<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[问题调试技巧]]></title>
    <url>%2F2019%2F02%2F14%2FJVM%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[JVM内存分析jmap分析内存状态123jmap -heap pid //简单查看整个JVM的内存状态jmap -histo pid //查看JVM堆中每个对象详细占用情况 四列依次表示： num instances bytes classnamejmap -dump:format=b,file=/data/filename pid //dump文件进行分析 -heap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051root@wchpc:/data# /opt/jdk1.7.0_79/bin/jmap -heap 4231Attaching to process ID 4231, please wait...Debugger attached successfully.Server compiler detected.JVM version is 24.79-b02using thread-local object allocation.Parallel GC with 4 thread(s)Heap Configuration: MinHeapFreeRatio = 0 MaxHeapFreeRatio = 100 MaxHeapSize = 805306368 (768.0MB) NewSize = 1310720 (1.25MB) MaxNewSize = 17592186044415 MB OldSize = 5439488 (5.1875MB) NewRatio = 2 SurvivorRatio = 8 PermSize = 21757952 (20.75MB) MaxPermSize = 85983232 (82.0MB) G1HeapRegionSize = 0 (0.0MB)Heap Usage:PS Young GenerationEden Space: capacity = 254279680 (242.5MB) used = 81008 (0.0772552490234375MB) free = 254198672 (242.42274475097656MB) 0.031857834648840205% usedFrom Space: capacity = 7340032 (7.0MB) used = 0 (0.0MB) free = 7340032 (7.0MB) 0.0% usedTo Space: capacity = 6815744 (6.5MB) used = 0 (0.0MB) free = 6815744 (6.5MB) 0.0% usedPS Old Generation capacity = 174063616 (166.0MB) used = 24795152 (23.646499633789062MB) free = 149268464 (142.35350036621094MB) 14.24487929746329% usedPS Perm Generation capacity = 26214400 (25.0MB) used = 25681496 (24.491783142089844MB) free = 532904 (0.5082168579101562MB) 97.96713256835938% used9444 interned Strings occupying 813664 bytes. -histo每个对象所占堆内存大小 问题：1、无法heap，报12Attaching to process ID 4231, please wait...Error attaching to process: sun.jvm.hotspot.debugger.DebuggerException: Can&apos;t attach to the process 确保jmap的jdk和pid的jdk是同一个 确保用户有权限执行 2、无法dump 确保pid文件存在 确保pid文件有权限执行 确保运行jdk用户和dump用户是同一个 由此问题进一步引申开来就会发现以下几点容易出问题的地方：1：没有生成 hsperfdata_xxx目录报错2：生成 hsperfdata_xxx目录但是没有pid文件3：没权限生成，例如指定的/tmp或者其他目录不可 写，包括2种情况，一是没权限，而是空间不够4：文件不可读，例如2个不同的用户来操作这个文件，一般是A用户启动java B用户来运行jvmstat等等5：java生成的目录 和 jvmstat 使用的目录文件不是同一个，这个可以见上面jdk update引起的bug导致 jhatjava自带的分析dump的工具，eclipse的mat插件更好用 jstack1234567891011121314jstack 是sun JDK 自带的工具，通过该工具可以看到JVM 中线程的运行状况，包括锁等待，线程是否在运行执行 jstack [pid] ,线程的所有堆栈信息&quot;http-8080-10&quot; daemon prio=10 tid=x0a949bb60 nid=0x884 waiting for monitor entry [...]&quot;http-8080-10&quot; 这个线程处于等待状态。 waiting for monitor entry 如果在连续几次输出线程堆栈信息都存在于同一个或多个线程上时，则说明系统中有锁竞争激烈，死锁，或锁饿死的现象。“http-8080-11” daemon prio=10 tix=xxx nid=xxx in object.wait() [...] java.lang.Thread.State:waiting (on object monitor)该表示http-8080-11的线程处于对象的Wait 上，等待其他线程的唤醒，这也是线程池的常见用法。“Low Memory Detector”daemon prio=10 tix=xx nid=xxx runnable [...] java.lang.Thread.State:runnable表示“Low Memory Detector” 的线程处于Runable状态，等待获取ＣＰＵ的使用权. 查看线程状态 一般用法jstack pid &gt; /data/pid.stack //导出到文件 一般常见的几个关键字 RUNNABLE：运行中状态。locked字眼表明该线程获得锁TIMED_WAITING：有时限的等待，wait（timeout）WAITING：无限期等待，wait（）或者park（）BLOCKED：阻塞，被sychronized（）block住了 关键语句： locked&lt;地址&gt;目标：拥有锁waiting on lock&lt;地址&gt;目标：等待锁waiting on：获取锁 ，wait()弃锁parking to wait for：基本的线程阻塞原语,不通过监视器在对象上阻塞。随concurrent包会出现的新的机制,不synchronized体系不同。 线程状态： runnable：RUNNABLE状态in Object.wait():等待区等待,状态为WAITING或TIMED_WAITING。waiting for monitor entry:进入区等待,状态为BLOCKED。waiting on condition:等待区等待、被park。sleeping:休眠的线程,调用了Thread.sleep()。 线程状态图： jstatref:https://blog.csdn.net/zhaozheng7758/article/details/8623549 使用jstack之内的工具调试的一般步骤：1、跑一个死循环while(true){Thread.sleep(500)}，模拟故障程序段。2、top查看cpu，快速定位进程。或者使用jps查看程序使用的进程。3、找到该进程，shift+h找到该进程中cpu最高的线程nid，4、jstack pid &gt; file 输出当前时刻的信息到文件5、将nid转为16进制echo &quot;obase=16;4003&quot;|bc，在导出的文件中查找线程信息 4003 –&gt; fa3 cpu的us sy各自代表的意义：us用户空间消耗cpu，指应用层。sy内核空间消耗cpu。 us高：应用消耗大量的CPU。java应用造成us高的原因主要是线程一直处于可运行（Runnable）状态，通常这些线程在执行无阻塞、循环、正则或纯粹的计算等任务造成的；另外一个可能也会造成us高的原因是频繁GC。sy高：表示linux花费了更多的时间在进行java线程切换。java应用造成这种现象的主要原因是启动的线程比较多，且这些线程多数处于不断的阻塞（例如锁等待，IO等待状态）和执行状态的变化过程中，这就导致了操作系统要不断地切换执行的线程，产生大量的线程上下文切换。 如果us高，sy低，则可以判断原因不是线程等待或者阻塞。sy高us低，可能是系统进行大量的线程调度，这个时候可以适当的降低线程数。在刚开始洗数据时线程数过多会出现这个问题。 参考:一个load飙高的过程分析，非常有价值 JDK大礼包一些常见的问题： 内存不足oom 内存泄露 线程死锁 锁争用 Java线程消耗cpu过高 … jps：jvm中运行的进程状态信息jstack：某个Java进程的线程堆栈信息jstat：JVM统计监测工具 jvm内存使用情况jinfo：指定pid的jvm信息jmap：dump 配合jhat ，eclipse mat分析堆栈信息jvisualvm：图形化工具 参考：https://blog.csdn.net/xiaofengnh/article/details/51900787 mysql死锁INFORMATION_SCHEMA库innodb_trx ## 当前运行的所有事务innodb_locks ## 当前出现的锁innodb_lock_waits ## 锁等待的对应关系 当数据库操作中出现死锁时可以查看该表找到死锁语句。 cyclicBarrier使用陷阱洗数据中使用了该类，经常抛一些不可预知的BrokenBarrierException，总结一下几点注意事项： cyclicBarrier相当于可重复使用的countDOwnLatch，需要注意以下几点：1、构造方法，第一种cyclicBarrier(int patties),cyclicBarrier(int parties,Runnable runnable)，第三种（parties,runnable,timeout）2、第一种单纯的定义批次线程数，第二种还定义了统一触发的操作，其由最后一个到达的线程执行。3、parties中的线程要么全部执行，要么全部失败。因此，在以下几种情况下，会抛出BrokenBarrierException: cyclicBarrier(Runnable)的Runnable任务中如果有对barrier的reset操作，会抛出BrokenBarrierException异常 任何一个线程在await()的过程中被中断，或任何一个线程抛出异常，抛出BrokenBarrierException异常，barrier置位破坏状态 调用一个坏的barrier，抛出BrokenBarrierException异常 洗数据过程中，10min开始抛出BrokenBarrierException异常。【原因】：线程在await过程中，被系统强制中断，导致barrier损坏，而后又重复调用坏的barrier，导致重复抛出BrokenBarrierException异常/分析该使用场景并不适合cyclicBarrier，最后舍弃。 【总结】：CyclicBarrier的等待线程不能有经常被中断的风险，如果有，就要做好重建机制。 12345678try&#123;&#125;catch()&#123; if(barrier.isBroken())&#123; rebuild(barrier); &#125;&#125; 最终洗数据的优化思路：BATCH_TASK_GENERATOR query 5000 datas each time, the 5000 datas will be splited into 10 500 size batch tasks, while the first batch task done, BATCH_TASK_GENERATOR will generate the next 5000 datas and repeat the pre task split steps. top第一行：当前时间 | 运行总时间 | 当前系统用户数 | 1、5、15min负载 **第二行：进程数 总共 | running | sleeping | stopped | 僵尸第三行：ＣＰＵ使用 用户使用（us） ｜ 内核占用（sys） | 改变过优先级的线程所占CPU（ni） | 空闲cpu（id） | io等待占比（wa） | 硬中断 | 软中断 注意：window和linux的cpu占用概念不一样，用户空间和内核空间。 第四行：内存状态total | used | free空闲 | buffers 缓存内存第五行：swap交换空间total | used | free | cached 不能只看free，第四行中used指内核控制的内存数，不一定都在正真的使用，还包括过去使用的现在可以重复利用的一部分内存。free是真正未使用过的内存，使用过的不会重新计入free，所以free会越来越少，一般不用担心。 经验计算公式：第四行free+第四行buffers+第五行cached==目前可用内存。 真正需要注意的是第五行的交换分区的used，如果经常变动，说明内核在不断的进行内存和swap的数据交换，此时内存不够用 第七行：一些参数进程id | 用户 | 优先级 ｜ … | cpu | 物理内存 ｜ 进程名 【排序】：有时候需要对ＣＰＵ排序或者排序，这么做。１、top２、b、x打开高亮3、shift+&gt;或者shift+&lt;改变排序序列 注意：shift+h会显示线程视图]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis学习（1）]]></title>
    <url>%2F2019%2F02%2F14%2FRedis%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Redis学习（1） REmote DIctionary Server：远程字典服务器，键值对存储，TCP协议传输。 1.2.1 存储结构支持的键值对数据类型： 字符串类型 散列类型 列表类型 集合类型 有序集合类型 不同于MySql的二维表形式存储结构，数据在Redis中的存储形式和程序中存储方式很接近。 1.2.2 内存存储与持久化同时存储于内存和硬盘中，解决了速度与持久化的问题。 Chapter 2 安装偶数版本为稳定版：2.8、3.0 安装：1234$ wget http://download.redis.io/releases/redis-4.0.0.tar.gz$ tar xzf redis-4.0.0.tar.gz$ cd redis-4.0.0$ make make install：将可运行指令复制到/usr/local/bin目录中，这样就不需要每次运行都进入安装目录了，相当于windows中的配置path路径。此操作需要sudo。 基本操作： redis-server：开启服务 redis-cli：redis自带的命令行客户端 redis-cli SHUTDOWN：正确的关闭方式 注：还可以通过修改配置文件的方式使redis随系统启动自动启动。 开始使用redis-cli进入命令行环境。12wch@ubuntu:~/redis-4.0.0/src$ redis-cli127.0.0.1:6379&gt; 表示已经进入到redis的命令环境了。输入相应的命令即可。123456wch@ubuntu:~/redis-4.0.0/src$ redis-cli127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; echo hi"hi"127.0.0.1:6379&gt; 数据库结构首先应该明白，redis实例、数据库、变量的区别。 redis实例：每开启一次redis-cli相当于开启了一个redis实例。实例与实例之间相互隔离，redis实例相当轻量，一个redis实例之占1MB左右的内存。不同应用的实例确保保存在不同的redis实例中。 数据库：每个redis实例中默认可以支持16个数据库，可以通过配置参数databases修改这个数量。通过SELECT 0、1、2、3。。15来切换不同的数据库。不同的数据库之间并不是完全隔离，比如FLUSHALL指令能够删除统一redis实例中的所有数据库中的数据。1234567891011121314151617181920212223127.0.0.1:6379&gt; config get databases#查看databases的配置，第一行是key。第二行是value1) "databases"2) "16"127.0.0.1:6379&gt; select 0#切换到第一个数据库，并set变量foo的值为test1OK127.0.0.1:6379&gt; set foo test1OK127.0.0.1:6379&gt; get foo"test1"127.0.0.1:6379&gt; select 1#切换了数据库，此时再查看foo变量的值，显示的是nil，既空结果。OK127.0.0.1:6379[1]&gt; get foo(nil)127.0.0.1:6379[1]&gt; 127.0.0.1:6379[1]&gt; flushall#刷新了所有内存中的数据，此操作对所以数据库起作用，但对不同的redis实例不起作用。OK127.0.0.1:6379[1]&gt; get foo(nil)127.0.0.1:6379[1]&gt; select 0OK127.0.0.1:6379&gt; get foo(nil)127.0.0.1:6379&gt; 变量：redis采用的是键值对的存储方式，既key-value对。 Chapter 3 入门之前学习了如何安装以及一些基本的操作，下面将学习主要的数据类型以及相应的命令。 目前redis的应用主要是缓存和队列为主，此过程还是不可省略的，首相，通过redis-cli命令开启一个redis实例进行学习。 3.1 基本指令1、 获取符合规则的键名列表 KEYS pattern：使用glob风格的通配符格式。1234127.0.0.1:6379[1]&gt; keys *#表示获取该数据库中的的所有数据的key，当前数据库有bar、foo两个数据1) "bar"2) "foo"127.0.0.1:6379[1]&gt; 注：redis中是不区分大小写的。 2、 判断一个键是否存在存在返回1，不存在返回01234127.0.0.1:6379&gt; exists foo(integer) 1127.0.0.1:6379&gt; exists faa(integer) 0 3、删除键可以删除一个或者多个，不支持通配符，**但是可以通过Linux的管道和xargs命令自己实现删除所有符合规则的键。 返回值是删除的键的个数1234567891011121314127.0.0.1:6379&gt; keys *1) "bar3"2) "bar5"3) "bar4"4) "foo"127.0.0.1:6379&gt; del bar3 bar4(integer) 2127.0.0.1:6379&gt; del bar5(integer) 1127.0.0.1:6379&gt; del bar5(integer) 0127.0.0.1:6379&gt; keys *1) "foo"127.0.0.1:6379&gt; 4、 获得键值的数据类型 TYPE key 12345678127.0.0.1:6379&gt; set foo 1OK127.0.0.1:6379&gt; type foostring127.0.0.1:6379&gt; lpush bar 1(integer) 1127.0.0.1:6379&gt; type barlist lpush表示向一个列表类型键中添加一个元素，如果键不存在中则创建它。 TYPE返回的类型一共有： string（字符串） hash（散列） list（列表） set（集合） zset（有序集合） 3.2 字符串类型一些特质： reids中最基本的数据类型 存储任何形式的字符串，包括二进制数据，图片 一个字符串类型键允许存储的数据的最大容量是512M。 3.2.2 命令1、 赋值与取值SET KEY valueGET KEY 2、 递增数字INCR key 此操作为原子操作（atomic operation）既多个客户端同时操作一个数据时，不会出现错误。 12345678127.0.0.1:6379&gt; set foo numOK127.0.0.1:6379&gt; incr foo#foo为string类型，会报错。INCR操作只支持数字形式的字符串。(error) ERR value is not an integer or out of range127.0.0.1:6379&gt; incr num1#如果不存在key，则创建一个，初始化为0，因此首次递增之后是1(integer) 1127.0.0.1:6379&gt; incr num2(integer) 1 3.2.3 应用1、 文章访问量统计使用名为post：文章ID：page.view的key来存储文章的访问量，每次访问使用INCR操作增加。 提示：命名没有强制的要求，但规范是用“对象类型：对象ID：对象属性”来命名一个键，如使用user:1:freinds来存储ID为1的用户的好友列表。多个单词推荐使用.来分割 2、 生成自增ID3、 存储文章数据 发布新文章时与redis操作相关的伪代码：123456#首先获取新文章的ID$postID = INCR posts:count#将博客文章的诸多元素序列化成字符串$serializedPost = serialize($title,$content,$author,$time)#serialize为PHP中将对象转为字符串的操作。相当于Javascript中的stringify操作。#把序列化候的字符串存入一个字符串类型键中SET post:$postID:data, $serializedPost 获取文章数据的伪代码如下 123456#从redis中读取文章数据$serializedPost = GET post:42:data#将文章数据反序列化成文章的各个元素$title, $content, $author, $time = unserialize($serializedPost)#获取并递增文章的访问数量$count = INCR post:42:page.view 除了使用序列化函数将文章的多个元素存入一个字符串类型键中外，还可以对每个元素使用一个字符串类型键来存储，这种方法将在3.3.3节中进行学习。 3.2.4 命令拾遗1、 增加指定的整数INCRBY key increment 1234127.0.0.1:6379&gt; get num2"4"127.0.0.1:6379&gt; incrby num2 5#将num2 = 4再加上5，等于9(integer) 9 2、 减少指定的整数DECR keyDECRBY key decrement 3、 增加指定浮点数INCRBYFLOAT KEY FLOAT4、 向尾部追加值APPEND key value 123456127.0.0.1:6379&gt; set sayHi helloOK127.0.0.1:6379&gt; append sayHi " world!"(integer) 12127.0.0.1:6379&gt; get sayHi"hello world!" 5、 获取字符串的长度STRLEN key12127.0.0.1:6379&gt; strlen sayHi(integer) 12 6、 同时获取/设置多个键值MGET KEY [KEY ...]MSET key value [key value ...] 12345678127.0.0.1:6379&gt; mset key1 v1 key2 v2 key3 v3OK127.0.0.1:6379&gt; get key2"v2"127.0.0.1:6379&gt; mget key1 key2 key31) "v1"2) "v2"3) "v3" 7、 位操作GETBIT key offsetSETBIT key offset valueBITCOUNT key [start] [end]//获取字符串类型键中值是1的二进制位个数BITOP operation destkey key [key ...] 比如：foo = “bar”的二进制存储是：01100010 01100001 01110010 123456789101112131415161718192021127.0.0.1:6379&gt; set foo barOK127.0.0.1:6379&gt; getbit foo 0(integer) 0127.0.0.1:6379&gt; getbit foo 1(integer) 1127.0.0.1:6379&gt; getbit foo 2(integer) 1127.0.0.1:6379&gt; getbit foo 3(integer) 0127.0.0.1:6379&gt; getbit foo 4(integer) 0127.0.0.1:6379&gt; getbit foo 5(integer) 0127.0.0.1:6379&gt; getbit foo 6(integer) 1127.0.0.1:6379&gt; getbit foo 7(integer) 0127.0.0.1:6379&gt; bitcount foo(integer) 10 BITOP: 位操作，AND、OR、XOR、NOT 12345678127.0.0.1:6379&gt; SET foo1 barOK127.0.0.1:6379&gt; SET foo2 aarOK127.0.0.1:6379&gt; BITOP OR result foo1 foo2(integer) 3127.0.0.1:6379&gt; GET result"car" BITPOS：redis2.8.7之后引入的操作，获取第一个二进制只0或1的位置。 123456127.0.0.1:6379&gt; GET result"car"127.0.0.1:6379&gt; BITPOS result 1(integer) 1127.0.0.1:6379&gt; BITPOS result 0(integer) 0 利用位操作可以非常紧凑地存储布尔值，记录100万个用户的性别只需要占用100kb多的空间，而且由于GETBIT和SETBIT的时间复杂度是O(1)，性能也很好。 3.3 散列类型3.3.1 介绍散列类型的值又是一种字典结构，存储了字段（field）和字段值的映射。值得注意的是：字段值只能是字符串，不支持其他的数据类型，既散列类型不能嵌套其他的类型数据。一个散列类型键可以包含2^32-1个字段（属性）。 提示：除了散列类型，Redis的其他数据类型同样不支持数据类型的嵌套。比如集合类型的每个元素只能是字符串，不能是另一个集合或散列表等。 散列类型的适用于：一个实体，有多重属性，每个属性名和字段对应，每个属性值和字段值对应。相较于关系型数据库，同一类的实体，其属性结构更加灵活，不存在字段冗余。 3.3.2 命令1、 赋值与取值HSET key field valueHGET key fieldHMSET key field value [field value ...]HMGET key field [field ...]HGETALL key 需求：car1对象，具有color、price、name属性。car2对象，具有color、price、name、engine属性。 123456789101112131415161718192021127.0.0.1:6379&gt; HSET car1 color red price 100000 name BMW(integer) 3127.0.0.1:6379&gt; HSET car2 color black price 200000 name BENZ engine turbine(integer) 4127.0.0.1:6379&gt; HGETALL car11) "color"2) "red"3) "price"4) "100000"5) "name"6) "BMW"127.0.0.1:6379&gt; HGETALL car21) "color"2) "black"3) "price"4) "200000"5) "name"6) "BENZ"7) "engine"8) "turbine" HSET操作不区分插入和更新操作，在返回值上进行区别（插入返1，更新返0） 2、 判断字段是否存在HEXISTS key field存在返回1，不存在返回03、 当字段不存在时赋值HSETNX key field value原子操作，不必担心竞态条件 4、 增加数字HINCRBY key field increment1234127.0.0.1:6379&gt; HGET car1 price "150000"127.0.0.1:6379&gt; HINCRBY car1 price 100000(integer) 250000 5、 删除字段HDEL key field [field ...]删除一个或者多个字段，返回的是被删除的字段个数。 3.3.3 实践1、 存储文章数据散列类型相较于字符串类型来说更加灵活，比如存储一篇文章的数据，如果使用字符串类型，那么整个文章对象作为一个整体，每次获取都需要整个获取。而使用散列类型，将文章中的title、content类型分离为不同的字段，在更新和查询操作时候更加的灵活，减少了竞态条件的发生，以及减少了数据量的产生。当然也可以使用多个字符串存储文章数据，如下。 而采用散列结构，其更加直观，也更容易维护。 2、 存储文章缩略名 3.3.4 命令拾遗1、 只获取字段名或者字段值HKEYS keyHVALS key2、 获取字段数量HLEN key 123456789101112127.0.0.1:6379&gt; HKEYS car11) "color"2) "price"3) "name"127.0.0.1:6379&gt; HVALS car11) "black"2) "250000"3) "BMW"127.0.0.1:6379&gt; HLEN car1(integer) 3127.0.0.1:6379&gt; HLEN car2(integer) 4 3.4 列表类型3.4.1 介绍 有序的字符串列表 双向链表结构，常用的操作是在头尾添加和删除，或者获取列表某一片段的元素。 一个列表类型键最多容纳2^32-1个元素。 3.4.2 命令1、 向列表两端增加元素LPUSH key value [value ...]向列表左端增加元素RPUSH key value [value ...]向列表右端增加元素同时还支持一次性添加多个元素123456789101112127.0.0.1:6379&gt; LPUSH numbers 1#左添加1(integer) 1127.0.0.1:6379&gt; LPUSH numbers 2 3#左添加2,3 先添加2，再左添加3.列表中为3,2(integer) 3127.0.0.1:6379&gt; RPUSH numbers 4 5#右添加4,5 先添加4，再右添加5。列表中为4,5(integer) 5127.0.0.1:6379&gt; LRANGE numbers 0 8#列表中的元素顺序是：3,2,1,4,51) "3"2) "2"3) "1"4) "4"5) "5" 2、 从列表两端弹出元素LPOP keyRPOP keyPOP表示移除并返回，POP之后元素就不存在列表中了、 1234127.0.0.1:6379&gt; LPOP numbers"3"127.0.0.1:6379&gt; LPOP numbers"2" 3、 获取列表中元素的个数LLEN key键不存在会返回0，时间复杂度为O(1)。不需要像SELECT COUNT(*)那样遍历整个数据表。4、 获得列表片段LRANGE key start stop起始从0开始，返回某一段的元素列表。包头且包尾。 12345678910127.0.0.1:6379&gt; LLEN numbers(integer) 3127.0.0.1:6379&gt; LRANGE numbers 0 21) "1"2) "4"3) "5"127.0.0.1:6379&gt; LRANGE numbers -2 -11) "4"2) "5" 也支持负索引，负数表示从左边开始计数。-1表示最后一个，-2表示倒数第二个，以此类推。获取整个列表的方法。LRANGE key 0 -1，或者stop序列取大于长度的值1234127.0.0.1:6379&gt; LRANGE numbers 0 -11) "1"2) "4"3) "5" 5、 删除列表中指定的值LREM key count value删除列表中前count个值中值为value的元素，返回值是实际删除的元素的个数。根据count的值的不同，LREM的执行方式略有差异： count&gt;0时，从左边开始删除。 count&lt;0时，从右边开始删除 count=0时，删除整个列表中value的值。 1234567891011121314151617181920212223242526272829303132333435363738127.0.0.1:6379&gt; LRANGE nums 0 -1 1) "0" 2) "1" 3) "1" 4) "1" 5) "1" 6) "1" 7) "2" 8) "2" 9) "2"10) "2"11) "2"12) "2"127.0.0.1:6379&gt; LREM nums 4 1#从左删除5个（从0开始，因此是5个）中值为1的元素，一共有4个为1，因此删除了4个(integer) 4127.0.0.1:6379&gt; LRANGE nums 0 -11) "0"2) "1"3) "2"4) "2"5) "2"6) "2"7) "2"8) "2"127.0.0.1:6379&gt; LREM nums -5 2#从右起删除5个（-1到-5，一共5个）元素中值为2的元素(integer) 5127.0.0.1:6379&gt; LRANGE nums 0 -1 1) "0"2) "1"3) "2"127.0.0.1:6379&gt; LRANGE nums 0 -11) "1"2) "2"127.0.0.1:6379&gt; LREM nums 0 1#删除整个列表中值为1 的元素(integer) 1127.0.0.1:6379&gt; LRANGE nums 0 -11) "2" 3.4.3 实践1、 存储文章ID列表此做法的好处是，删除文章时，性能更高，可以很轻松的统计出文章的总数。细枝末节在此不一一学习了。2、 存储评论列表 3.4.4 命令拾遗1、 获取/设置指定索引的元素值LINDEX key indexLSET key index value2、 只保留列表指定片段LTRIM key start stop如只保存近100条的日志记录，可以： 12LPUSH logs $newLogLTRIM logs 0 99 3、 向列表中插入元素LINSERT key BEFORE|AFTER pivot value//pivot:中心点从左到右查找pivot值的元素，根据BEFORE还是AFTER决定插入value到前还是后。4、 将元素从一个列表转到另一个列表RPOPLPUSH source destinationRPOP+LPUSH。先右弹出元素，在左添加到目标列表。（一次只对一个元素进行操作） 123456789101112131415161718192021222324252627127.0.0.1:6379&gt; rpush source 0(integer) 1127.0.0.1:6379&gt; rpush source 1(integer) 2127.0.0.1:6379&gt; rpush source 2(integer) 3127.0.0.1:6379&gt; lrange source 0 -11) "0"2) "1"3) "2"127.0.0.1:6379&gt; rpush des 3(integer) 1127.0.0.1:6379&gt; rpush des 4(integer) 2127.0.0.1:6379&gt; rpush des 5(integer) 3127.0.0.1:6379&gt; lrange des 0 -11) "3"2) "4"3) "5"127.0.0.1:6379&gt; rpoplpush source des#一次只对一个元素进行了操作，并返回这个元素的值"2"127.0.0.1:6379&gt; lrange des 0 -1 1) "2"2) "3"3) "4"4) "5" 注意：当source和destination相同时会发生什么？将队尾的元素不断放置到队首。 12345678910111213141516127.0.0.1:6379&gt; lrange des 0 -11) "2"2) "3"3) "4"4) "5"127.0.0.1:6379&gt; rpoplpush des des"5"127.0.0.1:6379&gt; rpoplpush des des"4"127.0.0.1:6379&gt; rpoplpush des des"3"127.0.0.1:6379&gt; lrange des 0 -11) "3"2) "4"3) "5"4) "2" 3.5 集合类型集合类型：无序，唯一，2^32-1个元素。内部使用了值为空的散列表，既字段值为空，因此添加和删除的复杂度为O(1)。 3.5.2 命令1、 增加/删除元素SADD key member [member ...]SREM key member [member ...]返回成功添加或者删除的元素个数 2、 获得集合中的所有元素SMEMBERS key 3、 判断元素是否在集合中SISMEMBER key member存在返回1，不存在返回0，复杂度为O(1) 4、 集合间运算 SDIFF key [key ...]差集，SDIFF setA setB表示在A中取出A、B的公共元素。支持同时传入多个键，从从左到右的顺序依次计算。 SINTER key [key ...]取交集，SINTER setA setB表示取出A、B的公共元素。支持多个键同时传入。 SUNION key [key ...]取并集，支持同时传入多个键。 3.5.4 命令拾遗1、 获取元素个数SCARD key2、 进行集合运算并将结果存储SDIFFSTORE destination key [key ...]SINTERSTORE destination key [key ...]//insterctionSUNIONSTORE destination key [key ...] 3、 随机获取元素SRANDMEMBER lettersSRANDMEMBER key count随机获取元素，count表示元素的数量 count为正，从集合取count个不重复的元素 count为负，可能重复的元素。 4、 从集合中弹出一个元素SPOP key弹出后会从集合中去除 3.6 有序集合类型3.6.1 介绍有序集合在集合类型的基础上为集合中的每个元素关联了一个分数，按照分数进行排序。 有序集合在某些方面和列表类型有些相似：（1）二者都是有序的。（2）都可以获得某一范围的元素差异：（1）列表类型通过双线链表实现，获取靠近两端的数据速度极快，访问中间数据的速度慢，既增删快，访问慢。更加适合如“新鲜事”或“日志”这样很少访问中间元素的应用。（2）有序集合使用的是散列表和跳跃表实现，即时访问中间的数据速度也很快。（3）列表中不能简单的调整某个元素的位置，但是有序集合可以，只要更改这个元素的分数即可。（4）有序集合比列表类型更加消耗内存。 3.6.2 命令1、 增加元素ZADD key score member [score member ...]向有序集合中添加一个元素和该元素的分数，如果已经存在该元素，则更新。返回的是添加进集合的元素个数，不包括更新的元素。1127.0.0.1:6379&gt; ZADD zset 86 mike 88 peter 89 jason#score可以是整数也可以是双精度浮点型，重复添加起到了更新数据的作用。 2、 获取元素的分数ZSCORE key member12127.0.0.1:6379&gt; zscore zset peter"88" 3、 获取排名在某个范围的元素列表ZRANGE key start stop [WITHSCORES]//正序ZREVRANGE key start stop [WIHSCORES]//逆序如需获取排名的分数。加上withscores参数。 时间复杂度是O(logN+M)，N为有序集合的元素数，M为返回的元素个数。分数相同按照自然顺序排序，中文按照具体的编码方式。4、 获取指定分数范围的元素ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 1234567891011127.0.0.1:6379&gt; zrangebyscore zset 88 89 withscores1) "peter"2) "88"3) "jason"4) "89"127.0.0.1:6379&gt; zrangebyscore zset 88 (89 withscores#加(表示不包括该分数1) "peter"2) "88"127.0.0.1:6379&gt; zrangebyscore zset (88 89 withscores1) "jason"2) "89" score还支持无穷大，inf表示无穷大 1234127.0.0.1:6379&gt; zrangebyscore zset -inf +inf#正无穷到负无穷1) "mike"2) "peter"3) "jason" 0 -1 表示获取全部的集合元素，LIMIT 1 3表示获取符合条件的第2个（1）元素开始的3（3）个元素。 1234567127.0.0.1:6379&gt; zrange zset 0 -1 1) "mike"2) "peter"3) "jason"127.0.0.1:6379&gt; zrangebyscore zset -inf +inf limit 1 31) "peter"2) "jason" 5、 增加某个元素的分数ZINCRBY key increment member返回的是更改之后分数负数表示减分。 3.6.3 实践1、 实现按点击量排序2、 改进按时间排序 3.6.4 命令拾遗1、 获取集合中元素的数量ZCARD key2、 获取指定分数段的元素个数ZCOUNT key min max“（”表示不包含，inf表示无穷大3、 删除一个或者多个元素ZREM key member [member ...]4、 按照排名范围删除元素ZREMRANGEBYCOUNT key start stop排名从0开始。返回到是被删除的元素的个数5、 按照分数范围删除元素ZREMRANGEBYSCORE key min max6、 获取元素的排名ZRANK key memberZREVRANK key member7、 计算有序集合的交集ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX] destination：目标有序集合 numskey：参与运算的键的个数 key：键名 WEIGHTS：每个键的权重，既每个集合中的元素在运算中所占的权重 AGGREGATE：运算方式，默认为SUM求和运算。其次是最小值和最大值 1234567891011121314151617181920212223242526272829303132127.0.0.1:6379&gt; zadd ss1 1 a 2 b 3 c(integer) 3127.0.0.1:6379&gt; zadd ss2 10 a 20 b 30 c(integer) 3127.0.0.1:6379&gt; zinterstore ss3 2 ss1 ss2 weight 0.1 1(error) ERR syntax error127.0.0.1:6379&gt; zinterstore ss3 3 ss1 ss2 weight 0.1 1(error) ERR syntax error127.0.0.1:6379&gt; zinterstore ss3 2 ss1 ss2 weights 0.1 1(integer) 3127.0.0.1:6379&gt; zrange 0 -1 ss3(error) ERR value is not an integer or out of range127.0.0.1:6379&gt; zrange ss3 0 -11) "a"2) "b"3) "c"127.0.0.1:6379&gt; zrange ss3 0 -1 withscores1) "a"2) "10.1"3) "b"4) "20.199999999999999"5) "c"6) "30.300000000000001"127.0.0.1:6379&gt; zinterstore ss3 2 ss1 ss2 weights 1 0.1(integer) 3127.0.0.1:6379&gt; zrange ss3 0 -1 withscores1) "a"2) "2"3) "b"4) "4"5) "c"6) "6" Chapter 4 进阶4.1 事务利用Redis解决关注与被关注的伪代码逻辑 1234127.0.0.1:6379&gt; sadd user:1:following 2(integer) 1127.0.0.1:6379&gt; sadd user:2:follower 1(integer) 1 如果在执行第一段代码中，程序被终止。则会出现用户1关注了2，但是在2的列表中并没有1的情况发生，解决此类问题的办法就是事务。 4.1.1 概述MULTI、EXEC指令123456789127.0.0.1:6379&gt; multi#进入事务OK127.0.0.1:6379&gt; sadd user:1:following 2QUEUED127.0.0.1:6379&gt; sadd user:2:follower 1QUEUED127.0.0.1:6379&gt; exec#跳出事务1) (integer) 02) (integer) 0 两个操作进入queued队列中等待exec指令之后，依次执行。保证了执行的连续性。 发生错误怎么办？ 12345MULTIsentenceAsentenceBsentenceCEXEC 1、 语法错误执行之前会被发现，2.6之后版本，所有的语句将不会被记录2、 运行错误运行时才发现，redis不提供回滚机制（简洁、快速），正确的语句被执行。需要开发人员手动进行纠错。因此在执行事务时候应尽量避免运行错误。 4.1.3 WATCH命令介绍WATCH命令可以监控一个或多个键，一旦其中一个键被修改（或删除），之后的事务就不会再执行了。监控一直持续到EXEC命令执行、 12345678910111213141516171819202122127.0.0.1:6379&gt; SET key 1OK127.0.0.1:6379&gt; WATCH key#监控key的值的变化OK127.0.0.1:6379&gt; SET key 2#发生修改，之后事务不起作用，直至EXEC指令，结束监控OK127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; SET key 3QUEUED127.0.0.1:6379&gt; EXEC#事务不起作用，返回空(nil)127.0.0.1:6379&gt; GET key#此时key值仍然是2"2"127.0.0.1:6379&gt; MULTI#事务再次修改，此时已经跳出监控状态，修改成功OK127.0.0.1:6379&gt; SET key 3QUEUED127.0.0.1:6379&gt; EXEC1) OK127.0.0.1:6379&gt; GET key"3" 提示：由于WATCH命令只是当被监控的键值被修改后阻止之后的一个事务的执行，而不能保证其他客户端不修改这一键值，所以我们需要在EXEC执行失败之后重新执行整个函数。既重新进行监控。 如果不需要监控某个键值的值，可以使用UNWATCH指令来保证下一个事务不收到影响。 4.2 过期时间4.2.1 命令介绍EXPIRE指令设置一个键值的过期时间。到期redis自动删除他。EXPIRE key seconds单位是秒，例如如下代码： 1234567891011121314127.0.0.1:6379&gt; SET session userOK127.0.0.1:6379&gt; EXPIRE session 60#设置过期时间60秒，返回1(integer) 1127.0.0.1:6379&gt; ttl session#返回剩余生命周期，秒(integer) 55127.0.0.1:6379&gt; ttl session(integer) 51127.0.0.1:6379&gt; SET session2 user2OK127.0.0.1:6379&gt; ttl session2#返回-1表示，永远不过期(integer) -1127.0.0.1:6379&gt; ttl session#已过期，返回-2(integer) -2 PERSIST表示将键重新设置为永久的，成功返回1，否则返回0（键不存在或者本身就是永久的。） 12345678910127.0.0.1:6379&gt; persist session(integer) 0127.0.0.1:6379&gt; persist session2(integer) 0127.0.0.1:6379&gt; expire session2 20(integer) 1127.0.0.1:6379&gt; persist session2(integer) 1127.0.0.1:6379&gt; ttl session2(integer) -1 除了PERSIST外，GET、GETSET指令也能修改过期时间为永久。此外重复的EXPIRE操作也能刷新生命周期。 其他的键INCR、LPUSH、HSET、ZREM均不会影响到键的生命周期。 PEXPIRE：毫秒单位的生命周期。 提示：生命到期并不会改变WATCH的监视状态。 4.2.2 实现访问频率限制之一通过EXPIRE来实现，大概思路是：维护一个访问次数的变量rate：limiting：用户ID ，第一次访问设置生命周期为60秒，在这60秒内的访问次数不能大于设定的值。 4.2.4 实现缓存redis有不同的缓存策略，可以通过修改配置文件中。maxmemory、maxmemory-policy参数确定删除哪一个键，从而降低内存的消耗。 Redis的缓存策略有：LRU、RANDOM、TTL、NOEVICTION 4.3 排序4.3.1 有序集合的集合操作有序集合只有ZINTERSTORE和ZUNIONSTORE，没有ZINTER和ZUNION。 可以自己实现ZINTER（既直接返回结果） 12345MULTIZINTERSTORE tempkey ...ZRANGE tempkey ...DEL tempkeyEXEC 4.3.2 SORT命令SORT命令可以对列表类型、集合类型、有序集合类型键进行排序 对有序集合排序时会忽略元素的分数，而直接对元素的自然顺序进行排序。 对字符串排序需要加入ALPHA参数 12345678910127.0.0.1:6379&gt; sort myzset alpha1) "abandon"2) "jaki"3) "john"4) "kury"5) "lucy"6) "mik"7) "miki"8) "shane"9) "tomson" DESC和ASC在此处同样适用，只需要加载语句的最后即可。 LIMIT在此处也同样适用，当需要分页时可以使用。LIMIT n m表示跳过之前的n个数据，取m个数据出来 12345678910111213141516127.0.0.1:6379&gt; sort myzset alpha asc1) "abandon"2) "jaki"3) "john"4) "kury"5) "lucy"6) "mik"7) "miki"8) "shane"9) "tomson"127.0.0.1:6379&gt; sort myzset alpha asc limit 2 51) "john"2) "kury"3) "lucy"4) "mik"5) "miki" 4.3.3 BY参数当需要按照某个指定的属性进行排序时，SORT BY就登场了。 语法：BY参考键。参考键可以是字符串类型或者是散列类型键 的某个字段（表示为键名-&gt;字段名），如果提供了BY参数键，SORT将不再按照元素自身的值进行排序，而是对每个元素使用元素的值替换参考键中第一个“*”并获取其值，然后依据该值对元素排序。 BY参数的语法为“BY参考键”。其中参考键可以是字符串类型键或者是散列类型键的某个字段（表示为键名—&gt;字段名）。如果提供了BY参数，SORT命令将不再依据元素自身的值进行排序，而是对每个元素使用元素的值替换参考键中的第一个“*”并获取其值，然后依据该值对元素排序。应该时刻记住，除了hash类型外，其余类型不支持类型嵌套。 4.3.4 GET参数SORT命令的GET参数，使得排序之后不再返回元素的值，而是可以GET元素的某个属性，GET和BY参数一样，支持字符串类型和散列类型的键，并使用“*”作为占位符。 记住一句话，*是占位符，排序的时候将被替换掉。 多个GET还可以叠加使用，就好像select a.name b.name from table1 a, table b sort by a.time一样。 在设定了GET参数之后还可以通过GET # 表示返回元素本身的值。 SORT tag:ruby:posts BY post:*-&gt;time DESC GET post:*-&gt;title GET post:*-&gt;time GET # 4.3.5 STORE参数STORE参数表示将排序结果保存到sort.result中。SORT tag:ruby:posts BY post:*-&gt;time DESC GET post:*-&gt;title GET post:*-&gt;time GET # STORE sort.result保存后的类型为列表类型 4.3.6 性能优化SOTR的时间复杂度是O（n+mlogm），n：需要排序的元素个数。m：要返回到元素个数。 1、 尽可能的减少待排序中元素的数量（减小n）2、 使用LIMIT参数只获取需要的数据（减小M）3、 如果要排序的数量较大，尽可能使用STORE参数将结果缓存。 4.4 消息通知4.4.1 任务队列生产者-消费者模式。任务队列的好处：1、 松耦合 2、 易于扩展 4.4.2 使用Redis实现任务队列指令：BRPOP、BLPOP阻塞弹出，当没有元素时一直阻塞，可以设置阻塞时间。0表示一直阻塞。如： 1234567127.0.0.1:6379&gt; BLPOP queue 5#没有元素，则阻塞5秒后返回(nil)(5.04s)127.0.0.1:6379&gt; BLPOP queue 0#一直阻塞的状态，直到另一个redis-cli实例向任务队列添加元素，才会输出。1) "queue"2) "hello"(20.21s) 4.4.3 优先队列优先队列用于优先执行某一方面的任务。 BRPOP、BLPOP可以传多个列表键，根据传入的先后顺序保证优先级。比如： 1234567127.0.0.1:6379&gt; lpush queue1 queue1(integer) 1127.0.0.1:6379&gt; lpush queue2 queue2(integer) 1127.0.0.1:6379&gt; brpop queue2 queue1 0#先弹出的是queue2的元素，因为它在BRPOP参数的前面。1) "queue2"2) "queue2" 4.4.4 发布/订阅模式SUBSCRIBE和PUBLISH 一个客户端SUBSCRIBE一个频道之后，进入接受消息的状态。一个客户端可同时订阅多个channel 另一客户端可以通过PUBLISH向指定的channel发送消息，所有订阅该channel的客户端会受到该消息。 使用UNSUBSCRIBE取消订阅。 客户端1：SUBSCRIBE channel.1 客户端2：PUBLISH channel.1 hi#向频道发送消息，此时订阅了该频道的客户端会接受到该message类型的消息。 客户端3：SUBSCRIBE channel.1#此时再订阅之前的消息并不会读取，只有再次有客户端向该频道发送消息时才会显示。UNSUSCRIBE channel.1#取消订阅该频道 4.4.5 按照规则订阅PSUBSCRIBE，订阅指定的规则，规则支持glob风格通配符格式。 123456789101112131415161718192021127.0.0.1:6379&gt; psubscribe channel.?*#该条语句订阅了无数个频道，规则是只要是channel.开头的频道都可以。因此不管向那个符合规则的频道发布消息，都会被接收到。Reading messages..、 (press Ctrl-C to quit)1) "psubscribe"2) "channel.?*"3) (integer) 11) "pmessage"2) "channel.?*"3) "channel.2"4) "hi"1) "pmessage"2) "channel.?*"3) "channel.233"4) "ho"1) "pmessage"2) "channel.?*"3) "channel.2883738"4) "nihao"1) "pmessage"2) "channel.?*"3) "channel.23738"4) "dajiahao" PUNSUBSCRIBE退订指定规则的频道，没有参数会退订所有的频道。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（一）]]></title>
    <url>%2F2019%2F02%2F14%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MyBatis学习笔记（一）mybatis介绍，快速入门个人笔记，如有错误，恳请批评指正。 1. Mybatis介绍MyBatis 世界上流行最广泛的基于SQL语句的ORM框架，由Clinton Begin 在2002 年创建，其后，捐献给了Apache基金会，成立了iBatis 项目。MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。 2. 与Hibernate比较a. 学习成本：MyBatis简单易学（特别是有SQL语法基础的人），较接近JDBCb. 程序灵活性：MyBatis直接使用SQL，灵活性高c. 程序执行效律：MyBatis效律高d. 可移植性：hibernate较好（与数据库关联在配置中完成，HQL语句与数据库无关） mybatis提供一种“半自动化”的ORM实现。这里的“半自动化”，是相对Hibernate等提供了全面的数据库封装机制的“全自动化”ORM实现而言，“全自动”ORM实现了POJO和数据库表之间的映射，以及SQL的自动生成和执行。而mybatis的着力点，则在于POJO与SQL之间的映射关系。 3. 适用场所MyBatis是一个灵活的DAO层解决方案，满足较高的性能要求，可以在很多场合使用，但一般以下场合不建议使用：a． 需要支持多种数据库或数据库有移植要求b． 完全动态sql，例如：字段要动态生成c． 使用的不是关系数据库 4. 开发步骤 新建JAVA项目或WEB项目 部署jar包（包括数据库驱动包）：使用MyBatis需要先下载jar包：下载地址http://code.google.com/p/mybatis 编写主配置文件 myBatis-config.xml 创建数据库及表（如已创建，可省略）newfile.sql 创建实体类及SQL映射文件 XXXMapper.xml 编写数据库接口及实现 编写测试类及测试 5. 开发示例 新建项目 导包导入mybatis和数据库驱动包、日志包（配置日志配置文件）。 创建myBatis-config.xml（可以参考用户手册）。 12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;&lt;!--可以设置多个运行环境，满足不同需要，例如 开发、测试、生产环境上有不同配置 --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt;&lt;!--事务管理类型主要有jdbc和managed,前者依赖于数据源获得的连接，后者依赖于容器 --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;!-- 如果数据库设置为UTF-8,则URL参数连接需要添加?useUnicode=true&amp;amp;characterEncoding=UTF-8，如下 --&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=UTF-8" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="root" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; sql建表 123456789101112131415drop database if exists mybatis;create database mybatis CHARACTER SET UTF8;use mybatis;create table dept( dept_id int primary key auto_increment, dept_name varchar(50), dept_address varchar(50));insert into dept(dept_name,dept_address) values('研发部一部','北京');insert into dept(dept_name,dept_address) values('研发部二部','广州');insert into dept(dept_name,dept_address) values('研发部三部','深圳');select * from dept; 创建实体类：Dept.java 创建SQL映射文件及修改主配置文件SQL映射文件：DeptMapper.xml（可以参考用户手册） 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 命名空间可以任选命名，但最好要定义一定规则，便于后继的使用 --&gt;&lt;mapper namespace="cn.itcast.entity.DeptMapper"&gt; &lt;!-- 一般在查询时使用--&gt; &lt;resultMap type="cn.itcast.entity.Dept" id="deptResultMap"&gt; &lt;id property="deptId" column="dept_id"/&gt; &lt;result property="deptName" column="dept_name"/&gt; &lt;result property="deptAddress" column="dept_address"/&gt; &lt;/resultMap&gt; &lt;!-- 定义插入的sql语句，通过命名空间+id方式被定位 --&gt; &lt;insert id="insert" parameterType="cn.itcast.entity.Dept"&gt; insert into dept(dept_name,dept_address) values(#&#123;deptName&#125;,#&#123;deptAddress&#125;); &lt;/insert&gt;&lt;/mapper&gt; sql映射文件建立了POJO与SQL之间的依赖关系。此时需要更新myBatis-config.xml中对sql映射配置的应用。 修改myBatis-config.xml，加入映射文件信息 12345678910111213&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; ………… &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="cn/itcast/entity/DeptMapper.xml" /&gt; &lt;/mappers&gt; &lt;/configuration&gt; 编写数据库操作包括操作接口及实现，接口略，实现类为：DeptDaoImpl.java 12345678910111213141516171819202122232425262728293031323334353637383940414243public class DeptDaoImpl &#123; private SqlSession session = null; /* *1.读取配置文件信息 *2.构建session工厂 *3.创建session *4.开启事务 *5.处理数据 *6.提交/回滚数据 *7.关闭session */ @Deprecated public int save(Dept dept)&#123; int i = 0; String path = "mybatis-config.xml"; SqlSession session = null; Reader reader = null; try &#123; reader = Resources.getResourceAsReader(path); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader); session = sessionFactory.openSession(); //参数1：定义的sql 参数2：sql的值// SQL映射文件定义的命名空间+SQL语句的ID定位SQL语句 i = session.insert("cn.ustb.entity.DeptMapper.insertDept", dept); session.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback(); &#125; finally&#123; if(reader != null)&#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(session != null)&#123; session.close(); &#125; &#125; return i; &#125; 编写测试类需要导入junit包 12345678910111213141516171819202122public class DeptTest &#123; private static DeptDaoImpl deptDaoImpl; @BeforeClass public static void setUpBeforeClass() throws Exception &#123; deptDaoImpl=new DeptDaoImpl(); &#125; @AfterClass public static void tearDownAfterClass() throws Exception &#123; deptDaoImpl=null; &#125; @Test public void testInsert() &#123; Dept dept=new Dept(); dept.setDeptName("市场部"); dept.setDeptAddress("深圳"); int i=deptDaoImpl.insert(dept); System.out.println("受影响行数："+i); &#125;&#125; 6. 基本的CRUD操作 准备工作（继续使用前面的库表和代码） 别名与自定义别名 内置别名对常用的 java 类型，已经内置了一些别名支持。这些别名都是不区分大小写的。（详细参看用户手册） 自定义别名在myBatis的主配置文件给cn.itcast.entity.Dept类创建别名Dept,后继的DeptMapper.xml配置文件中可以使用别名 1234&lt;!-- 通过别名简化对类的使用 --&gt;&lt;typeAliases&gt; &lt;typeAlias type="cn.ustb.entity.Dept" alias="Dept" /&gt;&lt;/typeAliases&gt; MyBatisUtil工具类封装了获取及关闭session的操作，并保证在线程池中始终只有一份session，节省了资源。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class MybatisSessionFactory &#123; private static final ThreadLocal&lt;SqlSession&gt; threadLocal = new ThreadLocal&lt;SqlSession&gt;(); private static SqlSessionFactory sqlSessionFactory = null; private static String CONFIG_FILE_LOCATION = "myBatis-config.xml"; private static String configFile = CONFIG_FILE_LOCATION; static&#123; buildSessionFactory(); &#125; public static SqlSession getSession() throws Exception&#123; SqlSession session = threadLocal.get(); if(session == null)&#123; if(sqlSessionFactory == null)&#123; buildSessionFactory(); &#125; session = (sqlSessionFactory!=null)? sqlSessionFactory.openSession():null; threadLocal.set(session); &#125; return session; &#125; public static void closeSession()&#123; SqlSession session = threadLocal.get(); threadLocal.set(null); if(session != null )&#123; session.close(); System.out.println("***Success Session Closing***"); &#125; &#125; public static void buildSessionFactory()&#123; Reader reader = null; try &#123; reader = Resources.getResourceAsReader(CONFIG_FILE_LOCATION); sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println("%%%%Create sessionFactory error%%%%"); &#125;finally&#123; if(reader!=null)&#123; try &#123; reader.close(); System.out.println("***Success reader Closing***"); &#125; catch (Exception e) &#123; System.out.println("%%%% Closing sessionFactory error %%%%"); e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 新增操作：INSERT修改DeptMapper.xml配置insert语句（使用之前配置好的别名） 1234&lt;!--parameterType="Dept"不写时，也能自动根据代码传递的参数Dept自动匹配 内容--&gt;&lt;insert id="insert" parameterType="Dept"&gt; insert into dept(dept_name) values(#&#123;deptName&#125;);&lt;/insert&gt; 修改DeptDaoImpl.java新增方法（使用MyBatisUtil.java工具类）： 1234567891011121314151617public int save2(Dept dept)&#123; int i = 0; SqlSession session = null; try &#123; session = MybatisSessionFactory.getSession(); //参数1：定义的sql 参数2：sql的值 i = session.insert("cn.ustb.entity.DeptMapper.insertDept", dept); session.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback(); &#125; finally&#123; MybatisSessionFactory.closeSession(); &#125; return i; &#125; 删除操作：DELETE修改配置文件deptMapper.xml，添加 123&lt;delete id="delete" parameterType="Dept"&gt; delete from dept where dept_id=#&#123;deptId&#125;&lt;/delete&gt; 修改DeptDaoImpl.java，添加delete方法： 12345678910111213141516public boolean delete(Integer id)&#123; boolean state = false; try &#123; session = MybatisSessionFactory.getSession(); int i = session.delete("cn.ustb.entity.DeptMapper.deleteDept",id); session.commit(); if(i!=0)state = true; &#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback(); state = false; &#125;finally&#123; MybatisSessionFactory.closeSession(); &#125; return state;&#125; 修改操作：UPDATE修改配置文件deptMapper.xml，添加update语句。传入的值用spel表达式#{}获取 123&lt;update id="update" parameterType="Dept"&gt; update dept set dept_name=#&#123;deptName&#125; ,dept_address=#&#123;deptAddress&#125; where dept_id=#&#123;deptId&#125; &lt;/update&gt; 修改DeptDaoImpl.java，添加update方法： 1234567891011121314public int update (Dept dept)&#123; int i = 0; try &#123; session = MybatisSessionFactory.getSession(); i = session.update("cn.ustb.entity.DeptMapper.updateDept", dept); session.commit();//necessary &#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback(); &#125;finally&#123; MybatisSessionFactory.closeSession(); &#125; return i;&#125; 查询操作：SELECT 查询操作（返回单条记录）配置deptMapper.xml文件的resultMap元素及SQL查询语句 12345678910111213&lt;!-- 表字段和实体属性命名一致时可以不配置 --&gt; &lt;resultMap id="deptResultMap" type="Dept"&gt; &lt;id property="deptId" column="dept_id"/&gt; &lt;result property="deptName" column="dept_name"/&gt; &lt;result property="deptAddress" column="dept_address"/&gt; &lt;/resultMap&gt;&lt;!—省略其它的配置信息 --&gt; &lt;!—返回单条记录，表字段和对应实体属性命名一致时可以不使用resultMap属性配置，直接使用resultType="返回的全类名或别名"，建议使用前者;查询结果为所有字段时，也可以用*表示 --&gt;&lt;!-- 单个查询 --&gt;&lt;!-- *号理论可以，但会降低性能，*转字段需要过程 --&gt;&lt;select id="selectDept" parameterType="integer" resultMap="deptResultMap"&gt;&lt;!-- 指定返回的类型，按照Map定义的规则封装对象 --&gt; select dept_id,dept_name,dept_address from dept where dept_id = #&#123;deptId&#125;&lt;/select&gt; 修改DeptDaoImpl.java，添加selectOne方法： 1234567891011121314public Dept selectOne(Integer id)&#123; Dept dept = null; try &#123; session = MybatisSessionFactory.getSession(); dept = session.selectOne("cn.ustb.entity.DeptMapper.selectDept",id); session.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback(); &#125;finally&#123; MybatisSessionFactory.closeSession(); &#125; return dept;&#125; 查询操作（返回多条记录）修改配置文件deptMapper.xml，添加 12345678910&lt;!-- 返回多条记录，返回结果配置的不是集合类型，而是集合元素的类型；参数也可以通过Map等方式封装 --&gt; &lt;!-- 多个查询 --&gt;&lt;!-- 如果返回的是list，resultMap指定的值是list集合里面的类型 --&gt;&lt;select id="selectMultiDept" parameterType="String" resultMap="deptResultMap"&gt; select * from dept where dept_address = #&#123;deptAddress&#125;&lt;/select&gt;&lt;!-- 参数类型用map的多个查询 --&gt;&lt;select id="selectMultiDeptUseMapParamter" parameterType="Map" resultMap="deptResultMap"&gt; select * from dept where dept_address like #&#123;deptAddress&#125;&lt;/select&gt; 修改DeptDaoImpl.java，添加selectList方法： 123456789101112131415161718192021222324252627public List&lt;Dept&gt; selectMulti(String deptAddress)&#123; List&lt;Dept&gt; list = null; try &#123; session = MybatisSessionFactory.getSession(); list = session.selectList("cn.ustb.entity.DeptMapper.selectMultiDept", deptAddress); session.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback(); &#125; return list; &#125; /* * 模糊查询在sql中添加like，在传入条件中添加% */ public List&lt;Dept&gt; selectMultiUserMapParameter(Map deptAddresses)&#123; List&lt;Dept&gt; list = null; try &#123; session = MybatisSessionFactory.getSession(); list = session.selectList("cn.ustb.entity.DeptMapper.selectMultiDeptUseMapParamter", deptAddresses); session.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback(); &#125; return list; &#125; 测试类代码： 123456789@Test public void testSelectList() &#123; Map map=new HashMap(); map.put("deptName", "%研%"); List&lt;Dept&gt; depts=deptDaoImpl.selectList(map); for(Dept dept:depts)&#123; System.out.println("dept:"+dept); &#125;&#125;]]></content>
      <categories>
        <category>实用技术</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>myBatis</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（三）]]></title>
    <url>%2F2019%2F02%2F14%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MyBatis学习笔记（三）常用批量操作，Spring与myBatis整合，简化配置个人笔记，如有错误，恳请批评指正。 常用批量操作批量新增部门映射文件定义SQL12345678910111213141516&lt;!-- 批量增加 --&gt; &lt;!-- insert into dept(dept_name,dept_address) values(name1,address1)(name2,address2)...(); --&gt; &lt;sql id="key"&gt; &lt;trim suffixOverrides=","&gt; dept_name, dept_address, &lt;/trim&gt; &lt;/sql&gt; &lt;insert id="insertDeptList"&gt; insert into dept( &lt;include refid="key"&gt;&lt;/include&gt; ) values &lt;foreach collection="list" item="dept" separator=","&gt; (#&#123;dept.deptName&#125;,#&#123;dept.deptAddress&#125;) &lt;/foreach&gt; &lt;/insert&gt; 编写批量添加部门方法数据操作类定义批量添加部门的方法123456789101112131415public int insertDeptList(List list)&#123; int i = 0; try &#123; session = MybatisSessionFactory.getSession(); i = session.insert("cn.ustb.entity.DeptMapper.insertDeptList", list); session.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback(); &#125; finally&#123; MybatisSessionFactory.closeSession(); &#125; return i; &#125; 批量删除部门映射文件定义SQL12345678&lt;!-- 批量删除 --&gt; &lt;delete id="deleteDeptList" parameterType="string"&gt; delete from dept where dept_id in ( &lt;foreach collection="array" item="id" separator=","&gt; #&#123;id&#125; &lt;/foreach&gt; ); &lt;/delete&gt; 编写批量删除部门的方法123456789101112131415public int deleteDeptList(String[] ids)&#123; int i = 0; try &#123; session = MybatisSessionFactory.getSession(); i = session.delete("cn.ustb.entity.DeptMapper.deleteDeptList", ids); session.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback(); &#125; finally&#123; MybatisSessionFactory.closeSession(); &#125; return i; &#125; 批量修改员工信息修改mybatis-config.xml文件12345678910111213141516支持上有点麻烦，需要修改mybatis-config.xml文件相关数据库连接的信息（主要url），以支持批量更新 &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;allowMultiQueries=true" /&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id="test"&gt; &lt;transactionManager type=""/&gt; &lt;dataSource type=""&gt;&lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; 配置批量更新的sql1234567891011&lt;!-- 批量更新 --&gt; &lt;update id="updateDeptList"&gt; &lt;foreach collection="list" item="dept" separator=";"&gt; update dept &lt;set&gt; &lt;if test="dept.deptName!=null"&gt;dept_name = #&#123;dept.deptName&#125;,&lt;/if&gt;&lt;!-- '，'necessary --&gt; &lt;if test="dept.deptAddress!=null"&gt;dept_address = #&#123;dept.deptAddress&#125;,&lt;/if&gt; &lt;/set&gt; where dept_id = #&#123;dept.deptId&#125; &lt;/foreach&gt; &lt;/update&gt; 编写批量更新部门的方法123456789101112131415public int updateDeptList(List list)&#123; int i = 0; try &#123; session = MybatisSessionFactory.getSession(); i = session.update("cn.ustb.entity.DeptMapper.updateDeptList", list); session.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback(); &#125; finally&#123; MybatisSessionFactory.closeSession(); &#125; return i; &#125; Spring+myBatis整合准备工作 新建项目并导入jar包 配置mybatis-config.xml 创建库及表 创建实体 编写映射文件，修改mybatis-config.xml内容 进行简单测试（除了导入spring相关jar包外，以上内容可能直接使用上一章节内容）配置applicationContext.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"&gt; &lt;!-- 配置数据源，记得去掉myBatis-config.xml的数据源相关配置 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=UTF-8" /&gt; &lt;property name="user" value="root" /&gt; &lt;property name="password" value="root" /&gt; &lt;/bean&gt; &lt;!-- 配置session工厂 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;property name="configLocation" value="classpath:myBatis-config.xml" /&gt; &lt;property name="mapperLocations" value="classpath:cn/ustb/entity/*.xml"/&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器,管理数据源事务处理--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- deptDao的实现类对象 --&gt; &lt;bean id="deptDao" class="cn.ustb.dao.impl.DeptDaoImpl"&gt; &lt;property name="sqlSessionTemplate" ref="sqlSessionTemplate"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置SessionTemplate，已封装了繁琐的数据操作--&gt; &lt;bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate"&gt; &lt;constructor-arg name="sqlSessionFactory" ref="sqlSessionFactory"/&gt; &lt;/bean&gt; &lt;/beans&gt; 修改myBatis-config.xml去掉数据源配置 1234567891011&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;typeAlias type="cn.ustb.entity.Dept" alias="Dept" /&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;mapper resource="cn/ustb/entity/DeptMapper.xml" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写dao层接口及实现DeptDao.java 1234public interface DeptDao &#123; //根据部门ID查询部门信息 public Dept selectOne(int deptId);&#125; 修改接口实现类：DeptDaoImpl.java123456789101112131415public class DeptDaoImpl &#123; private SqlSessionTemplate sqlSessionTemplate; public SqlSessionTemplate getSqlSessionTemplate() &#123; return sqlSessionTemplate; &#125; public void setSqlSessionTemplate(SqlSessionTemplate sqlSessionTemplate) &#123; this.sqlSessionTemplate = sqlSessionTemplate; &#125; public Dept selectOne(int deptId)&#123; Dept dept = null; dept = sqlSessionTemplate.selectOne("cn.ustb.entity.DeptMapper.selectOne", deptId); return dept; &#125;&#125; 编写业务层代码业务层接口略，这里只写业务层实现类：DeptServiceImpl.java12345678910111213141516public class DeptServiceImpl &#123; private DeptDao deptDao; public DeptDao getDeptDao() &#123; return deptDao; &#125; @Resource public void setDeptDao(DeptDao deptDao) &#123; this.deptDao = deptDao; &#125; public Dept selectOne(int id)&#123; return deptDao.selectOne(id); &#125; public int insertDept(Dept dept)&#123; return deptDao.insertDept(dept); &#125;&#125; 配置bean信息到sping配置文件 123456789&lt;!-- DAO层部门信息表的数据操作对象 --&gt;&lt;bean id="deptDao" class="cn.ustb.dao.impl.DeptDaoImpl" &gt; &lt;property name="sqlSessionTemplate" ref="sqlSessionTemplate"/&gt;&lt;/bean&gt;&lt;!-- 业务层部门信息业务处理对象 --&gt;&lt;bean id="deptService" class="cn.ustb.service.impl.DeptServiceImpl"&gt; &lt;property name="deptDao" ref="deptDao"/&gt;&lt;/bean&gt; 简化配置扫描式加载SQL映射文件修改myBatis-config.xml文件，去掉配置 12345678910111213&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;typeAlias type="cn.ustb.entity.Dept" alias="Dept" /&gt; &lt;/typeAliases&gt; &lt;!-- 采用扫描式加载映射文件，以下将不用配置,可以减少映射文件过多时维护的麻烦 --&gt; &lt;!-- &lt;mappers&gt; &lt;mapper resource="cn/ustb/entity/DeptMapper.xml" /&gt; &lt;/mappers&gt; --&gt;&lt;/configuration&gt; 修改applicationContext.xml,为SqlSessionFactoryBean设置mapperLocations属性 1234567&lt;!-- 配置session工厂 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;property name="configLocation" value="classpath:myBatis-config.xml" /&gt; &lt;!-- 配置扫描式加载SQL映射文件 --&gt; &lt;property name="mapperLocations" value="classpath:cn/ustb/entity/*.xml"/&gt; &lt;/bean&gt; MapperScannerConfigurer简化配置1. 在spring配置文件中添加MapperScannerConfigurer 配置并去掉所有的Dao接口实现类配置123456789101112131415161718&lt;!-- 配置 转换器，对于在basePackage设置的包（包括子包）下的接口类的全类名和在Mapper.xml文件中定义过的命名空间一致， spring将会生成对应的代理对象（在调用 的地方通过@Autowired或者@Resource方式将可以注入接口实例）--&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="sqlSessionFactory" ref="sqlSessionFactory"/&gt; &lt;property name="basePackage" value="cn.ustb.dao"/&gt; &lt;/bean&gt; &lt;!-- DAO层部门信息表的数据操作对象，上面如果配置MapperScannerConfigurer转换器，DAO接口将不再使用实现类 --&gt; &lt;!-- &lt;bean id="deptDao" class="cn.ustb.dao.impl.DeptDaoImpl" &gt; &lt;property name="sqlSessionTemplate" ref="sqlSessionTemplate"/&gt; &lt;/bean&gt; --&gt; &lt;!-- 业务层部门信息业务处理对象 --&gt; &lt;bean id="deptService" class="cn.ustb.service.impl.DeptServiceImpl"&gt; &lt;!-- 上面如果配置MapperScannerConfigurer转换器，DAO接口将不再使用实现类注入 --&gt; &lt;!-- &lt;property name="deptDao" ref="deptDao"/&gt; --&gt; &lt;/bean&gt; 2. 检查或修改DeptMapper.xml文件注意：命名空间+id和接口+方法名 一致 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 这时的命名空间就需要和dao接口类全类名一致了 --&gt;&lt;mapper namespace="cn.ustb.dao.DeptDao"&gt; &lt;resultMap id="deptResultMap" type="Dept"&gt; &lt;id property="deptId" column="dept_id" /&gt; &lt;result property="deptName" column="dept_name" /&gt; &lt;result property="deptAddress" column="dept_address" /&gt; &lt;/resultMap&gt; &lt;!-- 这时的id就需要和dao接口的方法一致了 --&gt; &lt;select id="selectOne" parameterType="int" resultMap="deptResultMap"&gt; select * from dept where dept_id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 3. 业务类中，使用@Autowired为DAO接口注入对象public class DeptServiceImpl {123@Autowired private DeptDao deptDao;//省略其它代码 4. 删除Dao实现类（存在也没有意义）ED]]></content>
      <categories>
        <category>实用技术</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>myBatis</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（二）]]></title>
    <url>%2F2019%2F02%2F14%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MyBatis学习笔记（二）动态SQL，关联查询，缓存机制，转义字符个人笔记，如有错误，恳请批评指正。 动态SQL操作IF语句修改配置文件deptMapper.xml，添加 12345678910&lt;!-- 动态Sql语句 --&gt;&lt;!-- 根据多个条件生成动态的sql语句，查询信息 --&gt;&lt;!-- 弊端：当不存在条件时，会查询所有的数据，改用choose可以解决问题 --&gt;&lt;select id="selectDeptUseIf" parameterType="Dept" resultMap="deptResultMap"&gt;&lt;!-- 若字段名与属性名一致可以直接用resultType="Dept" --&gt; select * from dept where 1=1 &lt;!-- 直接写属性，不需要#&#123;&#125;,and不能丢 --&gt; &lt;if test="deptId!=null"&gt;and dept_id = #&#123;deptId&#125;&lt;/if&gt; &lt;if test="deptAddress!=null"&gt;and dept_address = #&#123;deptAddress&#125;&lt;/if&gt; &lt;if test="deptName!=null"&gt;and dept_name = #&#123;deptName&#125;&lt;/if&gt;&lt;/select&gt; 修改DeptDaoImpl.java，添加selectListUseIf方法： 12345678910111213//根据参数使用配置文件的IF语句自动填充查询的过滤条件 public List&lt;Dept&gt; selectDeptUseIf(Dept dept)&#123; List&lt;Dept&gt; list = null; try &#123; session = MybatisSessionFactory.getSession(); list = session.selectList("cn.ustb.entity.DeptMapper.selectDeptUseIf", dept); session.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback(); &#125; return list; &#125; WHERE语句修改配置文件deptMapper.xml，添加 12345678910&lt;!-- 动态Where条件 ,一般也需要与if结合使用，与纯if比较，省略了where 1=1--&gt;&lt;!-- 如果需要去掉1=1，可用where --&gt;&lt;select id="selectDeptUseWhere" parameterType="Dept" resultMap="deptResultMap"&gt; select * from dept &lt;where&gt; &lt;if test="deptId!=null"&gt;and dept_id = #&#123;deptId&#125;&lt;/if&gt; &lt;if test="deptAddress!=null"&gt;and dept_address = #&#123;deptAddress&#125;&lt;/if&gt; &lt;if test="deptName!=null"&gt;and dept_name = #&#123;deptName&#125;&lt;/if&gt; &lt;/where&gt;&lt;/select&gt; choose(when,otherwise)语句修改配置文件deptMapper.xml，添加 123456789101112&lt;!-- choose 用choose时，前面的条件符合就不再执行之后的条件--&gt;&lt;select id="selectDeptUseChoose" parameterType="Dept" resultMap="deptResultMap"&gt; select * from dept &lt;where&gt; &lt;choose&gt; &lt;when test="deptId != null"&gt;and dept_id = #&#123;deptId&#125;&lt;/when&gt; &lt;when test="deptAddress != null"&gt;and dept_address = #&#123;deptAddress&#125;&lt;/when&gt; &lt;when test="deptName != null"&gt;and dept_name = #&#123;deptName&#125;&lt;/when&gt; &lt;otherwise&gt;1=2&lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; SET语句修改配置文件deptMapper.xml，添加 123456789&lt;!-- 动态set语句可以用来更新数据 --&gt;&lt;update id="updateDeptUseSet" parameterType="Dept"&gt; update dept &lt;set&gt; &lt;if test="deptAddress!=null"&gt;dept_address = #&#123;deptAddress&#125;&lt;/if&gt; &lt;if test="deptName!=null"&gt;dept_name = #&#123;deptName&#125;&lt;/if&gt; &lt;/set&gt; where dept_id = #&#123;deptId&#125;&lt;/update&gt; ForEach语句修改配置文件deptMapper.xml，添加 1234567891011&lt;!-- 若要查询多个id的数据 --&gt;&lt;!-- 定义根据多个部门ID查询部门相关部门信息的SQL语句 ,resultMap的值是指集合里元素的类型,parameterType不用指定 --&gt;&lt;!-- foreach --&gt;&lt;select id="selectDeptUseForeach" resultMap="deptResultMap"&gt; select * from dept where dept_id in (&lt;!-- collection＝"array或list",array用来对应参数为数组，list对应参数为 集合 --&gt; &lt;foreach collection="array" item="deptId" separator=","&gt; #&#123;deptId&#125; &lt;/foreach&gt; )&lt;/select&gt; include语句修改配置文件deptMapper.xml，添加 123456789101112131415161718&lt;insert id="insertDeptUseInclude" parameterType="Dept"&gt; insert into dept &lt;include refid="key"&gt;&lt;/include&gt; values &lt;include refid="value"&gt;&lt;/include&gt;&lt;/insert&gt;&lt;sql id="key"&gt; &lt;trim suffixOverrides="," prefix="(" suffix=")"&gt; &lt;if test="deptName!=null"&gt;dept_name,&lt;/if&gt; &lt;if test="deptAddress!=null"&gt;dept_address,&lt;/if&gt; &lt;/trim&gt;&lt;/sql&gt;&lt;sql id="value"&gt; &lt;trim suffixOverrides="," prefix="(" suffix=")"&gt; &lt;if test="deptName!=null"&gt;#&#123;deptName&#125;,&lt;/if&gt; &lt;if test="deptAddress!=null"&gt;#&#123;deptAddress&#125;,&lt;/if&gt;&lt;!-- #&#123;&#125; necessary --&gt; &lt;/trim&gt;&lt;/sql&gt; 关联查询创建数据库及表：1234567891011121314151617181920212223242526272829drop database if exists mybatis;create database mybatis CHARACTER SET UTF8;use mybatis;create table dept( dept_id int primary key auto_increment, dept_name varchar(50), dept_address varchar(50));insert into dept(dept_name,dept_address) values('研发部1部','北京');insert into dept(dept_name,dept_address) values('研发部2部','广州');insert into dept(dept_name,dept_address) values('研发部3部','深圳');create table emp( emp_id varchar(20) primary key, emp_name varchar(50), emp_age int(2), emp_gender char(1), dept_id int);insert into emp(emp_id,emp_name,emp_age,emp_gender,dept_id) values('430726199210102210','张三','18','男','1');insert into emp(emp_id,emp_name,emp_age,emp_gender,dept_id) values('430726199210102211','李四','20','女','3');insert into emp(emp_id,emp_name,emp_age,emp_gender,dept_id) values('430726199210102212','王五','19','男','2');select * from emp;select * from dept;select e.*,d.* from emp e inner join dept d on e.dept_id = d.dept_id; 基于association查询（用于多对一或一对一）创建存在关联的实体类12345678910public class Dept implements Serializable&#123; private String deptAddress; private String deptName; private Integer deptId;public class Emp implements Serializable&#123; private String empId; private String empName; private String empSex; private Dept dept; 配置DeptMapper.xml/EmpMapper.xml（重点加入级联的查询语句），并映射文件信息到mybatis-config.xml中：DeptMapper.xml 123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.ustb.entity.DeptMapper"&gt; &lt;resultMap type="Dept" id="deptResultMap"&gt; &lt;id column="dept_id" property="deptId" /&gt; &lt;result column="dept_name" property="deptName" /&gt; &lt;result column="dept_address" property="deptAddress" /&gt; &lt;/resultMap&gt;&lt;/mapper&gt; EmpMapper.xml,配置多对一的关联 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.ustb.entity.EmpMapper"&gt; &lt;resultMap type="Emp" id="empResultMap"&gt; &lt;id column="emp_id" property="empId"/&gt; &lt;result column="emp_name" property="empName"/&gt; &lt;result column="emp_age" property="empAge"/&gt; &lt;result column="emp_gender" property="empGender"/&gt; &lt;association property="dept" column="dept_id" resultMap="cn.ustb.entity.DeptMapper.deptResultMap"&gt;&lt;/association&gt; &lt;/resultMap&gt; &lt;select id="selectEmp" parameterType="string" resultMap="empResultMap"&gt; select e.*,d.* from emp e inner join dept d on e.dept_id = d.dept_id where e.emp_name = #&#123;empName&#125; &lt;/select&gt;&lt;/mapper&gt; 配置文件myBatis-config.xml1234567891011&lt;!-- 通过别名简化对类的使用 --&gt; &lt;typeAliases&gt; &lt;typeAlias type="cn.ustb.entity.Dept" alias="Dept"/&gt; &lt;typeAlias type="cn.ustb.entity.Emp" alias="Emp"/&gt; &lt;/typeAliases&gt; …….&lt;!--导入SQL映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource="cn/ustb/entity/DeptMapper.xml"&gt;&lt;/mapper&gt; &lt;mapper resource="cn/ustb/entity/EmpMapper.xml"&gt;&lt;/mapper&gt; &lt;/mappers&gt; 编写EmpDaoImpl.java实现查询1234567891011121314public class EmpDaoImpl &#123; private SqlSession session; public Emp selectEmp(String empName)&#123; Emp emp = null; try &#123; session = MybatisSessionFactory.getSession(); emp = session.selectOne("cn.ustb.entity.EmpMapper.selectEmp", empName); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return emp; &#125;&#125; 基于collection查询（用于一对多或多对多）编写 Dept.java/Emp.java实体类123456789101112Dept.javapublic class Dept implements Serializable&#123; private String deptAddress; private String deptName; private Integer deptId;private List&lt;Emp&gt; emps;Emp.javapublic class Emp implements Serializable&#123; private String empId; private String empName; private String empSex; 配置DeptMapper.xmlDeptMapper.xml文件，配置resultMap（重点是collection配置）和查询SQL语句： 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.ustb.entity.DeptMapper"&gt; &lt;resultMap type="Dept" id="deptResultMap"&gt; &lt;id column="dept_id" property="deptId" /&gt; &lt;result column="dept_name" property="deptName" /&gt; &lt;result column="dept_address" property="deptAddress" /&gt; &lt;collection property="emps" resultMap="cn.ustb.entity.EmpMapper.empResultMap"&gt;&lt;/collection&gt;&lt;!-- 没有column --&gt; &lt;/resultMap&gt; &lt;select id="selectDept" parameterType="String" resultMap="deptResultMap"&gt; select d.*,e.* from dept d inner join emp e on d.dept_id = e.dept_id where d.dept_name = #&#123;deptName&#125; &lt;/select&gt;&lt;/mapper&gt; 配置EmpMapper.xml文件不用配置对一关联12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.ustb.entity.EmpMapper"&gt; &lt;resultMap type="Emp" id="empResultMap"&gt; &lt;id column="emp_id" property="empId"/&gt; &lt;result column="emp_name" property="empName"/&gt; &lt;result column="emp_age" property="empAge"/&gt; &lt;result column="emp_gender" property="empGender"/&gt;&lt;/resultMap&gt;&lt;/mapper&gt; 编写数据库操作类DeptDaoImpl.java1234567891011121314151617public class DeptDaoImpl &#123; private SqlSession session = null; public Dept selectDept(String deptName)&#123; Dept dept = null; try &#123; session = MybatisSessionFactory.getSession(); dept = session.selectOne("cn.ustb.entity.DeptMapper.selectDept", deptName); session.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); session.rollback(); &#125;finally&#123; MybatisSessionFactory.closeSession(); &#125;return dept; &#125;&#125; 一对多双向关联查询示例编写实体类:Dept.java/Emp.java12345678910111213Dept.javapublic class Dept implements Serializable&#123; private String deptAddress; private String deptName; private Integer deptId; private List&lt;Emp&gt; emps;Emp.javapublic class Emp implements Serializable&#123; private String empId; private String empName; private String empSex; private Dept dept; 编写DeptMapper.xml/EmpMapper.xml文件DeptMapper.xml值得注意的是，如果在各自的resultMap相互配置了引用，在查询时会导致堆栈溢出的异常。解决的办法是在映射文件中分割resultMap，在查询时查询一方的同时避免迭代。123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.ustb.entity.DeptMapper"&gt; &lt;!-- 缓存的第二级开关，写上即开启 --&gt; &lt;!-- 一级默认开启，二级默认关闭，三级默认开启 --&gt; &lt;cache eviction="LRU" size="2" readOnly="false"&gt;&lt;/cache&gt; &lt;resultMap type="Dept" id="deptResultMap"&gt; &lt;id column="dept_id" property="deptId" /&gt; &lt;result column="dept_name" property="deptName" /&gt; &lt;result column="dept_address" property="deptAddress" /&gt; &lt;/resultMap&gt; &lt;resultMap type="Dept" id="deptExtResultMap" extends="deptResultMap"&gt; &lt;collection property="emps" resultMap="cn.ustb.entity.EmpMapper.empResultMap"&gt;&lt;/collection&gt;&lt;!-- resultMap是empResultMap而不是empExtResultMap,即没有配置多的属性，避免了相互查询时的内存溢出 --&gt; &lt;/resultMap&gt; &lt;select id="selectDept" parameterType="String" resultMap="deptExtResultMap" useCache="true"&gt;&lt;!-- 缓存的三级开关 语句级，默认开启 --&gt; select d.*,e.* from dept d inner join emp e on d.dept_id = e.dept_id where d.dept_name = #&#123;deptName&#125; &lt;/select&gt; &lt;select id="selectDeptById" parameterType="string" resultMap="deptExtResultMap"&gt; select d.*,e.* from dept d inner join emp e on d.dept_id = e.dept_id where d.dept_id = #&#123;deptId&#125; &lt;/select&gt;&lt;/mapper&gt; EmpMapper.xml12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.ustb.entity.EmpMapper"&gt; &lt;resultMap type="Emp" id="empResultMap"&gt; &lt;id column="emp_id" property="empId" /&gt; &lt;result column="emp_name" property="empName" /&gt; &lt;result column="emp_age" property="empAge" /&gt; &lt;result column="emp_gender" property="empGender" /&gt; &lt;/resultMap&gt; &lt;resultMap type="Emp" id="empExtResultMap" extends="empResultMap"&gt; &lt;association property="dept" column="dept_id" resultMap="cn.ustb.entity.DeptMapper.deptResultMap"&gt;&lt;/association&gt; &lt;!-- 同样，引用的是deprResultMap，没有配置多的属性 --&gt; &lt;/resultMap&gt; &lt;select id="selectEmp" parameterType="string" resultMap="empExtResultMap"&gt; select e.*,d.* from emp e inner join dept d on e.dept_id = d.dept_id where e.emp_name = #&#123;empName&#125; &lt;/select&gt;&lt;/mapper&gt; 编写数据操作类：DeptDaoImpl.java/EmpDaoImpl.javaDeptDaoImpl.java，查询部门员工信息，返回类型为List，关键代码： 12345678910111213141516public List&lt;Dept&gt; selectDeptEmpList(Dept dept)&#123; SqlSession session=null; List&lt;Dept&gt; deps=null; try&#123; session=MyBatisUtil.getSession(); deps=session.selectList("cn.ustb.entity.DeptMapper.selectDeptEmpList",dept); session.commit(); &#125;catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); session.rollback(); &#125;finally&#123; MyBatisUtil.closeSession(); &#125; return deps; &#125; EmpDaoImpl.java查询员工及其所在部门信息，返回类型为List&lt; Emp &gt;，关键代码 12345678910111213141516public List&lt;Emp&gt; selectEmpDeptList(Emp emp)&#123; SqlSession session=null; List&lt;Emp&gt; emps=null; try&#123; session=MyBatisUtil.getSession(); emps=session.selectList("cn.ustb.entity.EmpMapper.selectEmpDeptList",emp); session.commit(); &#125;catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); session.rollback(); &#125;finally&#123; MyBatisUtil.closeSession(); &#125; return emps; &#125; 缓存Mybatis和hibernate一样，也使用缓存；缓存分为一级缓存和二级缓存，一级缓存指在SqlSession内共享数据；二级缓存能被所有的SqlSession共享。 全局缓存配置（一级缓存）在mybatis-config.xml的主配置文件中进行配置： 12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;!-- 默认有启用全局缓存的，禁用可以把value设为false,如果这里设为false，Mapper.xml或SQL语句级的缓存配置不再起作用 --&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;/settings&gt;&lt;!—省略其它配置信息 --&gt;&lt;/configuration&gt; Mapper文件级缓存配置（二级缓存）使用二级缓存机制：需要开启全局缓存，文件级缓存 ，语句级缓存，才能使用二级缓存。默认情况下文件级缓存没有开启。 123&lt;!-- 缓存的第二级开关，写上即开启 --&gt; &lt;!-- 一级默认开启，二级默认关闭，三级默认开启 --&gt; &lt;cache eviction="LRU" size="2" readOnly="false"&gt;&lt;/cache&gt; 关于二级缓存的配置，在使用者手册中有详细说明，摘取如下内容： 可用的回收算法如下：• LRU – 最近最少使用：移出最近最长时间内都没有被使用的对象。• FIFO – 先进先出：移除最先进入缓存的对象。• SOFT – 软引用: 基于垃圾回收机制和软引用规则来移除对象（空间内存不足时才进行回收）。• WEAK – 弱引用: 基于垃圾回收机制和弱引用规则（垃圾回收器扫描到时即进行回收）。默认使用LRU。 flushInterval ：设置任何正整数，代表一个以毫秒为单位的合理时间。默认是没有设置，因此 没有刷新间隔时间被使用，在语句每次调用时才进行刷新。Size：属性可以设置为一个正整数，您需要留意您要缓存对象的大小和环境中可用的内存空间。 默认是1024。readOnly：属性可以被设置为true 或false。只读缓存将对所有调用者返回同一个实例。因此这些对象都不能被修改，这可以极大的提高性能。可写的缓存将通过序列化来返回一个缓存对象的拷贝。这会比较慢，但是比较安全。所以默认值是false。 缓存配置分析：123456789101112&lt;!-- &lt;cache eviction="FIFO" flushInterval="60000" size="512" readOnly="false"/&gt;创建了一个 FIFO 缓存,并每隔 60 秒刷新,存数结果对象或列表的 512 个引用,而且返回的对象被认为是只读的,因此在不同线程中的调用者之间修改它们会 导致冲突。可用的收回策略有以下几种, 默认的是 LRU:1. LRU – 最近最少使用的:移除最长时间不被使用的对象。 2. FIFO – 先进先出:按对象进入缓存的顺序来移除它们。 3. SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。 4. WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。flushInterval：刷新间隔时间，可以被设置为任意的正整数,单位毫秒。默认情况是不设置,也就是没有刷新间隔,缓存仅仅调用语句时刷新。size：内存资源数目，可以被设置为任意正整数。默认值是1024。readOnly(只读)属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓 存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存 会返回缓存对象的拷贝(通过序列化) 。这会慢一些,但是安全,因此默认是 false。 --&gt;&lt;cache eviction="LRU" size="2" readOnly="false" /&gt; SQL语句级缓存配置在相关的Mapper.xml文件中配置SQL查询，关键代码如下（示例）：1234&lt;!-- useCache默认值为true,设为false时缓存不起作用 --&gt; &lt;select id="selectOne" parameterType="int" resultMap="deptResultMap" useCache="true" &gt; select * from dept where dept_id=#&#123;id&#125; &lt;/select&gt; XML 中的特殊字符处理如果 MyBatis 使用 XML 配置，那不可避免地会遇到一些对 XML 来说是特殊的字符。如小于号 “&lt;”，因此要进行转义。主要有两个方式： 使用转义实体下面是五个在 XML 文档中预定义好的转义实体: &amp;lt； &lt; 小于号 &amp;gt； &gt; 大于号 &amp;amp； &amp; &amp;apos； ‘ 单引号 &amp;quot； “ 双引号 小于等于“&lt;=”，其转义为：&amp;lt；= 大小等于“&gt;=”，转义为：&amp;gt；=使用 CDATA 部件CDATA 部件以”&lt;![CDATA[“ 标记开始，以”]]&gt;”标记结束。在”&lt;![CDATA[“和”]]&gt;”之间 的特殊字符的意义都不起作用，而转变为普通字符串内容。在 MyBatis 的 XML 映射语句配置文件中，如果 SQL 语句有特殊字符，使用CDTA 部件括起来，如：12&lt;select id= "selectBlog_use_collection" resultMap= "blogResult" &gt;&lt;![CDATA[ SELECT id , title, author_id as authored FROM BLOG WHERE ID &gt; 0 and ID &lt; 10 ]]&gt; &lt;/select&gt;]]></content>
      <categories>
        <category>实用技术</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>myBatis</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lucene全文搜索学习笔记（一）]]></title>
    <url>%2F2019%2F02%2F14%2FLucene%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Lucene全文搜索学习笔记（一）LuceneUtil，分页查询个人笔记，如有错误，恳请批评指正。 什么是lucene？Lucene是apache软件基金会发布的一个开放源代码的全文检索引擎工具包，由资深全文检索专家Doug Cutting所撰写,它是一个全文检索引擎的架构，提供了完整的创建索引和查询索引，以及部分文本分析的引擎，Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎，Lucene在全文检索领域是一个经典的祖先，现在很多检索引擎都是在其基础上创建的，思想是相通的。即：Lucene是根据关健字来搜索的文本搜索工具，只能在某个网站内部搜索文本内容，不能跨网站搜索。 Lucene通常用在什么地方？Lucene不能用在互联网搜索（即像百度那样），只能用在网站内部的文本搜索（即只能在CRM，RAX，ERP内部使用），但思想是相通的。 为什么网站内部有些地方要用Lucene来索搜，而不全用SQL来搜索？ SQL只能针对数据库表搜索，不能直接针对硬盘上的文本搜索 SQL没有相关度排名 SQL搜索结果没有关健字高亮显示 SQL需要数据库的支持，数据库本身需要内存开销较大，例如：Oracle SQL搜索有时较慢，尤其是数据库不在本地时，超慢，例如：Oracle 使用Lucene的流程图？ 创建索引库： 创建JavaBean对象 创建Docment对象 将JavaBean对象所有的属性值，均放到Document对象中去，属性名可以和JavaBean相同或不同 创建IndexWriter对象 将Document对象通过IndexWriter对象写入索引库中 关闭IndexWriter对象 根据关键字查询索引库中的内容： 创建IndexSearcher对象 创建QueryParser对象 创建Query对象来封装关键字 用IndexSearcher对象去索引库中查询符合条件的前100条记录，不足100条记录的以实际为准 获取符合条件的编号 用indexSearcher对象去索引库中查询编号对应的Document对象 将Document对象中的所有属性取出，再封装回JavaBean对象中去，并加入到集合中保存，以备将之用。 Lucene快速入门 导入Lucene相关的jar包 lucene-core-3.0.2.jar【Lucene核心】 lucene-analyzers-3.0.2.jar【分词器】 lucene-highlighter-3.0.2.jar【Lucene会将搜索出来的字，高亮显示，提示用户】 lucene-memory-3.0.2.jar【索引库优化策略】 编写代码： 虚拟Article bean对象123456789101112131415161718192021222324252627282930313233public class Article &#123; private Integer id; private String title; private String content; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; public Article() &#123; super(); &#125; public Article(Integer id, String title, String content) &#123; super(); this.id = id; this.title = title; this.content = content; &#125; &#125; LuceneApp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class FirstLucene &#123; public void createIndexDB(Article article)&#123; //document Document document = new Document(); //创建lucene文档对象，并添加字段 /*FIELD：： * Store.YES表示把当前字段存到文档中，Store.NO表示 不把当前字段存到文档中 * Index： * ANALYZED，表示当前字段建立索引，并且进行分词，产生多个term * NOT_ANALYZED，表示当前字段建立索引，但不进行分词，整个字段值作为一个整体，产生一个term * NO,不创建索引，以后不能用此字段查询 */ document.add(new Field("id", article.getId().toString(), Store.YES, Index.NOT_ANALYZED)); document.add(new Field("title",article.getTitle(),Store.YES,Index.ANALYZED)); document.add(new Field("content",article.getContent(),Store.YES,Index.ANALYZED)); Directory directory = null; Analyzer analyzer = null; IndexWriter indexWriter = null; try &#123; //指定索引库目录 directory = FSDirectory.open(new File("F:/java/practice/luceneDir")); //指定分词器 版本一般用最高版本 analyzer = new StandardAnalyzer(Version.LUCENE_30); //创建索引库管理对象 /* *创建索引库管理对象（主要用来增删改索引库信息） * MaxFieldLength，用于限制Field的大小。这个变量可以让用户有计划地 *对大文档Field进行截取。假如取值为10000，就只索引每个Field的前 *10000个Term（关键字）。其它的部分都不会被Lucene索引，也不能被搜索到。 */ indexWriter = new IndexWriter(directory, analyzer, MaxFieldLength.LIMITED); //添加文档对象到索引库管理对象 indexWriter.addDocument(document); //提交到索引库 indexWriter.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //关闭 finally&#123; if(indexWriter!=null)&#123; try &#123; indexWriter.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public void findIndexDB(String keyWords)&#123; List&lt;Article&gt; articleList = new ArrayList&lt;Article&gt;(); try &#123; FSDirectory directory = FSDirectory.open(new File("F:/java/practice/luceneDir")); //分词器 ：和存入时要一致 Analyzer analyzer = new StandardAnalyzer(Version.LUCENE_30); //索引库搜索者 IndexSearcher indexSearcher = new IndexSearcher(directory); //指定查询解析器//参数一：版本号，一般选择最高，参数二：字段名，参数三：分词器 QueryParser queryParser = new QueryParser(Version.LUCENE_30, "title", analyzer); //把查询关键字交给查询解析器，如果由多个单词组成，将匹配多个term 关键字，只要能匹配上任意一个单词都可以返回 Query query = queryParser.parse(keyWords); //查询解析库//参数1：指定的查询解析器，参数二：指定返回记录条数 TopDocs topDocs = indexSearcher.search(query, 5); System.out.println("实际索引库中匹配到的总条数为："+topDocs.totalHits); System.out.println("返回的记录(ID)条数为："+topDocs.scoreDocs.length); ScoreDoc[] scoreDocs = topDocs.scoreDocs; for (ScoreDoc scoreDoc : scoreDocs) &#123; System.out.println("当前的文档积分是："+scoreDoc.score); System.out.println("当前的文档编号是："+scoreDoc.doc); //根据文档查看真正的文档对象 Document document = indexSearcher.doc(scoreDoc.doc); System.out.println("真正文档的内容是：id:"+document.get("id")+";title:"+document.get("title")+";content："+document.get("content")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testIn()&#123; Article article = new Article(1, "挖掘机修理哪家强？", "山东济南找蓝翔"); createIndexDB(article); &#125; @Test public void testOut()&#123; String keyword = "挖掘机"; findIndexDB(keyword); &#125; &#125; 新增操作说明关键步骤： 1. 构建索引库 `Directory directory = FSDirectory.open(new File(&quot;索引库目录&quot;));` 2. 指定分词器，版本一般指定为最高 `Analyzer analyzer = newStandardAnalyzer(Version.LUCENE_30);` 3. 创建文档对象，并添加相关字段值 `Document doc = new Document(); doc.add(new Field(&quot;Id&quot;,goods.getGoodsId().toString(),Store.YES,Index.NOT_ANALYZED));` 4. 创建增删改索引库的操作对象，添加文档并提交 `IndexWriter indexWriter =new IndexWriter(directory,analyzer, MaxFieldLength.LIMITED); indexWriter.addDocument(doc); indexWriter.commit();` 5. 关闭操作对象 查询操作说明关键步骤： 1. 打开索引库 `directory= FSDirectory.open(new File(&quot;索引库目录&quot;));` 2. 创建查询分词器，版本号与写入文档的查询分词器一样 `Analyzer analyzer = newStandardAnalyzer(Version.LUCENE_30);` 3. 创建查询解析器，参数为版本号，查询字段名，分词器 `QueryParser parser = new QueryParser(Version.LUCENE_30,&quot;content&quot;,analyzer);` 4. 构建查询信息对象 ` Query query = parser.parse(keyWord);` 5. 构建查询工具 `searcher = new IndexSearcher(directory);` 6. 通过查询工具执行查询。参数1，查询信息对象；参数2。返回记录数；TopDocs包括总记录数、文档重要信息（编号）的列表等 `TopDocs topDocx=searcher.search(query,20);` 7. 根据文档编号遍历真正的文档 ` ScoreDoc sd[] = topDocx.scoreDocs; for(ScoreDoc scoreDoc:sd){ ... Document doc =searcher.doc(scoreDoc.doc);` 8. 转为Java对象 setter(doc.get(&quot;param&quot;)); 9. 关闭查询操作对象]]></content>
      <categories>
        <category>实用技术</category>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Lucene</tag>
        <tag>全文搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lucene全文搜索学习笔记（三）]]></title>
    <url>%2F2019%2F02%2F14%2FLucene%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Lucene全文搜索学习笔记（三）高亮，多字段查询，分页查询。个人笔记，如有错误，恳请批评指正。 分页查询，接上若查询第二页，每页5条。查询10条。遍历取回6-10条。需判断总条数与需要条数的关系123456//总记录数小于end，说明scoreDocs不满end条。即返回的是start--totalHits条。否则返回的是start--end条 ScoreDoc[] scoreDocs = topDocs.scoreDocs; int size = end; if(topDocs.totalHits&lt;end) &#123; size = topDocs.totalHits; &#125; IndexWriterUtil的编写：整个项目唯一一个IndexWriter，并且在虚拟机关闭时自动close()；123456789101112131415//注册虚拟机关闭线程Runtime.getRuntime().addShutdownHook(new Thread()&#123; @Override public void run() &#123; try &#123; indexWriter.close(); System.out.println("indexWriter已经关闭了！"); &#125; catch (CorruptIndexException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); 使用IKAnalyzer,当参数为true时，表示使用最大词长分词，false表示使用细粒度分词步骤： 导包 配置文件IKAnalyzer.cfg.xml到src目录下 禁用词汇ext_stopword.dic和自定义词汇mydict.dic放到src目录下（/）（格式：第一行空格换行，并注意保存的编码要一致）,禁用词汇不建立索引库，所以搜索不到。但是会存储进索引库。 //使用IKAnalyzer,当参数为true时，表示使用最大词长分词，false表示使用细粒度分词。 IKAnalyzer = new IKAnalyzer(true); IndexWriter indexWriter = new IndexWriter(LuceneUtil.getDirectory(), LuceneUtil.getAnalyzer(),LuceneUtil.getMaxFieldLength()); 注意：当indexWriter用了IKAnalyzer以后，indexSearcher也要用IKAnalyzer排序和多字段查询123456789//创建排序字段，参数一：指定排序字段；参数二：字段类型；参数三：设置升序或子降序，true为降序 SortField goodsId = new SortField("goodsId",SortField.INT,true); Sort sort=new Sort(); //设置排序字段（可以多个字段）到sort对象中，排序的优先级，前者优先于后者 sort.setSort(goodsId,其它SortField对象); //使用IKQueryParser进行多字段数据查询 Query query=IKQueryParser.parseMultiField(new String[]&#123;"goodsName","goodsRemark"&#125;,keyword); //执行查询，使用search(Query query , Filter filter , int n , Sort sort)方法，返回20条记录，加入排序设置信息 TopDocs topDocs = indexSearcher.search(query, null,20,sort);//null过滤器 排序：123new SortField(“指定排序字段”，“字段类型”，“true：升序 false：降序”);sort = new sort();sort.setSort(多个sortField); 多字段：1query = IKQueryParser.parseMultiField(new String[]&#123;“字段名”&#125;,“keyword”); 查询：12345678910111213141516171819202122232425indexSearcher.search(query,null,20,sort);//排序+多字段查询 public void searchBySortAndMultiField(String keyword)&#123; try &#123; IndexSearcher indexSearcher = IndexSearcherUtil.getIndexSearcher(); //设置排序 SortField idField = new SortField("id", SortField.INT, false); //SortField contentField = new SortField("content",SortField.STRING,false); Sort sort = new Sort(); sort.setSort(idField); //设置多字段查询 Query query = IKQueryParser.parseMultiField(new String[]&#123;"title","content"&#125;, keyword); TopFieldDocs topFieldDocs = indexSearcher.search(query, null, 20, sort); System.out.println("总匹配数："+topFieldDocs.totalHits); ScoreDoc[] scoreDocs = topFieldDocs.scoreDocs; for (ScoreDoc scoreDoc : scoreDocs) &#123; Document doc = indexSearcher.doc(scoreDoc.doc); System.out.println("title:"+doc.get("title")+"content:"+doc.get("content")); &#125; &#125; catch (CorruptIndexException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 高亮：获取到Document对象后，对doc中指定字段的指定内容利用HighLighter对象进行高亮返回带有高亮格式的指定字段值,重新setValue到document中的对应field中，封装到对象输出。具体步骤：123456789101112Document doc = indexSearcher.doc(scoreDocs[i].doc);//设置高亮格式Formatter fomatter = new SimpleHTMLFormatter("&lt;font color='red'&gt;", "&lt;/font&gt;");//设置需要高亮的关键字，指定查询信息Scorer scorer = new QueryScorer(query);Highlighter highlighter = new Highlighter(fomatter,scorer);//制定高亮后的长度，需要SimpleFragmenter类型参数，指定20int length = 20;highlighter.setTextFragmenter(new SimpleFragmenter(length));//设置对哪些字段进行高亮，返回高亮后的结果String titleResult = highlighter.getBestFragment(LuceneUtil.getIKAnalyzer(), "title", doc.get("title"));String contentResult = highlighter.getBestFragment(LuceneUtil.getIKAnalyzer(), "content", doc.get("content")); 对返回的String判空：123456789101112Document doc = indexSearcher.doc(scoreDocs[i].doc);//设置高亮格式Formatter fomatter = new SimpleHTMLFormatter("&lt;font color='red'&gt;", "&lt;/font&gt;");//设置需要高亮的关键字，指定查询信息Scorer scorer = new QueryScorer(query);Highlighter highlighter = new Highlighter(fomatter,scorer);//制定高亮后的长度，需要SimpleFragmenter类型参数，指定20int length = 20;highlighter.setTextFragmenter(new SimpleFragmenter(length));//设置对哪些字段进行高亮，返回高亮后的结果String titleResult = highlighter.getBestFragment(LuceneUtil.getIKAnalyzer(), "title", doc.get("title"));String contentResult = highlighter.getBestFragment(LuceneUtil.getIKAnalyzer(), "content", doc.get("content")); 对HighLighterUtils的抽取123456789101112Document doc = indexSearcher.doc(scoreDocs[i].doc);//设置高亮格式Formatter fomatter = new SimpleHTMLFormatter("&lt;font color='red'&gt;", "&lt;/font&gt;");//设置需要高亮的关键字，指定查询信息Scorer scorer = new QueryScorer(query);Highlighter highlighter = new Highlighter(fomatter,scorer);//制定高亮后的长度，需要SimpleFragmenter类型参数，指定20int length = 20;highlighter.setTextFragmenter(new SimpleFragmenter(length));//设置对哪些字段进行高亮，返回高亮后的结果String titleResult = highlighter.getBestFragment(LuceneUtil.getIKAnalyzer(), "title", doc.get("title"));String contentResult = highlighter.getBestFragment(LuceneUtil.getIKAnalyzer(), "content", doc.get("content")); 索引库优化 indexWriter.optimize（）方法使用： 新增数据时在提交前使用optimize()方法将把产生.cfs的文档和原来的文档压缩并合并为一个修改操作类的保存数据方法 1indexWriter.optimize()； indexWriter.setMergeFactor()方法使用关键代码： 12//通过设置合并因子合并文件，如下：产生三个cfs文档（包括合并的）将压缩合并成一个indexWriter.setMergeFactor(3); 增删改查Term 对应索引表里的关键词及字段 newTerm(“字段名”,”字段值”)TopDocs只包括总记录数和文档编号(scoreDoc.doc) 12ScoreDoc[] scoreDocs = topDocs.scoreDocs;Document document = indexSearcher.doc(scoreDoc.doc); 通过文档编号再次查询searcher.doc(scoreDoc.doc)返回documentupdate原则：根据字段的值进行修改数据内容，先删除再添加。如果字段值不存在，则新增一条记录（文档），如果字段值唯一，那就相当于根据主键修改数据；如果字段值对应多条记录（文档），则其他记录（文档）将被逻辑删除后，再添加一条记录（文档）。Delete原则：根据传入的字段值搜索对应的记录（文档），进行删除。 个人总结： 做系统不仅要考虑功能，还要考虑非功能的东西，比如说性能，可维护性，交互性等。 IKAnalyzer中文分词器：开源的，轻量级的分词器。 尽量减少不必要的字段的存储。Store.YES/Store.NO 不需要检索的内容尽量不要建立索引。Index.ANALYZED/Index.NOT_ANALYZED/Index.NO 非文本格式需要提前转化为字符串。 需要整体存放的内容不要分词，例如：ID、价格、专业词。Index.NOT_ANALYZED ED]]></content>
      <categories>
        <category>实用技术</category>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Lucene</tag>
        <tag>全文搜索</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lucene全文搜索学习笔记（二）]]></title>
    <url>%2F2019%2F02%2F14%2FLucene%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Lucene全文搜索学习笔记（二）LuceneUtil，分页查询个人笔记，如有错误，恳请批评指正。 LuceneUtil的编写，主要是对document2bean以及bean2document操作的封装。写的不完善，先学完Lucene再说。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class LuceneUtil &#123; private static Directory directory; private static Version version; private static Analyzer analyzer; private static MaxFieldLength maxFieldLength; static&#123; try &#123; directory = FSDirectory.open(new File("F:/java/practice/luceneDir")); version = Version.LUCENE_30; analyzer = new StandardAnalyzer(version); maxFieldLength = MaxFieldLength.LIMITED; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * * @param obj 传入的对象，用到反射将Field存入索引库 * @return doc对象 * @throws Exception */ public static Document bean2document(Object obj) throws Exception&#123; /* * 思路：document.add(new Field(name,content,Store?,Index?)) * 利用反射获取传入的obj中name属性对应的content * */ Document document = new Document(); Class clazz = obj.getClass(); Field[] fields = clazz.getDeclaredFields(); //对传入的obj每个field遍历，利用get方法取出值并存入索引库 for (Field field : fields) &#123; field.setAccessible(true); String getMethodName = "get"+field.getName().substring(0,1).toUpperCase()+field.getName().substring(1); Method method = clazz.getDeclaredMethod(getMethodName, null); String fieldValue = ""; if(method.invoke(obj, null)!=null)&#123; fieldValue = method.invoke(obj, null).toString();//参数1：执行的对象，参数2：所需的参数 &#125; document.add(new org.apache.lucene.document.Field(field.getName(), fieldValue, Store.YES, Index.ANALYZED));//两种Field &#125; return document; &#125; /** * * @param document * @param clazz 返回的Class * @return * @throws Exception */ public static Object document2bean(Document document,Class clazz) throws Exception&#123; /* * 思路 :BeanUtils.setProperty(obj,name,value); **/ Object obj = clazz.newInstance(); Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) &#123; field.setAccessible(true); String name = field.getName(); BeanUtils.setProperty(obj, name, document.get(name).toString());//参数1：对象. 参数2：变量名 .参数3：变量值 &#125; return obj; &#125; public static Directory getDirectory() &#123; return directory; &#125; public static Version getVersion() &#123; return version; &#125; public static Analyzer getAnalyzer() &#123; return analyzer; &#125; public static MaxFieldLength getMaxFieldLength() &#123; return maxFieldLength; &#125; &#125; Lucene的增删改查： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class LuceneCRUD &#123; public void addIndexDB(Object obj)&#123; try &#123; Document document = LuceneUtil.bean2document(obj); IndexWriter indexWriter = new IndexWriter(LuceneUtil.getDirectory(), LuceneUtil.getAnalyzer(), LuceneUtil.getMaxFieldLength()); indexWriter.addDocument(document); indexWriter.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void updateIndexDB(Object obj)&#123; try &#123; Document document = LuceneUtil.bean2document(obj); IndexWriter indexWriter = new IndexWriter(LuceneUtil.getDirectory(), LuceneUtil.getAnalyzer(), LuceneUtil.getMaxFieldLength()); //Term表示需要更新的document对象。id用户找到该document。在这里先写死。 indexWriter.updateDocument(new Term("id","1"), document); indexWriter.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void deleteAllIndexDB()&#123; try &#123; IndexWriter indexWriter = new IndexWriter(LuceneUtil.getDirectory(), LuceneUtil.getAnalyzer(), LuceneUtil.getMaxFieldLength()); indexWriter.deleteAll(); indexWriter.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void deleteIndexDB()&#123; try &#123; IndexWriter indexWriter = new IndexWriter(LuceneUtil.getDirectory(), LuceneUtil.getAnalyzer(), LuceneUtil.getMaxFieldLength()); indexWriter.deleteDocuments(new Term("id","1"));// 删除id为1的doc indexWriter.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void searchIndexDB(String keyword)&#123; try &#123; IndexSearcher indexSearcher = new IndexSearcher(LuceneUtil.getDirectory()); QueryParser queryParser = new QueryParser(Version.LUCENE_30, "content", LuceneUtil.getAnalyzer()); Query query = queryParser.parse(keyword); TopDocs topDocs = indexSearcher.search(query, 5); ScoreDoc[] scoreDocs = topDocs.scoreDocs; for (ScoreDoc scoreDoc : scoreDocs) &#123; Document doc = indexSearcher.doc(scoreDoc.doc); Article article = (Article) LuceneUtil.document2bean(doc, Article.class); System.out.println(article.getTitle()+":"+article.getContent()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testAdd()&#123; addIndexDB(new Article(1,"标题","内容")); &#125; @Test public void testDelete()&#123; deleteIndexDB(); &#125; @Test public void testDeleteAll()&#123; deleteAllIndexDB(); &#125; @Test public void testSearch()&#123; searchIndexDB(""); &#125; @Test public void testUpdate()&#123; updateIndexDB(new Article(1,"新标题2","好！")); &#125; &#125; 分页的初步实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class LuceneDaoImpl &#123; public List&lt;Article&gt; selectArticlePage(String keyword,int pageIndex,int pageSize)&#123; List&lt;Article&gt; list = new ArrayList&lt;Article&gt;(); IndexSearcher indexSearcher = null; try &#123; int start = (pageIndex-1)*pageSize; int end = pageIndex*pageSize; QueryParser queryParser = new QueryParser(Version.LUCENE_30,"title", LuceneUtil.getAnalyzer()); Query query = queryParser.parse(keyword); indexSearcher = new IndexSearcher(LuceneUtil.getDirectory()); TopDocs topDocs = indexSearcher.search(query, end); System.out.println("总记录数为："+topDocs.totalHits); //总记录数小于end，说明scoreDocs不满end条。即返回的是start--totalHits条。否则返回的是start--end条 ScoreDoc[] scoreDocs = topDocs.scoreDocs; int size = end; if(topDocs.totalHits&lt;end) &#123; size = topDocs.totalHits; &#125; if(topDocs.totalHits&lt;=start)&#123; System.out.println("没有记录了！"); return null; &#125; for(int i = start ;i&lt;size;i++)&#123; Document doc = indexSearcher.doc(scoreDocs[i].doc); Article article = (Article) LuceneUtil.document2bean(doc,Article.class); list.add(article); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; try &#123; indexSearcher.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return list; &#125; @Test public void testSearchPage()&#123; int pageIndex = 1; int pageSize = 19; List&lt;Article&gt; list = selectArticlePage("标题", pageIndex, pageSize); if(list!=null)&#123; System.out.println(list.size()); for (Article article : list) &#123; System.out.println(article.getTitle()+":"+article.getContent()); &#125; System.out.println("第"+pageIndex+"页"+"每页"+pageSize+"条"); &#125; &#125; &#125;]]></content>
      <categories>
        <category>实用技术</category>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Lucene</tag>
        <tag>全文搜索</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习（2）]]></title>
    <url>%2F2019%2F02%2F14%2FLinux%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Linux学习（2） 个人笔记，如有错误，恳请批评指正。 第三部分：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364软件管理 windows:.exe 执行安装 andriod：安装.apk 卸载包名 red hat：*.rpm ubuntu：对debian的升级 *.deb文件格式安装程序 卸载+包名 1：直接安装.deb包 dpkg软件包 1：安装以.deb结尾的软件包，需要使用root的权限 1：sudo dpkg -i 软件包名 2：卸载 1：sudo dpkg -r 软件包名 3：安装tree 1：进入file文件 cd /home/itcast/Desktop/file 2：sudo dpkg -i tree_1.5.3-1_i386.deb 4：看Ubuntu系统已安装所有软件包列表 1：sudo dpkg -l 很多情况软件安装:/usr/local之下 2：使用apt-get管理软件（推荐使用） 1：前提连接互联网，自动搜素，自动下载自动安装 2：安装 1：sudo apt-get install eclipse 2：sudo apt-get install openjdk-6-jdk 3：卸载 1：sudo apt-get remove packagename 3：使用广泛，默认下载路径 1：/var/cache/apt 同时也可以可以更新和搜索软件 1.执行“apt-get update”更源列表 2.执行“apt-cache search 名称”搜索软件 ubuntu系统如何查看软件安装的位置？装到哪里去了，可以这样看： 代码: dpkg -L 软件名 软件中心下载的软件默认保存路径：/var/cache/apt/archives. 9：vim编辑器 vim的安装： sudo apt-get install vim 安装成功以后的优化： sudo vim /etc/vim/vimrc 编辑配置文件 endif下面加入： set nu // 在左侧行号 set tabstop //tab 长度设置为 4 set nobackup //覆盖文件时不备份 set cursorline //突出显示当前行 set ruler //在右下角显示光标位置的状态行 set autoindent //自动缩进 vim的基本操作： VIM的运行模式 &lt;C-F12&gt; 编辑模式：等待编辑命令输入 插入模式：编辑模式下，输入 i 进入插入模式，插入文本信息 命令模式：在编辑模式下，输入 “：” 进行命令模式 1：安装 2：在/home/itcast/目录下建立一个bank.txt文件 1：cd /home/itcast/familyA/ 2：touch bank.txt 3：使用vim编辑 4：ctrl+C 退出插入模式或者敲ESC切换至命令模式 -q: 安全退出，当没有操作该文档，则直接q退出文档。 -q!：当修改了内容，不想保存直接按q退出vim -wq：保存退出 -set number：显示行号 -set nonumber：取消行号显示 第四部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152 搭建Java服务器并进行远程管理 查看linux 是否开始SSH 服务(是否安装服务端) ssh:secure shell 加密方式： 1、对称加密（加密密钥和解密密钥相同） des、aes 2、非对称加密（加密密钥与解密密钥不同） RSA：公钥、私钥 数字摘要：md5\sha1 sudo apt-cache policy openssh-client openssh-server 1：搭建SSH服务器 1：在Ubuntu Linux服务器上安装SSH软件 执行“apt-get install openssh-server” 客户端：sudo apt-get install openssh-client 2：在Windows客户机上访问SSH服务器 使用“putty.exe”登录服务器（命令行），可用于在windows执行服务端执行命令。 使用“winscp.exe”连接服务器，可用于系统间的上传下载文件。 2：搭建Java环境（JDK6） 方法一：执行“apt-get install openjdk-6-jdk” 注意: 需要联网. 安装后存入/usr/bin目录中，且PATH中自动配置了环境变量。不用配置CLASSPATH 方法二： 1.进入opt目录 cd /opt 2.在opt目录下建立java安装目录 sudo mkdir java 3.将jdk-6u24-linux-i586.bin拷贝到java目录下 sudo cp /home/itcast/Desktop/file/jdk-6u39-linux-i586.bin /opt/java 4.安装jdk cd /opt/java sudo ./jdk-6u39-linux-i586.bin 配置JAVA_HOME 修改/ect/profile文件 编辑配置文件 sudo vim /etc/profile 添加如下内容： export JAVA_HOME=&quot;/opt/java/jdk1.6.0_39&quot; export PATH=&quot;$JAVA_HOME/bin:$PATH&quot; 重启机器。或者(source /etc/profile) 3：验证环境 查看环境变量 env 验证JAVA_HOME是否配好： echo $JAVA_HOME echo $PATH 注意： $是取环境变量的值 JAVA_HOME是环境变量 验证PATH是否配好： java -version 3: 搭建Tomcat服务器 1，从tomcat官网上下载.tar.gz包，并放到服务器上。 2，解压tomcat.tar.gz包：“tar -zxvf tomcat6.tar.gz”。 sudo tar -zxvf 该命令字节进.gz的文件包解压。 3，执行“/opt/tomcat6/bin/startup.sh”便可启动Tomcat。 如果启动不了，请尝试 sudo -i 切换到root用户再重新启动 sudo ./startup.sh 关闭 sudo ./shutdown.sh 测试http:127.0.0.1:8080/ sudo firefox (如果无法正常打开浏览器使用该命令) 4: 安装eclipse 1，从eclipse官网下载eclipse-jee-helios-linux-gtk.tar.gz包，放到服务器上。 2，解压eclips.tar.gz包：“tar -zxvf 解压eclips.tar.gz”。 3，执行“/opt/eclipse/eclipse” 便可启动eclipse 如果eclipse无法正常启动，可以经jre拷贝一份到eclipse目录下（cp -a 拷贝目录) 5.安装mysql 查看mysql 安装文档一些命令： 查看软件安装路径：whereis 软件名 查看运行文件的路径：which 运行程序名 etc(etcetera) -grep: 在指定的文本文件中查找指定的字符串tree：以树状图列出目录的内容 tree -a：显示所有目录和内容 -d：显示目录名称而非内容 -f：在每个文件或目录之前，显示完整的相对路径名称 -t：按修改时间排序 详见:http://www.cnblogs.com/leijiangtao/archive/2014/06/08/3776280.html 安装软件包： sudo apt-get install packagename 删除软件包： sudo apt-get remove packagename 获取新的软件包列表： sudo apt-get update 升级有可用更新的系统： sudo apt-get upgrade 列出更多命令和选项： apt-get help 搜索包 apt-cache search package 下载安装程序到你的/var/cache/apt文件夹里面然后进行安装。 sudo apt-get install package - - reinstall 重新安装包 sudo apt-get -f install 修复安装&quot;-f = ――fix-missing&quot; sudo apt-get remove package 删除包 sudo apt-get remove package - - purge 删除包，包括删除配置文件等 sudo apt-get update 更新源 sudo apt-get upgrade 更新已安装的包 sudo apt-get dist-upgrade 升级系统 sudo apt-get dselect-upgrade 使用 dselect 升级 apt-cache depends package 了解使用依赖 apt-cache rdepends package 是查看该包被哪些包依赖 sudo apt-get build-dep package 安装相关的编译环境 apt-get source package 下载该包的源代码 sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包 sudo apt-get check 检查是否有损坏的依赖 /var/cache/apt/archives.VIM编辑器的使用 VIM的运行模式 编辑模式：等待编辑命令输入 插入模式：编辑模式下，输入 i 进入插入模式，插入文本信息 命令模式：在编辑模式下，输入 “：” 进行命令模式安装时创建的系统用户 此用户创建时被添加到admin组中，在Ubuntu中，admin组中的用户默认是可以使用sudo命令来执行只有管理员才能执行的命令的。如果不使用sudo就是一个普通用户。查看账户系统文件 1、sudo cat /etc/passwd 2、sudo cat /etc/shadow 为了增加系统的安全性，用户口令通常用shadow passwords保护。只有root可读。每行包含如下信息： 用户名：口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志 root:$6$Kn.oyu1E$Ig9ygYJSl8YYi37BKQ7W96MdIivd7B7MIfmxHByjQgZJsCLaiKK2Ig010MjJ9cKRsL2VuohOqxHs83QfE0s9f.:17238:0:99999:7::: wch:$1$vpZEMeej$AeughttPPFKzqNjL.zicc.:17238:0:99999:7::: 3、sudo cat /etc/group 用户组的配置文件 root:x:0: 1、用户组名称 2、 用户组密码 给用户组管理员使用通常不用。 3、 GID 用户组的ID 4、 此用户支持的账号名称 一个账号可以加入多个用户组，例如想要itcast 加入root 这个用户组，将该账号填入该字段即可,root:x:0:root,icast将用户进行分组是 Linux对用户进行管理及控制访问权限的一种手段。一个中可以有多个用户，一个用户可以同时属于多个组。该文件对所有用户可读。 4、sudo cat /etc/gshadow 该文件用户定义用户组口令，组管理员等信息只有root用户可读。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849使用命令行工具管理账户 useradd 用户名 useradd –u（UID号） useradd –p（口令） useradd –g（分组） useradd –s（SHELL） useradd –d（用户目录） 使用usermod修改用户信息 usermod –u（新UID） usermod –d（用户目录） usermod –g（组名） usermod –s（SHELL） usermod –p（新口令） usermod –l（新登录名） usermod –L (锁定用户账号密码) usermod –U (解锁用户账号) userdel 用户名 (删除用户账号) userdel –r 删除账号时同时删除目录 sudo usermod –u 1007 –g group2 –G root thinkpad 将thinkpad用户uid修改为1007，默认组改为系统中已经存在的group2，并且加入到系统管理员（GID 0）组。 组账户维护命令 groupadd 组账户名 (创建新组) groupadd –g 指定组GID groupmod –g 更改组的GID groupmod –n 更改组账户名 groupdel 组账户名 (删除指定组账户) 口令维护命令 passwd 用户账户名 (设置用户口令) passwd –l 用户账户名 (锁定用户账户) passwd –u 用户账户名 (解锁用户账户) passwd –d 用户账户名 (删除账户口令) gpasswd –a 用户账户名 组账户名 (将指定用户添加到指定组) gpasswd –d 用户账户名 组账户名 (将用户从指定组中删除) gpasswd –A 用户账户名 组账户名 (将用户指定为组的管理员)OpenSSHSSH是芬兰一家公司开发。但是受到版权和加密算法限制，现在很多人都使用OpenSSH。OpenSSH是SSH的替代软件，免费。OpenSSH由客户端和服务端组成。OpenSSH提供两种级别的验证方式。（1）基于口令的安全验证：知道服务器的帐号密码即可远程登录，口令和数据在传输过程中都会被加密。（2）基于密钥的安全验证：此时需要在创建一对密钥，把公有密钥放到远程服务器上**自己的宿主目录**中，而私有密钥则由自己保存。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习（1）]]></title>
    <url>%2F2019%2F02%2F14%2FLinux%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Linux学习（1） 个人笔记，如有错误，恳请批评指正。 一些常识 操作系统主要用于管理与驱动硬件，因此必须要能够管理内存、管理设备、负责进程管理以及系统调用等。 UNIX的前身是由Bell实验室的Ken Thompson利用汇编语言写成的，后来在1971-1973年由Dennis Ritchie以C程序语言进行改写，才称为UNIX。 1977年由Bill Joy释放出BSD（Berkeley Software Distribution），这些称为UNIX like的操作系统。 1984年，由Andrew Tannenbaum制作出了Minix操作系统，改系统提供源码以及软件。 1984年由Richard Stallman提倡GNU项目，倡导自由软件（Free Software），强调其软件可以自由地复制、取得、修改与再发行，并规范出GPL授权模式，任何GPL软件均不可单纯仅销售其软件，也不可修改软件授权。 1991年由芬兰人Linus Torvalds开发出Linux操作系统。简而言之，其成功的地方在于Minix（UNIX）、GNU、Internet、POSIX及虚拟团队的产生。 Linux最底层的数据为内核（Kernel）。 Linux内核版本命名方式，稳定的偶数版本，适合家用和商业版本；开发中版本的技术版，适合开发功能的环境。 学习Linux需要注意的几点： 计算机概论及硬件相关知识 常见的命令 Linux操作系统的基础技能 务必学会vi文本编辑器 shell与shell脚本的学习，包括“正则表达式”、“管道命令”、“数据流重定向” 网络基础的学习 各硬件设备在Linux中的文件名在Linux系统中，每个设备都被当成一个文件来对待。 磁盘分区的选择挂载：文件系统与目录树的关系，所谓挂载，就是利用一个目录当成进入点，将磁盘分区的数据放置在该目录下；也就是说，进入该目录就可以读取该分区的数据，进入的站点称为挂载点。 安装方式虚拟机安装原料：Ubuntu Kylin的ISO、VMware或VirtualBox优点：一条龙服务，安全简单缺点：用户体验差，隔靴搔痒 Wubi安装原料：Ubuntu Kylin的ISO、wubi.exe优点：即点即用，默认Windows开机引导缺点：易死机，待机和网络易出问题 U盘安装原料：Ubuntu Kylin的ISO、UltraISO、EasyBCD、U盘(&gt;=2G)优点：简单安全，正牌双系统缺点：默认Ubuntu开机引导 Linux Ubuntu虚拟机命令交互：CTRL+ALT+F1~F6图形交互：CTRL+ALT+F7root默认关闭，sudo passwd root设置密码并开启。 第一部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311：linux基础简介 1：操作系统（Operating System） 1：操作系统是管理计算机硬件与软件资源的程序 2：典型操作系统 1：UNIX、LINUX、Mac OS X、Windows iOS、Android、MS-DOS 3：操作方式 1：命令行界面(Command Line Interface CLI) 1：用户通过键盘输入指令，计算机接收到指令后，予以执行。 2：优点 1：节约计算机系统的资源 2：操作速度快（记住命令） 3：常见 1：DOS、UNIX、LINUX 2：图形用户界面(Graphical User Interface，简称 GUI) 1：采用图形方式显示的计算机操作 2：优点 1：操作简单 2：用户友好 3：缺点 1：比图形命令界面消耗资源 4：常见 1：WINDOWS、Mac OS 2：UNIX与MINIX 1：UNIX 1：1969年由贝尔实验室的肯.汤普逊、丹尼斯.里奇带领下开发出UNIX 1：肯.汤普逊：UNIX之父 2：丹尼斯.里奇：C语言之父 2：之前使用汇编语言B语言，1973年用两人改用C语言（高级语言）重写 2：MINIX 1：贝尔实验室收回版权并且规定“不可对学生提供源码”。 2：Andrew S. Tanenbaum（谭帮宁）教授为了授课，在不参考UNIX源码下写出了MINIX 1：计算机网络、现代操作系统作者，MINIX之父。 3：LINUX 1：1991年，芬兰人林纳斯.托瓦兹在赫尔辛基大学自己动手写了操作系统，就是LINUX内核（Linux kernel）。 2：吉祥物企鹅。 2：Linux加入GNU并遵循公共版权许可证 （GPL）。 4：GNU（“GNU&apos;s Not Unix”） 1：理查德.斯托曼博士1983 年启动建立一个完全相容于UNIX的自由软件环境 1：自由软件 1：赋予用户复制、研究、修改和散布该软件的权利，并提供源码供用户自由使用 2：核心的操作系统内核发展受挫，于是采用Linux kernel，应用在GNU系统中 5：GPL（General Public License 通用公共许可证） 1：为了避免GNU开发的软件被其他人利用成为专利软件 2：Copyleft（专利软件是Copyright） 3：目的要让GNU永远是免费和公开的 6：Linux简介 1：Linux是一种自由和开放源码的类UNIX操作系统 2：LINUX特点 1：开放性，多用户，多任务，丰富的网络功能，可靠的系统安全，良好的可移植性， 良好的用户界面（命令界面，图形界面等），出色的速度性能 3：LINUX组成 1：内核 2：Shell 3：文件系统 4：应用程序 4：LINUX版本 1：LINUX内核（Linux kernel） 1：系统的心脏 2：发行版本（Distribution） 1：厂商将Linux系统内核与应用软件和文档包装起来，并提供一些安装界面和系统设定管理工具的一个软件包的集合 2：常见 RedHat Linux，Debian，Ubuntu, Novell/SuSE Linux 7：Ubuntu 1：Ubuntu版本由发布的年份和月份组成最新的版本为Ubuntu 16.04 查看Ubuntu版本cat /etc/issue 或者 sudo lsb_release -a 2：Linux系统安装 1：下载iso系统镜像文件刻录光盘，一步步安装。 1：该步骤和安装windows系统一样，傻瓜式安装 2：Vmware虚拟机安装 1：虚拟机（Virtual Machine）是一个软件，可以模拟出具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。 2：安装参看安装文档。 3：注意：安装完虚拟机后，进入网上邻居—）》属性—》》 禁用 VMware Network Adapter VMnet1 和 VMware Network Adapter VMnet8 3：使用VMware安装Ubuntu 1：参看安装文档。 1：设置用户名和密码，用户名不能设置为root 3：Linux的命令行与图形界面切换 1：命令行界面 1：在图形化界面中打开命令行窗口 应用程序-》附件-》终端 2：切换到纯命令行是使用Ctrl加Alt加F1~F6： 注意： 使用ctrl+alt 和Vmware软件有冲突，需要修改VMware的快捷键 （在VMware左上角edit-&gt;preferences-&gt;hot keys，将ctrl+alt 修改为ctrl+shift+alt） 1.Ctrl+Alt+F1 切换到控制台1（tty1） 2.Ctrl+Alt+F2 切换到控制台2（tty2） 3.Ctrl+Alt+F3 切换到控制台3（tty3） 4.Ctrl+Alt+F4 切换到控制台4（tty4） 5.Ctrl+Alt+F5 切换到控制台5（tty5） 6.Ctrl+Alt+F6 切换到控制台6（tty6） 3: 使用who命令查看当前已经登录的用户 2：图形用户界面(Graphical User Interface，简称 GUI) 2：ctrl+alt+f7切换到图形用户界面 4: 普通用户与超级管理员 1:显示“$”标识表示是普通用户 例如： 进入linux系统，控制台出现：wch@ubuntu:~$ ~用户的根目录 2:显示“#”标识表示是超级管理员： 3：切换用户 切换用户（使用su命令切换用户）： 当从普通用户切换到root用户（超级管理员）或其他用户时，需要输入目标用户的密码。 当从root用户切换到普通用户时，不需要输入密码。 5：Linux目录结构 1：Linux所有内容是以文件形式进行管理 2：/ 根目录 1：bin （binaries） 存放二进制可执行文件(ls,cat,mkdir等) 2：boot 存放用于系统引导时使用的各种文件 3：dev (devices) 用于存放设备文件 dev是device的简写，就是“设备”的意思。Linux把每个硬件也看作是一个文件 4：etc 存放系统配置文件的目录 1：例如安装jdk配置环境变量 5：home 存放所有用户文件的根目录 1：用户登录系统后默认所在的目录 6：mnt 系统管理员安装临时文件系统的安装点 例如：挂载光驱。 7：opt 额外安装的可选应用程序包所放置的位置 例如：我们可以安装自定义程序1：安装eclipse，安装tomcat 8：root 超级用户目录 1：管理员 9：sbin (super user binaries) 存放二进制可执行文件，只有root才能访问 10：usr (unix shared resources) 用于存放系统应用程序，有些类似windows的Program Files 例如：软件中心下载的软件默认安装在usr/bin中。 我们也可以将jdk安装在此目录中。 图形化界面查看 Places -Documents-File System (/ 根目录) 11: var(variable)用于存放运行时需要改变数据的文件 第二部分Linux基本命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293Linux的常用命令： 1.注销、关机、重启命令 注销：logout或exit（要login才能有logout，否则是exit） 关机：halt或shutdown -h now（要是root用户或是有授权才可以）（now还可以用时间点12：00和时间段3（min）代替） 重启：reboot或shutdown -r now（要是root用户或是有授权才可以） 2：Linux的基本命令 1：ls 显示文件和目录列表 1： -l 列出文件的详细信息 2： -a 列出当前目录所有文件，包含隐藏文件（可组合如 -la） 2：mkdir 创建目录 （ 删除？rmdir 非空） 1：-p 父目录不存在情况下先生成父目录 3：cd 切换目录 cd.. 退回 cd ../XXX上级目录的子目录 4：touch 生成一个空白的普通文件 touch a.txt 5：echo 生成一个带内容文件 1：echo &quot;abcd&quot;&gt;a.txt &gt;表示覆盖 &gt;&gt;表示追加 6：cat、more 显示文本文件内容 cat 直接跳到末尾 more 从头看，space进行翻页 7：cp 复制文件或目录 1：cp a.txt /home/wch/abc/ddd 8：rm 删除文件 1：rm a.txt 2：rm -rf abc -f force 强制删除（什么都不问） -i 删除之前询问 输入y表示删除，默认不删除 -d 删除空白的目录 -r 或者-R或者--recursive 递归的删除一个文件夹，即用于删除非空文件夹。 9：mv 移动文件或目录、文件 假若剪切的文件存放在同一目录中，则替换就可重命名 1：mv aaa bbb 将aaa改名为bbb 2：mv bbb /home/abc/ccc 10：find 在文件系统中查找指定的文件 1：find -name 文件名 11：wc 统计文本文档的行数，字数，字符数 1：wc a.txt num1 num2 num3分别表示行数 单词数 字符数 12：grep 在指定的文本文件中查找指定的字符串 1：grep aa a.txt 13：pwd 显示当前工作目录的绝对路径 14：ln 建立链接文件（***） 默认是硬链接，好比复制，但是两个文件会同步，软连接也会同步，但是软连接的文件不会占用空间，相当于快捷方式。 1：ln -s /home/familyA/house/roomB /home/roomB 1：当访问一个目录较深的文件，可以建立链接文件。 2： 遇到 Permission denied（权限拒绝）说明wch用户没有权利做这件事 1：使用sudo 可以借用root的权限，输入wch的密码 3：在home下就可以直接访问roomB的文件 4：例如安装jdk路径需要配置环境变量，如果路径较长书写麻烦可以配置连接文件 第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化； 第二，ln的链接又软链接和硬链接两种，软链接就是ln –s ** **，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间。 硬链接ln ** **，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。 如果你用ls察看一个目录时，发现有的文件后面有一个@的符号，那就是一个用ln命令生成的文件，用ls –l命令去察看，就可以看到显示的link的路径了。 15：more、less 分页显示文本文件内容 1：查看配置文件时，很长需要分页处理 2：more（一页一页翻） 1：空格键向下翻页 2：Enter键向下滚动一行 3：:f 显示出文件名及当前的行数 4： q 离开more 5： b 往回翻 3：less（一页一页翻） 1：空格 向下翻一页 2：PageDown 向下翻一页 3：PageUp 向上翻一页 4：q 离开 16：head,tail分别显示文件开头和结尾内容 17：man 命令帮助信息查询 manual：手册 1：man ls 18：管道（***）将|之前命令的输出作为|之后命令的输入 1： cat /etc/passwd | wc -l 使用cat命令显示passwd文件中的内容，但是并没有显示在屏幕上，而是通过管道“|” 接受，wc命令从管道中取出内容进行统计，然后显示结果 这个输出时该文件有多少行（多少个用户） 19：重定向 1：&gt; cat /etc/passwd&gt;/home/wch/a.txt echo &quot;hello java&quot;&gt;a.txt （覆盖上一个a.txt） 2：&gt;&gt; 1：追加，不会覆盖 cat /etc/passwd&gt;&gt;/home/wch/a.txt echo &quot;---------&quot;&gt;&gt;a.txt 20:su 切换用户 su root需要输入root用户的密码 root切换其他用户不需要密码 21：passwd 修改密码，root操作 sudo passwd root Linux系统命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341353：Linux系统命令 1：stat 显示指定文件的相关信息 1：stat familyA access 进入 Modify 修改 Change 改变 access time是文档最后一次被读取的时间。因此阅读一个文档会更新它的access时间， 但它的modify时间和change时间并没有变化。cat、more 、less、grep、tail、head这些命令都会修改文件的access时间。 change time是文档的索引节点(inode)发生了改变(比如位置、用户属性、组属性等)； modify time是文本本身的内容发生了变化。[文档的modify时间也叫时间戳(timestamp) 2：who、显示在线登录用户 1：想要知道当前有多少用户登录系统。 2：who 1：显示2个一个是命令行，一个是图形界面的只有一个wch 3：whoami 显示用户自己的身份 4：hostname 显示主机名称 1：hostname 2：hostname -i 显示主机IP 5：uname 显示系统信息 1：uname -a 显示全部信息 Linux ubuntu 2.6.35-22-generic #33-Ubuntu SMP Sun Sep 19 20:34:50 UTC 2010 i686 GNU/Linux 6：top 显示当前系统中耗费资源最多的进程 动态显示过程，实时监控 3s刷新一次 1：类似于windows的任务管理器 2：主要看 cpu mem command 3；ctrl+c 退出，或者q 7：ps 显示瞬间进程状态 快照 1：ps -aux 显示所有瞬间进程状态 8：du 显示指定的文件（目录）已使用的磁盘空间的总量 1：du 2：du familyA （以K为单位） 3：du -h familyA 9：df 显示文件系统磁盘空间的使用情况 disk free 1：df -h 10：free 显示当前内存和交换空间的使用情况 11：ifconfig 显示网络接口信息 1：windows 是ipconfig ipv4:32位 2^32个地址数 ipv6:128位 是v4的2^96倍 设置虚拟机的ip地址： 设置vmware的连接方式： 主机与虚拟机之间的关系： 1、桥接模式：虚拟机独立IP 2、共享模式（NAT模式） 3、仅主机模式 12：ping 测试网络的连通性 13：clear 清屏 windows是cls 14：kill 杀死一个进程 15：关机/重启命令 1：shutdown 命令可以安全的关闭Linux系统，shutdown命令必须有超级用户才能执行。shutdown命令执行后会以广播的形式通知正在系统中工作的所有用户， 1：shutdown -h now （关机不重启） 2：shutdown -r now （关机重启） 3：shutdown now （关机） 4：shutdown 15:22 2：halt 关机后关闭电源 3：reboot 重新启动 16：useradd 查看用户：sudo cat /etc/passwd wch:x:1000:1000:ubuntu,,,:/home/wch:/bin/bash - wch: 用户名 - x:密码，已加密，存放在/etc/shadow - 1000：账号id，userId - 1000：组id，group id - ubuntu,,,:账号描述 - /home/wch:该账号存放的默认位置 创建用户：useradd wch2 -d /home/wch2 -s /bin/bash -d 指定该用户的home路径 -s 该用户的shell解析方式 步骤：1、创建/home/wch2的目录 2、执行useradd命令 3、用passwd设置密码 4、su切换用户 4：备份压缩命令 1：tar tar -cxzjvf &lt;打包后的文件&gt; &lt;欲打包的目录&gt; -c：创建的一个归档文件，即打包文件夹 -x：拆包，与-c相反 -z：以gzip格式压缩，默认倍数6倍（0~9） -j：以bzip格式压缩 -v：显示打包或者拆包的文件信息 -f：后面紧接一个归档文件 1:打包 1：tar -cvf familyA.tar familyA （tar -cvf 保存路径/包名 打包目录） 2：拆包 1：tar -xvf /home/wch/familyA.tar 2：gzip 命令 gzip 压缩（解压）文件，压缩文件后缀为gz 1：压缩 1：把/home/wch目录下的familyA目录下所有文件压缩成.gz文件 1：gzip只能压缩文件，目录（文件夹不能处理），需要使用tar对文件夹打包 1：gzip familyA.tar 进行压缩 2：查看压缩文件 1：gzip -l familyA.tar.gz 查看压缩包详细信息 1：compressed 压缩后大小 2：uncompressed 原始大小 3：ratio 压缩比 4：uncompressed_name 原始文件名 3：解压 1：gzip -d familyA.tar.gz 显示文件名和压缩比 4：压缩比 1：高压缩（速度稍慢） gzip -9 familyA.tar 高压缩比 gzip -l familyA.tar.gz 2：低压缩比（速度快） gzip -d familyA.tar.gz （解压） gzip -1 familyA.tar 低压缩比 gzip -l familyA.tar.gz 3：默认是6 3：bzip2 命令 bzip2 压缩（解压）文件或目录，压缩文件后缀为bz2 1：压缩 1：把/home/wch目录下的familyA目录下所有文件压缩成.bz2文件 1：bzip2 -z familyA.tar 压缩需加上参数-z 2：解压缩 1：bzip2 -d familyA.tar.bz2 4：tar命令压缩和解压 1：将整个/home/wch/familyA目录下的文件全部打包成为/home/wch/familyA.tar 1：仅打包，不压缩 1：tar -cvf familyA.tar familyA 2：打包后，以gzip压缩 1：tar -zcvf familyA.tar.gz familyA 拆包 sudo tar -zxvf familyA.tar.gz 3：打包后，以bzip2压缩 1：tar -jcvf familyA.tar.bz2 familyA 拆包 sudo tar -jxvf familyA.tar.bz2 linux ls -al 的各段含义123456789101112131415161718192021222324252627282930313233343536373839404142434445linux drwxr-xr-x 第一位表示文件类型。d是目录文件，l是链接文件，-是普通文件，p是管道第2-4位表示这个文件的属主拥有的权限，r是读，w是写，x是执行。第5-7位表示和这个文件属主所在同一个组的用户所具有的权限。第8-10位表示其他用户所具有的权限。如：wch@ubuntu:~/Desktop$ ls -latotal 20drwxr-xr-x 3 wch wch 4096 Mar 13 19:38 .drwxr-xr-x 15 wch wch 4096 Mar 13 19:49 ..-rw-rw-r-- 2 wch wch 9 Mar 13 19:12 aaa-rwxrw-rw- 1 wch wch 24 Mar 13 21:57 a.txtlrwxrwxrwx 1 wch wch 17 Mar 13 19:11 bbb -&gt; ./java/j2ee/z.txt-rw-rw-r-- 1 wch wch 0 Mar 13 19:37 bbbbbbbb.txtdrwxrwxr-x 5 wch wch 4096 Mar 13 18:41 javalinux ls -al 的各段含义第1字段: 文件属性字段文件属性字段总共有10个字母组成,第一个字母表示文件类型,如果这个字母是一个减号”-”,则说明该文件是一个普通文件.字母”d”表示该文件是一个目录,字母”d”,是dirtectory(目录)的缩写.请注意,一个目录或者说一个文件夹是一个特殊文件,这个特殊文件存放的是其他文件和文件夹的相关信息.第2字段文件硬链接数或目录子目录数第3字段:文件拥有者第4字段:文件拥有者所在的组第5字段:文件文件大小(以字节为单位)第6字段:文件创建月份第7字段:文件创建日期第8字段:文件创建时间第9字段:文件名 (如果是一个符号链接,那么会有一个 “-&gt;” 箭头符号,后面根一个它指向的文件)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK的安装及环境变量的配置]]></title>
    <url>%2F2019%2F02%2F14%2FJDK%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[JDK的安装及环境变量的配置个人笔记，如有错误，恳请批评指正。 刚换了电脑，涉及到JDK的安装以及环境的配置，写了个教程贴在这里，免得以后再换电脑又忘了… 常见的dos命令dir : 列出当前目录下的文件以及文件夹md : 创建目录rd : 删除目录cd : 进入指定目录cd.. : 退回到上一级目录cd \ : 退回到根目录del : 删除文件exit : 推出dos命令行cls : 通知计算机将当前的命令清空echo “hello java”&gt;a.txt 写入文本到指定文件type a.txt 显示文件内容命令通配符。 可以匹配任意的名字。Ctrl+上下方向键： 可以找回上次执行过的命令。 Java简介语言起源Java是SUN ( Stanford University Network 斯坦福大学网络公司 ) 1995年推出的一门高级编程语言。 Java名称的来源 Java最初被命名为Oak，目标在于家用电器等小型系统的编程语言，随着市场的变化，SUN着眼于网络应用的开发。Java的名字的来源：Java是印度尼西亚爪哇岛的英文名称，因盛产咖啡而闻名。 1995年5月23日，JAVA语言诞生 1996年，1997分别推出JDK1.0，JDK1.1版 1999年，JAVA被分成J2SE,J2EE,J2ME 2000年，JDK1.4发布 2004年9月30日18:00PM，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0 2005年，JAVA版本正式更名为JAVAEE,JAVASE, JAVAME 2006年12月，SUN公司发布JRE6.0 2009年04月20日，Oracle以74亿美元收购Sun。取得java的版权。 2010年9月，JDK7.0已经发布，增加了简单闭包功能。 2011年7月，甲骨文公司发布java7的正式版。 环境的搭建JDK简介:JDK（Java Development Kit）是Sun Microsystems针对Java开发员的产品。自从Java推出以来，JDK已经成为使用最广泛的Java SDK。JDK 是整个Java的核心，包括了Java运行环境、Java工具和Java基础类库。JDK是学好Java的第一步。从SUN的JDK5.0开始，提供了泛型等非常实用的功能，其版本也不断更新，运行效率得到了非常大的提高。 JDK的安装网址：http://www.oracle.com/index.html 、http://www.java.sun.com JDK目录介绍 bin:存放的是开发java程序常用的工具。 demo：源代码的示例程序。 include:包含c的语言程序，支持c的本地接口和java虚拟机调试程序的本地接口。 sample： 主要包含一些典型的小例子JNLP示例 jre： 主要包含java程序运行需要的类 bin：用于运行时的可执行文件 lib：类库 安装JDK需要注意的事项： 1. 安装路径中不要包含中文。 2. 安装路径中不要包含空格。 JRE简介JRE Java Runtime Environment Java运行环境。包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。 配置path环境变量 在dos窗口敲上javac 我们在随意的一个目录敲javac或者java命令时候，发现dos窗口显示这个不是内部命令，然后我们在上面敲上notepad命令时，打开了一个记事本的程序，但是在当前目录下页没有存在notepad.exe的可执行文件，那么为什么能启动呢？错误原因：原来在dos窗口上写上一个命令时候，如果在当前目录下找不到指定的可执行文件，那么它会根据path环境变量保存的路径去搜索是否存在这个可执行文件，如果存在则启动该程序，否则就没有这个命令。 解决方法：1、 进入jdk的安装目录的bin目录。2、 在dos命令上敲javac。(如果出现了以上的图信息则配置成功) 为什么要配置path环境变量因为在jdk下bin文件夹中有很多我们在开发中要使用的工具，如java.exe,javac.exe,jar.ex等,那么我们在使用时，想要在电脑的任意位置下使用这些java开发工具，那么我们就需有把这些工具所在的路径配置到系统的环境变量中，当我们使用时，系统可以帮且我们找到这些命令。 如何配置path环境变量我们将jdk下bin的路径进行复制在我们电脑—–属性—–高级—–环境变量———path这项将bin的路径放置到path的最前边，别忘记加分号. JAVA_HOME环境的配置有时候可能需要更换Jdk的目录，但是经常修改path的值可能会不小心修改其他的路径，解决方法： 1、 创建一个JAVA_HOME的变量。 2、 JAVA_HOME的值为JDK的安装目录。 3、 配置path路径：%JAVA_HOME%。 以后需要更换JDK的目录时，只需要更换JAVA_HOME的目录即可。 设置临时变量： set ： 查看所有的环境变量信息。 set 变量名 ：查看具体一个环境变量的值。 set 变量名=：清空一个环境变量的值。 set 变量名=具体值 ：给指定变量定义具体值。想要在原有环境变量值基础上添加新值呢？首先，通过%变量名%操作符获取到原有环境变量的值。然后加上新值后在定义给该变量名即可举例：给path环境变量加入新值set path=新值;%path%注意：这种配置方式只在当前dos窗口有效。窗口关闭，配置消失。 classpath环境变量 classpath的作用: 作用是指定类搜索路径，保存class文件的存储路径。要使用已经编写好的类，前提当然是能够找到它们了，JVM就是通过CLASSPTH来寻找类的。 如何设置当前目录（.）set classpath=.;设置路径 与 set classpath=设置路径;.有什么区别?“.”在前面的时候，java虚拟机会先从当前路径去寻找class文件，然后再到指定的路径去需找。如果”.”在后面，java虚拟机则会先寻找指定好的路径,然后再在当前的路径去寻找。设置classpath的时候要加上 ; 就会在当前目录下查找。 JAVA CLASSPATH 和PATH的区别PATH:用来指定 java虚拟机(JVM) 所在在目录告诉java虚拟机,因为我们要常用到java给我们提供的一些工具对原代码进行一些处理或者是提取原代码的信息。CLASSPATH：用来指定我们自己所写的或要用到的类文件(.class文件) 所在的目录。]]></content>
      <categories>
        <category>实用技术</category>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK</tag>
        <tag>环境变量</tag>
        <tag>CLASSPATH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java核心技术（卷一）（第五章 继承）]]></title>
    <url>%2F2019%2F02%2F14%2FJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%88%E5%8D%B7%E4%B8%80%EF%BC%89%EF%BC%88%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E7%BB%A7%E6%89%BF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java核心技术（卷一）（第五章 继承）继承，反射个人笔记，如有错误，恳请批评指正。 继承(inheritance) 5.1 类、超类和子类 super不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个指示编译器调用超类方法的关键字，指向超类的域。 this的两个用途：一是引用隐式参数，二是调用该类其他的构造器。super：一调用超类的方法，二是调用超类的构造器。两个调用构造器时作为第一条语句出现，不能共存。 重载：方法名相同，签名不同的两个方法，与返回类型无关。重载的方法具有可协变的返回类型，即允许重载的方法的返回类型定义为原返回类型的子类型。 如果是private、static、final方法，编译器将准确知道应该调用哪个方法，这种调用方式称为静态绑定（static binding）。 动态绑定（dynamic binding），调用的方法依赖于隐式参数的实际类型。在执行期间（非编译期）判断所引用对象的实际类型，根据其实际的类型调用其相应的方法 每次调用都要进行搜索会花费开销，因此虚拟机为每个类创建了方法表（method table），其中列出了所有方法的签名和实际调用的方法。 阻止继承：final修饰类或者方法，则改类不能被继承，该方法不能被覆盖。当类被修饰为final时，其中的所有方法将被修饰为final，域则不受影响。 null instanceof X 不会报错，只会返回false。 5.1.6 抽象类 除了抽象方法以外，抽象类中还可以包含具体数据和具体方法。抽象方法充当占位的作用，他们的具体实现在子类中。 类即使不含抽象方法，也可以被声明为抽象类。 可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象。 5.1.7 受保护访问protected：受保护域标记。实际引用中要谨慎使用，假设需要将设计的类提供给他人使用，而在这个类中设置了一些受保护域，由于他人可能会对该类进行继承，直接访问其中的受保护域。这种情况下，如果需要对这个类的实现进行修改，就必须通知所有使用了该类的人。这违背了OOP提倡的数据封装原则。受保护的方法更具有实际意义，子类可用，其他类不行。 private 私有 public 对所有类可见 protected 对本包和所有子类可见 对本包可见：默认，不需要修饰符 5.2 Object：所有类的超类在Java中，只有基本类型（primitive types）不是对象，例如：数值、字符和布尔类型值都不是对象。所有的数组类型，不管是对象数组还是基本类型数组都扩展于Object类。 5.2.1 equals方法5.2.2 相等测试和继承Java语言规范要求equals具有以下的特性： 自反性：对于任何非空的引用x，x.equals（x）返回true。 对称性：对于任何x和y，当且仅当y.equals（x）返回true，x.equals（y）也返回true。 传递性：对于任何x、y、z，如果x.equals(y)返回true，y.equals(z)返回true，则x.equals(z)也返回true。 一致性：如果x和y引用的对象没有变化，则反复调用equals的结果应该是一致的。 对于任意的非空引用，x.equals(null)返回false。 equals具有该特性，所以定义equals方法的时候需要遵守，少用instanceof运算符。某些观念认为，equals应该不涉及getClass检测，因为这不符合置换原则。 编写一个完美equals方法的建议： 显式参数命名为otherObject，稍后需要将他转换成另一个叫做other的变量。 检测this与otherObject是否引用了同一个变量。 1if(this == otherObject) return true; 检测otherObject是否是null，如果是null，返回false。这项检测很有必要。 1if( otherObject == null) return false; 比较this与otherObject是否属于同一类。如果equals的语义在每个子类总有所改变，就使用getClass检测： 1if(getClass()!= otherObject.getClass()) return false; 如果所有的子类都拥有同一的语义，就使用instanceof检测： 1if(!(otherObject instanceof ClassName)) return false; 将otherObject强转为对应的类类型变量 1ClassName other = (ClassName) otherObject; 现在开始对所有需要比较的域进行比较。使用==比较基本类型域，equals比较对象域，如果所有的域都能匹配则return true；否则return false。如果在子类重新定义了equals，就要在其中包含super.equals(other)。 @Override 表示正在重写一个方法，如果没有签名不符合，则会报错。 5.2.3 hashCode方法散列码（hash code）是由对象导出的一个整形值。 Object中存在hashCode方法，该值根据存储地址计算出hashCode值，源码： 如果重新定义equals方法，就必须重新定义hashCode方法，以便用户可以将对象插入到散列表中。在插入散列表中，要判断equals，并且要根据hashcode确定存储位置。（见数据结构 散列表）。 计算int的hashCode。 1int h = new Integer(4).hashCode();//4的hashcode Objects.hashCode(Object… objects);提供hashcode的批量计算。 JDK1.7 改为hash（Object… objects） 5.3 泛型数组列表12345public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(100);//JDK1.7一下不支持菱形运算符 list.add(2, 3); &#125; //将报java.lang.IndexOutOfBoundsException异常 泛型的使用使得类型转换错误提前至编译时被发现。 @SuppressWarning（“unchecked”）标记这个变量能接受类型转换。 5.4 对象包装器与自动封箱包装器（wrapper）：Integer、Long、Float、Double、Short、Byte、Character、Void、Boolean，一旦构造了包装器，就不允许修改其中的值，并且包装器还是final类，因此不能定义他们的子类。 自动封箱和自动拆箱出现的假象：即基本类型和包装器是一样的。实际上下列代码不一样需在某些条件下才会成立： 12345678public static void main(String[] args) &#123; Integer a = 127; Integer b = 127; System.out.println(a==b);//true Integer c = 128; Integer d = 128; System.out.println(c==d);//false &#125; 原因：自动装箱规范要求boolean、byte、char&lt;=127，介于-128到127之间的short和int被包装到固定的对象中。 装箱和拆箱是编译器认可的，而不是虚拟机。编译器在生成类的字节码时，插入必要的方法调用，虚拟机只负责执行这些字节码。 String转int ： 12Integer.parseInt(str);Integer.parseInt(str,radix);//radix表示进制数 Java中都是值传递，即传递的是值的拷贝，而不是对象本身。所以不能直接改变数值参数值，有一种方法就是，使用org.omg.CORBA包中定义的持有者（holder）类型，包括IntHolder、BooleanHolder等。每个持有者类型都包含一个公有（！）域值，通过它可以访问存储在其中的值。 5.5 可变参数 JDK1.5… 1234567891011121314151617public class Demo7 &#123; public static double findMax(double... values)&#123; Double max = Double.MIN_VALUE; for (Double value : values) &#123; if(value&gt;max) max = value; &#125; return max; &#125; public static void main(String... args) &#123; System.out.println(Double.MIN_VALUE); System.out.println(Double.MAX_VALUE); double[] d = &#123;1,2,5,3.2,3.2,412,0.33,19.99,5253.22&#125;; double max = findMax(d); System.out.println(max); &#125;&#125; 5.6 枚举类所有的枚举类型都是Enum的子类，他们继承了这个类的很多方法。toString：Size.SAMLL.toString(); 123456789101112public class Demo8 &#123; enum Size&#123; SMALL,MEDIUM,LARGE; &#125; public static void main(String[] args) &#123; while (true) &#123; String str = "SMALL"; Size size = Enum.valueOf(Size.class, str); System.out.println("size=" + size); &#125; &#125;&#125; 5.7 反射能够分析类能力的程序称为反射（reflective），其功能强大。 1Class c1 = Class.forName(&quot;java.lang.String&quot;); 将forName与newInstance配合使用，可以根据类名创建一个对象。 1234String s = "java.util.Date";Object o = Class.forName(s).newInstance();//newInstance方法默认调用无参构造器，没有构造器则抛出InstantiationException异常//如果需要添加参数，则需要利用构造器Constructor类中的newInstance方法 注意：一个Class对象实际上表示的是一个类型，而这个类型未必一定是一种类。例如：下例中的int不是类，但int.class是一个Class类型的对象。 1Class c1 = int.class; 鉴于历史原因，数组类型的getName有前缀“[”。 5.7.2 捕获异常modifier：修饰符 public static之类annotation：注释 例程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Demo9 &#123; /** * 获取制定类中的所有域和方法 * @param className */ public static void printMethod(String className)&#123; try &#123; Class c1 = Class.forName(className); Class c2 = c1.getSuperclass(); Method[] cm1 = c1.getDeclaredMethods(); Method[] cm2 = c2.getDeclaredMethods(); ArrayList&lt;Method&gt; list = new ArrayList&lt;Method&gt;(); List&lt;Method&gt; l1 = Arrays.asList(cm1); List&lt;Method&gt; l2 = Arrays.asList(cm2); list.addAll(l1); list.addAll(l2); for (Method method : list) &#123; Class[] parameterTypes = method.getParameterTypes(); //获取形参列表 String str = ""; for (Class class1 : parameterTypes) &#123; str = str+class1.getSimpleName()+" "+class1.getSimpleName().substring(0,1).toLowerCase()+","; &#125; if(!str.isEmpty()) str = str.substring(0,str.length()-1);//包头不包尾 //拼接 System.out.print(Modifier.toString(method.getModifiers())); System.out.print(" "+method.getReturnType().getSimpleName()); System.out.println(" "+method.getName()+"("+str+")"+";"); &#125; System.out.println(); //所有域变量 ArrayList&lt;Field&gt; list2 = new ArrayList&lt;Field&gt;(); list2.addAll(Arrays.asList(c1.getDeclaredFields())); list2.addAll(Arrays.asList(c2.getDeclaredFields())); for (Field field : list2) &#123; System.out.print(Modifier.toString(field.getModifiers())); System.out.println(" "+field.getType().getName()+" "+field.getName()+";"); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; printMethod("java.lang.Double"); &#125;&#125; setAccessable(true);暴利反射！ 5.7.5 使用反射编写泛型数组代码java.lang.reflect.Array类允许动态创建数组。123456789101112131415public class Demo11 &#123; public static Object copyArray(Object obj,int newLength)&#123; Class c1 = obj.getClass(); if(!c1.isArray())return null; Class c2 = c1.getComponentType();//获取数组组成元素的类型 int length = Array.getLength(obj);//获取数组的长度 Object newArray = Array.newInstance(c2, newLength); System.arraycopy(obj, 0, newArray, 0, Math.min(length, newLength));//System中的arrayCopy方法 return newArray; &#125; public static void main(String[] args) &#123; String[] a = &#123;"haha","hehe","xixi"&#125;; System.out.println(Arrays.toString((String[])copyArray(a, 2))); &#125;&#125; 5.7.6 调用任意方法建议仅在必要的时候才使用Method方法，而最好使用接口和内部类。特别重申：建议Java开发者不要使用Method对象的回调功能，使用接口进行回调会使代码的速度更快。 5.8 继承设计的技巧 将公共操作和域放在超类 不要使用受保护的域因为：protected在子类或同包可见，子类集合无限制，同一个包也可自由访问。 使用继承实现“is-a”关系 除非所有的继承都有意义，否则不要使用继承。 在覆盖方法时候，不要改变预期的行为。 使用多态，而非类型信息。 不要过多的使用反射。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java核心技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>核心技术</tag>
        <tag>继承</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java核心技术（卷一）（第四章 对象与类）]]></title>
    <url>%2F2019%2F02%2F14%2FJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%88%E5%8D%B7%E4%B8%80%EF%BC%89%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java核心技术（卷一）（第四章 对象与类）对象与类个人笔记，如有错误，恳请批评指正。 4.1 面向对象程序设计概述 在OOP中不必关心具体的实现，数据结构的重要性高于算法。 4.1.1 类 封装是提高重用性和可靠性的关键，并对象赋予了“黑盒”特征。 继承（inheritance） 4.1.2 对象 对象的三个主要特征： 对象的行为（behavior）：对象的行为使用可调用的方法定义的。 对象的状态（state）：所维护的变量，具有封装性，只有特定的方法可以改变。 对象标识（identity） ：唯一的标识。 4.1.2类之间的关系 最常见的关系 依赖： uses-a 工程中，应尽量减小依赖，即降低耦合度。 聚合： has-a 继承： is-a 表达类关系的UML符号 4.2 使用预定义类 对象的引用，一个对象变量并没有实际包含一个对象，而仅仅引用了一个对象。 4.2.2 Java类库中的GregorianCalendar类涉及到Day、Month、Year时推荐使用Calendar不推荐使用Date。Calendar类方法丰富。 4.3 用户自定义类4.3.5 隐式参数和显式参数在每个方法中，this表示隐式参数，表示该方法的调用者对象。 4.3.6 封装的优点警告！！不要编写返回引用可变对象的访问器方法。例如下例： get方法返回的可变对象的引用可以对其进行修改从而破坏数据的封装性。如果需要返回一个可变对象的引用，应该首先对其进行克隆。1234567891011121314151617public class Employee &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; private Date hireDay; public Date getHireDay() &#123; return hireDay; //正确做法 return hireDay.clone(); &#125; public void setHireDay(Date hireDay) &#123; this.hireDay = hireDay; &#125;&#125; 12345678910111213public class Demo1 &#123; public static void main(String[] args) &#123; Employee emp = new Employee(); emp.setHireDay(new Date()); System.out.println(emp.getHireDay().toString()); Date a = emp.getHireDay(); a.setTime(a.getTime()-10100000000000l); System.out.println(emp.getHireDay().toString()); &#125; //运行结果： //Wed Feb 22 22:02:42 CST 2017 //Fri Feb 01 18:29:22 CST 1697&#125; 4.4.2 静态常量举例： System.out 12345public class System&#123; ... public static final PrintStream out = ...; ...&#125; 每个类对象都可以对共有域进行修改，所以最好不要将域设计为public。然而，共有常量（即final）域却没有问题，因为不能在被修改了。 4.4.3 静态方法再下面两种情况下使用静态方法： 一个方法不需要访问对象状态，其所需要的参数都是通过显示参数提供； 一个方法只需要访问类的静态域，即没有访问非静态成员。 4.5 方法参数按值调用（call by value）表示方法接收的是调用者提供的值。按引用调用（call by reference）表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。Java中总是采用值传递，即按值调用。方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。方法得到的是所有参数值的一个拷贝。一个方法不可能修改一个基本类型的参数，而对象引用作为参数却可以，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。 一个方法不能修改一个基本类型数据的参数（即数值型和布尔型） 一个方法可以改变一个对象参数的状态（与拷贝引用了同一个对象） 一个方法不能让对象引用一个新的对象 1234567891011121314151617181920212223242526public class Demo2 &#123; int a = 3; String b = "test"; public void changeCallByValue(int a)&#123; a = 2; System.out.println(a); &#125; public void changeCallByReference(String b)&#123; b = "okToChange"; System.out.println(b); &#125; @Test public void test1()&#123; changeCallByValue(a); System.out.println(a); changeCallByReference(b); System.out.println(b); &#125;&#125;结果：所有的变量类型都是值传递。/*23okToChangetest*/ 4.6.3 无参数的构造器有有参构造器时若没有无参构造器，调用无参构造器就会把报错，作为良好的编程习惯，最好都定义无参的构造器。当类没有定义任何构造器时，系统才会提供一个默认的构造器。 4.6.6 调用另外一个构造器如果构造器的第一个语句形如this（…），这个构造器将调用同一个类的另一个构造器。 4.6.7 初始化块只要构造类的对象，这些块就被执行。即使在类的后面定义，也可以在初始化块中设置域，规范起见，最好将初始化块放在域定义之后。1234&#123; name = "xxx"; id = "xxx";&#125; 4.6.8 对象析构与finalize方法Java有自动的垃圾回收器，不需要人工回收内存，所以Java不支持析构器。可以为任何一个类添加finalize方法。finalize方法将在垃圾回收器清楚对象之前调用，在实际应用中，不要依赖使用finalize方法回收任何短缺的资源。 有个名为System.runFinalizersOnExit(true)，能确保finalizer方法在Java关闭前被调用，不过这个方法并不安全，也不鼓励使用。有一种替代方法Runtime.addShutDownHook添加“关闭钩（shutdown hook）”，详见API。 4.9文档注释javadoc工具，由源文件生成文档。javadoc实用程序（utility）从以下几个方面抽取信息： 包 公有类和接口 共有的和受保护的构造器及方法 共有的和受保护的域 4.9.4 域注释只需要对共有域（通常指的是静态常量）建立文档：1234/***the "Hearts" card suit*/public static final int HEARTS = 1; 4.9.7 注释的抽取MyEclipse工具具有抽取的功能。具体做法： 使用eclipse生成文档（javadoc）主要有三种方法： 在项目列表中按右键，选择Export（导出），然后在Export(导出)对话框中选择java下的javadoc，提交到下一步。 在Javadoc Generation对话框中有两个地方要注意的： javadoc command:应该选择jdk的bin/javadoc.exe destination:为生成文档的保存路径，可自由选择。按finish(完成)提交即可开始生成文档。 用菜单选择：File-&gt;Export(文件－&gt;导出)， 剩下的步骤和第一种方法是一样的。 选中要生成文档的项目，然后用菜单选择， Project-&gt;Generate Javadoc直接进入Javadoc Generation对话框，剩余的步骤就和第一种方法在Javadoc Generation对话框开始是一样的。用哪种方法都行，但是要注意一下几个问题： 1、eclipse不能生成，报错：java.lang.IllegalArgumentException at sun.net.www.ParseUtil.decode，这是由于设置java环境变量引起的。例如classpath为.;%JAVA_HOME\lib\dt.jar;%JAVA_HOME%\lib\tool.jar，解决方法就是把classpath删除或是参考官方文档http://maven.apache.org/plugins/maven-javadoc-plugin/faq.html 。2、生成文档乱码问题。完善api-doc，用eclipse生成javadoc的时候发生“编码 GBK 的不可映射字符”其实是字符编码问题。打开eclipse，project -&gt; Generate javadoc一项一项的选你要输出javadoc的项目，最后一步中VM设置行中加入以下代码 复制代码 代码如下:-encoding utf-8 -charset utf-8 4.10 类设计技巧1. 一定要保证数据私有 2. 一定要对数据进行初始化 提供默认值或者在构造器中设置默认值。 3. 不要在类中使用过多的基本类型 4. 不是所有的域都需要独立的域访问器和域更改器 5. 将职责过多的类进行分解，即一个类中的方法不宜过多。 6. 类名和方法要能够体现他们的职责。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java核心技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>核心技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java核心技术（卷一）（第十一章 异常、日志和调试）]]></title>
    <url>%2F2019%2F02%2F14%2FJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%88%E5%8D%B7%E4%B8%80%EF%BC%89%EF%BC%88%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E5%BC%82%E5%B8%B8%E3%80%81%E6%97%A5%E5%BF%97%E5%92%8C%E8%B0%83%E8%AF%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java核心技术（卷一）（第十一章 异常、日志和调试） 个人笔记，如有错误，恳请批评指正。 11.1 异常 异常对象都派生于Throwable类。分为Error和Exception。 Error描述系统的内部错误和资源耗尽错误。 Exception又分为RuntimeException和其余的异常。 RuntimeException： 错误的类型转换 数组访问资源 访问空指针 其余的异常（如IoException）： 试图在文件尾部后面读取数据 试图打开一个不存在的文件 试图根据给定的字符串查找class对象，而这个字符串表示的类并不存在。 RuntimeException和Error称为未检查异常（unchecked），其余的是（checked异常）。编译器将核查是否为所有的已检查异常提供了异常处理器。 常见的RuntimeException12345678910NullPointerException - 空指针引用异常ClassCastException - 类型强制转换异常。IllegalArgumentException - 传递非法参数异常。ArithmeticException - 算术运算异常ArrayStoreException - 向数组中存放与声明类型不兼容对象异常IndexOutOfBoundsException - 下标越界异常NegativeArraySizeException - 创建一个大小为负数的数组错误异常NumberFormatException - 数字格式异常SecurityException - 安全异常UnsupportedOperationException - 不支持的操作异常 参考：http://blog.csdn.net/qq635785620/article/details/7781026 不需要声明Java的Error，因为是内部错误，我们对此没有控制能力。也不需要声明RuntimeException，因为我们完全可以在编码上解决。 一个方法必须声明所有可能抛出的已检查异常，而未检查异常要么不可控制（Error），要么就应该避免发生（RuntimeExcpetioon）。如果方法没有声明任何可能发生的可检查异常，编译器就会给出一个错误消息。 对异常的处理：抛出或者捕获。 子类覆盖超类的方法时，抛出的异常范围应该低于或者等于父类抛出的已检查异常。 在catch语句中可以再次抛出一个异常，这样做的目的是改变异常的类型。如throw new RuntimeException(e);是为了调用方法时候不需声明异常类型，改为运行时异常（不可查unchecked）。 在同一块中，throw之后的语句为unreachable语句。 当finally块中有return语句时，其返回的值将会覆盖原return值。 12345678910public static int f(int n)&#123; try &#123; int r = n * n; return r; &#125; finally&#123; if(n == 2) return 0; &#125; &#125; 带资源的try语句jdk1.7中，提供了改新特性。主要为了解决close资源是抛出的异常对try语句中的异常的覆盖问题。 123456try(Scanner in = new Scanner(new FileInputStream("d:\\haha.txt")); PrintWriter out = new PrintWriter("d:\\hehe.txt")) &#123; while(in.hasNext()) &#123; out.println(in.next().toUpperCase()); &#125; &#125; 使用异常机制的技巧： 异常机制不能代替简单的测试。如进行必要的判空测试从而避免产生空指针异常。 不要过分的细化异常，这种方式将会极大的增大代码量。 利用异常层次结构，寻找更加适合的子类异常或者自己创建异常。将一种异常转换另一种更加合适的异常时不要犹豫。 不要压制异常，代码中万万不能出现，catch中捕获了异常而不做任何处理的情况出现。这样会压制下异常，让异常逃脱编译器的检查。隐藏了异常，给整个程序留下了较大的隐患。 检查错误时，苛刻要比放任好。抛出EmptyStackException异常要比之后抛出NullPointerException要好。 不要羞于传递异常，让高层次的方法同志用户发生了错误，后者放弃不成功的命令更加适宜。后两条可以归纳为“早抛出、晚捕获”。 断言：预期的结果，不符合则会抛出异常。多用于测试阶段。 日志、调试 略ED ��果，不符合则会抛出异常。多用于测试阶段。 日志、调试 略ED]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java核心技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>核心技术</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java核心技术（卷一）（第十四章 线程）]]></title>
    <url>%2F2019%2F02%2F14%2FJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%88%E5%8D%B7%E4%B8%80%EF%BC%89%EF%BC%88%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%20%E7%BA%BF%E7%A8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java核心技术（卷一）（第十四章 线程） 个人笔记，如有错误，恳请批评指正。 并发执行的进程数并不是由CPU数目制约的，操作系统将CPU的时间片分配给每一个进程，给人以并行处理的感觉。 多线程和多进程的区别：每个进程都拥有一整套自己的变量，而线程则共享数据。然而，共享变量使线程之间的通信比进程之间的通信更有效、更容易。 14.1 实现线程的方式方式1、继承Thread方式2、实现Runnable接口，作为参数传递入Thread的构造函数。P627中提到： 继承的方式不再推荐，应该从运行机制上减少需要并行运行的任务数量，如果有很多的任务，要为每个任务创建一个独立的线程所付出的代价太大了。可以使用线程池解决这个问题。 继承的方法不再推荐，理由是Java是单继承、多实现的，况且，在多任务的情况下，每个任务对应一个线程，如果是继承的方式，需要创建多个对象，况且实现的对象不利于线程池。 14.2 中断线程当线程run方法中顺利执行完毕时，这个线程将会终止。在Java的早起版本中，有手动的stop()方法终止线程，但是现已被启用。具体原因是stop方法天生就不安全，该方法视图终止所有未结束的方法，包括run方法。当线程被终止时，立即释放锁对象，此时别的线程会有机会执行，这会导致操作对象的不一致。 没有可以强制终止线程的方法，但是interrupt()用来请求终止线程，当对某个线程使用该方法时，线程中的中断状态将会被置位，这是每个线程都具有的boolean状态。每个线程都应该不时的检查这个标志，以判断线程是否被终止。 检测是否处于中断状态，使用isInterrupted();对一个阻塞的进程（wait或sleep）的进程使用会抛出InterruptedException异常。 被中断的进程不一定会终止，某些进程很重要，处理完异常后继续执行不会终止。更普遍的情况是线程将简单的中断作为一个终止的请求。 interrupted和isInterrupted方法的区别：两者都可以查看当前进程的中断状态，后者不会改变当前进程的中断状态。 14.3 线程状态 新建状态(New)：当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 当一个线程处于新生状态时，程序还没有开始运行线程中的代码。 可运行线程（Runnable）：一个可运行状态线程可能正在运行也可能没有运行。运行与否取决于线程调度，线程调度的细节依赖于操作系统提供的服务，分为抢占式调度和协作式调度。抢占式调度给每个可运行线程一个时间片来运行，时间到，进程之间进行竞争，Java进程之间存在优先级的概念，优先级从1开始到10，依次升高。但是优先级在操作系统上存在映射，Windows只有7个优先级，Linux则不存在优先级。现在所有的桌面和服务器操作系统都采取抢占式调度；手机小型设备做协作式调度，在这样的设备中，进程只有采用yield、或者被阻塞、等待时才会失去控制权。 运行状态(Running)当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法. 阻塞状态(Blocked) 线程运行过程中，可能由于各种原因进入阻塞状态: 1. 线程通过调用sleep方法进入睡眠状态； 2. 线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者； 3. 线程试图得到一个锁，而该锁正被其他线程持有； 4. 线程在等待某个触发条件； ...... 所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。 死亡状态(Dead)有两个原因会导致线程死亡： 1. run方法正常退出而自然死亡， 2. 一个未捕获的异常终止了run方法而使线程猝死。 为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法。如果是可运行或被阻塞，这个方法返回true； 如果线程仍旧是new状态且不是可运行的， 或者线程死亡了，则返回false。 线程状态关系图如下： 14.4 线程属性属性包括：线程优先级、守护线程、线程组以及处理为捕获异常的处理器。 14.4.1 线程优先级priority，不要过度使用优先级。不同系统对优先级的支持不一样。APIstatic void yield():导致当前的进程做出让步，同优先级或以上的进程会被调度。 14.4.2 守护线程为其他线程服务的线程，t.setDaemon(true);守护线程不能访问固有资源，如文件、数据库，因为它可能在任何时候甚至在一个操作的中间发生中断。setDaemon方法必须在线程启动之前调用。 14.4.3 未捕获异常处理器待详细了解 14.5 同步多个线程同时操作同一资源，会产生竞争条件（race condition）。下面用一个银行转账的例程来演示线程安全问题： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/** * 银行对象 * @author Wch * */public class Bank &#123; private final int[] accounts; public Bank(int n,int initBalance) &#123; this.accounts = new int[n]; for(int i = 0;i&lt;n;i++) accounts[i] = initBalance; &#125; public void transfer(int from ,int to,int amount)&#123; if(amount&gt;accounts[from]) return; if(from == 0||to == 0 ) return; accounts[from-1] -= amount; System.out.printf("从账户%1$d转了%3$d元到账户%2$d",from,to,amount); accounts[to-1] += amount; System.out.printf("银行里的总钱数有%d元",getTotalBalance()); System.out.println(); &#125; private int getTotalBalance()&#123; int total = 0; for(int i = 0;i&lt;accounts.length;i++) total += accounts[i]; return total; &#125; public static void main(String[] args) &#123; Bank b = new Bank(100, 5000); b.transfer(1, 2, 200); &#125; public int size()&#123; return accounts.length; &#125;&#125;public class TransferRunnable implements Runnable&#123; private Bank bank; private int from; private int maxAmount; private int delay = 100; public TransferRunnable(Bank bank, int from, int maxAmount) &#123; super(); this.bank = bank; this.from = from; this.maxAmount = maxAmount; &#125; @Override public void run() &#123; while(true)&#123; try &#123; int amount = (int) (maxAmount*Math.random()); int to = (int) (bank.size()*Math.random()); bank.transfer(from, to, amount); Thread.sleep((long) (delay*Math.random())); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;&#125;public class TransferTest &#123; public static void main(String[] args) &#123; Bank b = new Bank(100, 5000); int i; for(i = 0;i&lt;100;i++)&#123; TransferRunnable t = new TransferRunnable(b, i, 100); Thread t2 = new Thread(t); t2.start(); &#125; &#125;&#125;运行结果：银行的总金额发生了混乱：从账户36转了72元到账户9银行里的总钱数有500032元银行里的总钱数有499863元从账户76转了51元到账户5银行里的总钱数有500032元从账户45转了3元到账户58银行里的总钱数有500032元从账户13转了57元到账户51银行里的总钱数有500032元从账户21转了45元到账户80银行里的总钱数有500032元从账户86转了34元到账户89银行里的总钱数有500032元从账户16转了57元到账户59银行里的总钱数有500032元从账户68转了91元到账户28银行里的总钱数有500032元从账户26转了34元到账户9银行里的总钱数有500019元从账户52转了13元到账户93银行里的总钱数有500032元从账户78转了9元到账户17银行里的总钱数有499967元从账户85转了65元到账户90银行里的总钱数有500032元从账户12转了1元到账户54银行里的总钱数有499924元从账户89转了90元到账户40银行里的总钱数有500014元从账户66转了18元到账户23银行里的总钱数有500032元从账户18转了16元到账户19银行里的总钱数有499931元从账户43转了11元到账户60银行里的总钱数有499942元从账户39转了43元到账户52银行里的总钱数有499985元从账户67转了47元到账户83银行里的总钱数有500032元从账户81转了69元到账户12银行里的总钱数有499937元从账户47转了95元到账户89银行里的总钱数有500032元 原因：transfer操作非原子操作，执行到任何一步都可能被剥夺运行权。 线程问题的解决办法14.5.3 锁对象显式锁对象 ReentrantLock类，存在于java.util.concurrent框架中。 1234567891011121314151617181920private ReentrantLock lock = new ReentrantLock();//显示锁对象......java public void transfer(int from ,int to,int amount)&#123; lock.lock();//锁住 try &#123; if(amount&gt;accounts[from]) return; if(from == 0||to == 0 ) return; accounts[from-1] -= amount; System.out.printf("从账户%1$d转了%3$d元到账户%2$d",from,to,amount); accounts[to-1] += amount; System.out.printf("银行里的总钱数有%d元",getTotalBalance()); System.out.println(); &#125; finally&#123; lock.unlock();//解锁，必须保证会执行，否则程序会挂起 &#125; &#125; 注意：如果使用了锁，就不能使用带资源的try语句，关于带资源的trry语句详解见：http://blog.csdn.net/u012421846/article/details/46129237 当线程访问同一对象（此处是bank）中的锁对象时，锁以串行的方式提供服务。如果访问不同对象的锁对象，不会发生阻塞。 锁是可重入的，线程可以重复获取已经持有的锁。所保持有一个持有计数（hold count）getHoldCount()来跟踪对lock方法的嵌套调用。线程在每一次调用lock都要调用unlock来释放锁，由于这一特性，被一个锁保护的代码可以调用另一个使用相同锁的方法。 警告：临界区中的代码不能因为异常的抛出提前退出临界区，如果这样，finally会提前释放锁，而不完整的修改会使对象处于一种受损状态。以下的代码说明了这种情况： 12345678910111213141516171819202122232425262728293031323334353637public void transfer(int from ,int to,int amount)&#123; lock.lock();//锁住 try &#123; if(amount&gt;accounts[from]) return; if(from == 0||to == 0 ) return; accounts[from-1] -= amount; System.out.printf("从账户%1$d转了%3$d元到账户%2$d",from,to,amount); System.out.println(1/(int)(Math.random()*10));//临界区的代码不能因为异常提前退出，否则会对对象有损 accounts[to-1] += amount; System.out.println("持有计数"+lock.getHoldCount()); System.out.printf("银行里的总钱数有%d元",getTotalBalance()); System.out.println(); &#125; catch (Exception e) &#123; e.printStackTrace();//捕获的是java.lang.ArithmeticException: / by zero &#125; finally&#123; lock.unlock();//解锁，必须保证会执行，否则程序会挂起 &#125; &#125;运行结果：//出错就会使bank对象受损！ 从账户18转了40元到账户460 持有计数1 transfer中的持有计数2 银行里的总钱数有500000元 从账户19转了65元到账户14java.lang.ArithmeticException: / by zero at cn.ustb.chapter14.bank.Bank.transfer(Bank.java:31) at cn.ustb.chapter14.bank.TransferRunnable.run(TransferRunnable.java:27) at java.lang.Thread.run(Thread.java:744) 从账户20转了80元到账户610 持有计数1 transfer中的持有计数2 银行里的总钱数有499935元 API lock() unLock() ReentrantLock() ReentrantLock(boolean fair)//是否启用带有公平策略的锁，这将大大降低性能，并且也不能保证线程调度器是公平的。 14.5.4 条件对象当进入临界区以后又发现某些条件不能满足执行条件时，用到条件对象。Condition condition = lock.newCondition()获取条件对象。当不满足执行条件时，使用condition.await();放弃当前锁，这时候其他线程可以对对象进行操作，当之前进程再次满足执行条件时且另外的进程调用了signalAll()方法时，改线程被激活。原来，原线程在condition.await()之后进入了该条件的等待集，在别的进程中condition.signalAll()之后，重新激活了因为这一条件而等待的所有线程。这些进程再次成为可运行的，调度器再次激活他们，获取锁对象的进程从被阻塞的地方重新执行，此时应该重新检测是否满足条件，signalAll仅仅是通知正在等待的线程：此时可能已经满足了执行条件。 通常，对await的调用应该在如下的循环体中：12while(!(ok to process)) condition.await(); 如果一个线程始终没有被signal，它将始终处于阻塞。条件对象可能会引起死锁，调用signalAll的时机是：在对象的状态有利于等待线程的方向改变时调用signalAll()。 14.5.5 synchronized关键字一种嵌入到Java语言内部的机制，从1.0开始，Java中的每一个对象都有一个内部锁，如果一个方法用synchronized关键字声明可对方法和代码块进行同步。 12345678910111213141516171819202122232425public synchronized void transfer(int from ,int to,int amount)&#123;&#125;orsynchronized (this) &#123; if (amount &gt; accounts[from]) return; if (from == 0 || to == 0) return; while (accounts[from] &lt; 1000) &#123; System.out.printf("账户%d余额不足1000，等待充值", from); System.out.println(); try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; accounts[from - 1] -= amount; System.out.print(Thread.currentThread()); System.out.printf("从账户%1$d转了%3$d元到账户%2$d", from, to, amount); accounts[to - 1] += amount; System.out.printf("银行里的总钱数有%d元", getTotalBalance()); System.out.println(); notifyAll(); &#125; 使用synchronized比显式锁和条件来同步的方式要简洁很多，每一个对象都有一个内部锁，并且该内部锁有一个内部条件。由锁管理试图进入synchronized方法的线程，由条件来管理那些调用wait的线程。 wait、notifyAll以及notify方法是Object中的final方法。只可以在一个同步方法或者同步代码块中调用，如果当前的线程不是对象锁的持有者，改方法都会抛出IllegalMonitorStateException的异常。 14.5.8 Volatile域现代的处理器与编译器中： 多处理器的计算机能够暂时在寄存器或本地缓存中保存内存中值，导致的结果是：不同处理器的线程可能在同一内存位置取到不同的值。 编译器可以改变指令的顺序使吞吐量最大化。这也会导致错误的发生。 锁的机制是让编译器在必要的时候刷新本地缓存来保持锁定的效应，并且不能不正当的重新排序指令。 volatile关键字为实例域的同步访问提供了一种免锁机制，如果声明为volitale，编译器和虚拟机默认该域可能被另一个进程并发更新的。 12345678public class Bank &#123; private volatile int[] accounts;//用volitale声明了account数组，然而并没有什么卵用，原因是transfer对其进行了非原子性操作，破坏了对象的状态。 public Bank(int n, int initBalance) &#123;&#125; public void transfer(int from, int to, int amount) &#123;&#125; private int getTotalBalance() &#123;&#125;&#125; 警告：Volatile变量不能提供原子性，其仅适合于get or set操作，不适合getAndOperate操作。 Volitale在执行时插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。内存屏障另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。更详细的解析见：http://blog.csdn.net/hupitao/article/details/45227891 final变量、原子性、死锁final用于声明安全访问的共享域。原子性指java.util.concurrent.atomic框架中一些高级指令，他们将一些简单的自增自减变为原子操作。死锁，线程之间的相互等待、或者互不相让的一种状态。 14.5.12 线程局部变量在线程之间共享变量有风险，有时候需要避免共享变量，这是就用到了局部变量。Java中使用ThreadLocal辅助类为各个线程提供各自的实例，不会因为线程导致安全问题。 12345678910111213141516public class Demo2 &#123; public static void main(String[] args) &#123; ThreadLocal&lt;SimpleDateFormat&gt; dateFormat = new ThreadLocal&lt;SimpleDateFormat&gt;()&#123; @Override protected SimpleDateFormat initialValue() &#123; System.out .println("Demo2.main(...).new ThreadLocal() &#123;...&#125;.initialValue()"); return new SimpleDateFormat("yyyy-MM-dd"); &#125; &#125;; SimpleDateFormat simpleDateFormat = dateFormat.get();//get获取线程局部变量对象，线程安全的 SimpleDateFormat simpleDateFormat2 = dateFormat.get(); System.out.println(simpleDateFormat); System.out.println(simpleDateFormat2); &#125;&#125; 可以在initialValue方法初始化局部变量。在一个给定线程首次调用get方法时，会调用initialValue方法，值调用一次，此后返回的都是同一个线程局部变量，此变量是线程安全的。 14.5.14 读写锁java.uitl.concurrent.locks中定义的ReentrantReadWriteLock类，适用于线程很少修改数据。API123private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();private Lock readLock = rwl.readLock();//得到一个可以被多个读操作公用的读锁，但会排斥所有的写操作。private Lock writeLock = rwl.writeLock();//得到一个写锁，排斥所有其他的读操作和写操作。 关于printf的用法：http://heidian.iteye.com/blog/404632]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java核心技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>核心技术</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java核心技术（卷一）（第十三章 集合）]]></title>
    <url>%2F2019%2F02%2F14%2FJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%88%E5%8D%B7%E4%B8%80%EF%BC%89%EF%BC%88%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E9%9B%86%E5%90%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java核心技术（卷一）（第十三章 集合） 个人笔记，如有错误，恳请批评指正。 Java中的队列队列通常由两种实现方式：一种是使用循环数组，另一种是使用链表。在Java中，如果需要使用一个循环数组队列，就可以使用ArrayDeque。如果需要使用一个链表队列，就直接使用LInkedList这个类实现了Queue接口。 循环数组要比链表的效率更高，然而，循环数组是一个有界集合，即容量有限，如果程序中要手机的对象数量没有上限，就最好使用链表来实现。 API中的AbstractQueue是为了让用户更好地实现自己的队列类设计的，实现之比实现Queue更好。 13.1.2 Java类库中的集合接口和迭代器接口增强for循环，底层利用了Iterator。因此，增强for循环可以在任何实现了Iterable接口的对象一起工作，Iterable接口只包含一个方法： 123public interface Iterable&#123; Iterator&lt;E&gt; iterator();&#125; Collection接口中扩展了此接口，因此，对任何标准类库中的任何集合都可以使用增强for循环。 Iterator中的remove方法next方法和remove方法具有相互依赖型，调用remove之前没有调用next是不合法的。 remove是指删除最后遍历的元素123456it.next();it.remove();//OKit.next();it.remove();it.remove();//IllegalStateException 集合中也是值传递123456789101112131415public class Demo4 &#123; public static void main(String[] args) &#123; List&lt;Emp&gt; l = new ArrayList&lt;&gt;(); l.add(new Emp("origin name",110)); Emp emp = l.get(0); emp.setName("new Name"); System.out.println(l.get(0).getName());//origin or new ?new Name 。说明集合中也是值传递，传的是存储的内存地址，引用的同一对象，可以改变状态。 l.add(new Emp("second name",110)); Emp emp2 = l.get(1); emp2 = new Emp("new Object",220); System.out.println(l.get(1).getName());//second name or new Object?second name!不能指向 新的对象，即不能改变引用 &#125;&#125; Java库中的具体集合核心技术卷一P568 集合类型 描述 ArrayList 一种可以动态增长和缩减的索引序列 LinkedList 一种可以在任何位置进行高效插入和删除操作的有序序列 ArrayDeque 一种用循环数组实现的双端队列 HashSet 一种没有重复元素的无序集合 TreeSet 一种有序集合 EnumSet 一种包含枚举类型值的集合 PriorityQueue 一种允许高效删除最小元素的集合 LinkedHashSet 一种可以记住元素插入次序的集合 HashMap 一种存储键值关联的数据结构 TreeMap 一种键值有序排列的映射表 13.2.1 链表链表是一个有序集合（ordered collection），每个对象的位置都十分重要，LinkedList.add方法将对象添加到链表的尾部，由于迭代器是描述集合中位置的，因此这种依赖位置的add方法将由迭代器负责。只有对自然有序的集合使用迭代器添加元素才有实际意义，因此在Iterator中没有add，set；在ListIterator中才有。 12345678910111213141516public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); void remove();&#125;public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); boolean hasPrevious(); E previous(); int nextIndex(); int previousIndex(); void remove(); void set(E e); void add(E e);&#125; 与Collection.add不同，这个方法不返回boolean类型的值，它假定添加操作总会改变链表。 如果链表有n个元素，就有n+1个位置可以添加新元素。add方法只依赖于迭代器的位置，而remove方法依赖于迭代器的状态。 ListIterator.set方法用一个新元素取代调用next或previous方法返回的上一个元素。如果在next或previous上次调用之后列表结构被修改了，将抛出一个IllegalStateException异常。 LinkedList根本不适合做任何缓存信息的操作，换言之，LinkedList.get(Index)的操作是低效的。实际上，get方法还做了一点小优化，如果index&gt;size/2，则从尾部开始搜索。 13.2.2 动态数组列表vector是同步安全的，效率低下，这是ArrayList取代它的原因。在不需要同步的时候使用ArrayList。 13.2.3 散列表Hash tableHashSet的初始大小为16，装填因子是0.75。 注意：自己实现hashCode方法必须和equals方法兼容，即equals为true，hashCode必须相等。 12345678910111213141516171819202122public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable&#123; /** * The default initial capacity - MUST be a power of two. */ static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 /** * The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two &lt;= 1&lt;&lt;30. */ static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; /** * The load factor used when none specified in constructor. */ static final float DEFAULT_LOAD_FACTOR = 0.75f;&#125; HashSet API1234HashSet();//构造一个空散列表HashSet(Collection&lt;? extends E&gt; elements);//构造一个散列表，并将集合中的所有元素添加到此散列表中。HashSet(int initialCapacity);HashSet(int initialCapacity,float loadFactor);//指定初始大小和装填因子 equals()和hashCode()的定义必须兼容。equals默认比较的也是内存地址，而内存地址的获取与hashcode有关，所以改写equals的同时需要与hashCode兼容。 13.2.4 树集树集与散列集相比，更加有序，树集是一个有序集合（Sorted Collction），该有序是指插入元素具备的自然顺序，不是插入顺序。将一个元素添加到树集比添加到散列表中要慢，但是，与数组和链表相比还是快很多。由于是二叉树，呈现对数级的消耗。树集相对于散列表的优点是遍历时是有序遍历的。 与TreeSet一样，一个优先队列即可以保存实现了COmparable接口的对象，也可以保存在构造器中提供比较器的对象。 HashSet与TreeSet选择时，如果不需要对数据进行排序，就没必要选用TreeSet、 13.2.6 队列与双端队列ArrayDeque和LinkedList都实现了双端队列结构，并且在必要时候可以进行扩容。 13.2.7 优先级队列优先级队列（priority queue）中的元素可以按照任意的顺序插入，却总按照排序的顺序进行检索。采用的二叉堆（binary heap）的数据结构，堆是一个可以自我调整的二叉树，对树执行添加和删除操作，可以让最小的元素移动到根，而不必花费必要的时间进行排序。 123456789101112131415public class Demo5 &#123; public static void main(String[] args) &#123; PriorityQueue&lt;String&gt; s = new PriorityQueue&lt;String&gt;(); s.add("a"); s.add("c"); s.add("d"); s.add("b"); for (String string : s) &#123; System.out.println(string); &#125; while(!s.isEmpty()) System.out.println(s.remove()); &#125;&#125; PriorityQueue API 123PriorityQueue();PriorityQueue(int initialCapacity);PriorityQueue(int initialCapacity,Comparator&lt;? super E&gt; c);//构造一个优先队列，并用指定的比较器对元素进行排序。 13.2.8 映射表HashMap和TreeMap 类比于HashSet和TreeSet，TreeMap键有序，但是插入效率低于HashMap。 集合框架没有包括映射表，Map和Collection是一级。但是可以通过entrySet()获取映射表的视图，即Set&lt;Map.Entry&lt;K,V&gt;&gt;。 123Set&lt;K&gt; keySet();//返回的既不是HashSet也不是TreeSet，只是实现了Set接口的某个其他类的对象。里面封装着键值。Collection&lt;V&gt; values();//封装了valuesSet&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();//封装了内部类Entry，定义了getKey\getValue\setValue方法 java.util.Map.Entry&lt;K,V&gt;getKey\getValue\setValue Set与Collection接口是一样的，只是其方法的行为有着更加严谨的定义。因为键值不可重复 集的add方法拒绝添加重复的元素。 集的equals方法定义两个集相等的条件是元素相同，插入顺序不必要相同。 hashCode方法定义应该保证具有相同元素的集将会拥有相同的散列码。 12345678910111213141516171819202122232425262728public class Demo7 &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; l1 = new ArrayList&lt;Integer&gt;(); l1.add(1); l1.add(2); l1.add(3); List&lt;Integer&gt; l2 = new ArrayList&lt;Integer&gt;(); l2.add(1); l2.add(3); l2.add(2); System.out.println(l1.equals(l2));//false,对应位置元素相同 System.out.println(l1.hashCode()); System.out.println(l2.hashCode());//散列码不一样 Set&lt;Integer&gt; s1 = new HashSet&lt;&gt;(); s1.add(1); s1.add(2); s1.add(3); Set&lt;Integer&gt; s2 = new HashSet&lt;&gt;(); s2.add(1); s2.add(3); s2.add(2); System.out.println(s2.equals(s1));//true,元素相同，对应位置不一定相同，即对顺序没有要求 System.out.println(s1.hashCode()); System.out.println(s2.hashCode());//相同元素的set的散列码相同 &#125;&#125; 13.3 集合框架JDK1.4引入了RandomAccess标记接口，目的是用来判断集合是否支持高效的随机访问，ArrayList和Vector都实现了该接口。说明其get（index）方法访问数据是高效的。 Set接口与Collection接口是一样的，只是其方法的行为更加严谨。Set的add方法拒绝添加重复的元素，Set的equals方法定义两个Set相等的条件是所包含的元素相同但顺序不比要相同，Set的hashCode方法自然就要保证相等的Set其散列码值也一致。 12345678910111213public static void main(String[] args) &#123; Collection&lt;Integer&gt; c1 = new ArrayList&lt;&gt;(); Collection&lt;Integer&gt; c2 = new ArrayList&lt;&gt;(); Set&lt;Integer&gt; s1 = new HashSet&lt;&gt;(); Set&lt;Integer&gt; s2 = new HashSet&lt;&gt;(); c1.add(1);c1.add(2);c1.add(3);c2.add(2);c2.add(1);c2.add(3); s1.add(1);s1.add(3);s1.add(2);s1.add(4);s2.add(2);s2.add(1); s2.add(3);s2.add(4); System.out.println(c1.equals(c2));//false System.out.println(s1.equals(s2));//true &#125; 13.3.1 视图与包装器视图：保持对原集合的控制。只用来展示集合中的元素。 1、轻量级集包装器关于asList方法asList方法返回的对象不是ArrayList，而是一个视图对象，带有访问底层数组的get和set方法。任何改变数组的大小的所有方法（包括迭代器相关的add和remove方法）都会抛出Unsupported OperationException的异常。 视图是不可修改的，任何改变视图size的操作都会影响到原集合。抛出异常、 1234567public static void main(String[] args) &#123; Integer[] arr = &#123;2,1,5,4,6,8,9,6&#125;; List&lt;Integer&gt; intList = Arrays.asList(arr); Iterator&lt;Integer&gt; iterator = intList.iterator(); iterator.next(); iterator.remove();//java.lang.UnsupportedOperationException &#125; 源码：有新的ArrayList内部视图类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@SafeVarargs public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a); &#125; /** * @serial include */ private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable &#123; private static final long serialVersionUID = -2764017481108945198L; private final E[] a; ArrayList(E[] array) &#123; if (array==null) throw new NullPointerException(); a = array; &#125; public int size() &#123; return a.length; &#125; public Object[] toArray() &#123; return a.clone();//避免破坏封装性 &#125; public &lt;T&gt; T[] toArray(T[] a) &#123; int size = size(); if (a.length &lt; size) return Arrays.copyOf(this.a, size, (Class&lt;? extends T[]&gt;) a.getClass()); System.arraycopy(this.a, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; public E get(int index) &#123; return a[index]; &#125; public E set(int index, E element) &#123; E oldValue = a[index]; a[index] = element; return oldValue; &#125; public int indexOf(Object o) &#123; if (o==null) &#123; for (int i=0; i&lt;a.length; i++) if (a[i]==null) return i; &#125; else &#123; for (int i=0; i&lt;a.length; i++) if (o.equals(a[i])) return i; &#125; return -1; &#125; public boolean contains(Object o) &#123; return indexOf(o) != -1; &#125; &#125; 关于Collecitons.nCopies方法Collections.nCopies(n,anObject);返回一个实现了List接口的不可修改的对象。Collections.singleton(Object obj)返回一个视图对象，该对象实现了set接口。该方法的好处是返回的对象实现了一个不可修改的单元素集，而不需要付出建立数据结构的开销。singletonList和singletonMap方法类似。 子范围subList返回的包头不包尾的也是视图，这种是子范围视图，对该视图进行clear会影响到原集合。 subList返回的子范围的任何操作将会影响到整个列表中！例如：子列表中的clear操作将会使源列表的元素被清除。 不可修改的视图返回的视图对现有集合增加了一个运行时检查，当发现视图试图修改集合时，抛出异常。但是源集合可以自己对自己进行修改。 Collections的某些方法用于产生集合的不可修改视图（unmodifiable views）。 123456public static &lt;T&gt; Collection&lt;T&gt; unmodifiableCollection(Collection&lt;? extends T&gt; c) &#123;&#125;unmodifiableList();unmodifiableSet();unmodifiableSortedSet();unmodifiableMap();unmodifiableSortedMap(); 将传入的集合封装成一个不可修改的视图，如果发现视图修改，则抛出一个UnsupportOperation的异常，并且将集合保持为未修改的状态。 不可修改视图并不是集合本身不可修改，仍然可以通过集合的原始引用对集合进行修改。 由于视图只是包装了接口而不是实际的集合对象，所以只能访问接口中定义的方法，例如LinkedList类中的addFirst，不是List接口的方法，不能通过不可修改视图进行访问。 12345678910111213141516//源码public static &lt;T&gt; Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; s) &#123; return new UnmodifiableSet&lt;&gt;(s); &#125; /** * @serial include */ static class UnmodifiableSet&lt;E&gt; extends UnmodifiableCollection&lt;E&gt; implements Set&lt;E&gt;, Serializable &#123; private static final long serialVersionUID = -9215047833775013803L; UnmodifiableSet(Set&lt;? extends E&gt; s) &#123;super(s);&#125; public boolean equals(Object o) &#123;return o == this || c.equals(o);&#125; public int hashCode() &#123;return c.hashCode();&#125; &#125; 同步视图Java中，利用视图机制保证常规集合的线程安全，而不是实现线程安全的集合，Collections.synchronized***();方法可对任何集合装换成具有同步访问方法的集合。 检查视图包装一个具有检查类型机制的视图，对泛型类型发生问题时提供调试支持。Collections.checkedList();详见P602。 13.3.2 批操作指Set的removeAll、retainAll操作。对于Map，也可keySet().removeAll()。 13.3.3 集合与数组之间的转换 数组转集合：利用Arrays.adList的包装器。 123456public static void main(String[] args) &#123; String[] arr = &#123;"aaa","bbb"&#125;; List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(arr)); list.remove(0);//remove不会抛出UnsupportedOperationException的异常 System.out.println(list); &#125; 集合转数组：list.toArray(new String[]); 12345//集合转数组Object[] array = list.toArray();//String[] strArr = (String[]) array;//java.lang.ClassCastExceptionString[] strArr = list.toArray(new String[0]);//可指定大小和类型，不用强转 13.4 算法13.4.1 排序与混排Java中的Collections.sort()底层使用了数组的归并排序。即先转化集合为数组，排好序以后在复制回以前的集合。 归并排序相较于快速排序，速度慢，但是稳定，它不需要交换相同的元素。 排序传递的列表必须是可修改的，不必要是可改变大小的。 混排：Collections.shuffle(List);，随机的打乱列表中元素的顺序。//每次都不一样。 13.4.2 二分查找12public static &lt;T&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123;&#125;;public static &lt;T&gt; int binarySearch(List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; c) &#123;&#125;; 若查找的元素不存在返回的是负数i，不一定是-1！ 这是可以插入-i-1到列表中正确的位置。 另外，只有采取随机访问，二分查找才有意义，如果必须利用迭代一次次的遍历链表的一般元素来找到中间元素的位置，二分查找就失去了它的优势，因此，如果传入的是LinkedList链表，它将自动转换成线性查找。 13.5 遗留的集合13.5.1 Hashtable与HashMap的作用是一样的，但是Hashtable（并非HashTable）是线程同步的。如果同步性没有要求，应该尽量使用HashMap。 13.5.3 属性映射表属性映射表（property map）十一个类型非常特殊的映射表结构，其特性是： 键与值都是字符串。 表可以保存到一个文件中，也可以从文件中加载 使用一个默认的辅助表。 实现属性映射表的Java平台类称为Properties类。load、store方法。 13.5.4 栈Stack类，push、pop、peek]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java核心技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>核心技术</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java核心技术（卷一）（第十二章 泛型程序设计）]]></title>
    <url>%2F2019%2F02%2F14%2FJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%88%E5%8D%B7%E4%B8%80%EF%BC%89%EF%BC%88%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java核心技术（卷一）（第十二章 泛型程序设计） 个人笔记，如有错误，恳请批评指正。 泛型（generic）提供了一个更好的解决方案：类型参数（type parameters）。这使得代码具有更好的可读性和安全性。编译器可以很好的利用类型参数信息，不需要强制转换，编译器就知道具体的类型。 泛型类可以有多个类型变量T，用尖括号括起来，逗号隔开。 1public class Pair&lt;T,U&gt;&#123;...&#125; T：表示泛型。E：集合的元素类型。K、V：键值对。 泛型方法 123456789public class Demo1 &#123; public static &lt;T&gt; T getSomeThing(T... a)&#123; return a[a.length/2]; &#125; public static void main(String[] args) &#123; String a = "sss"; Demo1.&lt;String&gt;getSomeThing(a);//String可省略，编译器将自动识别出泛型的具体类型。 &#125;&#125; 泛型类型变量的限定： 1public static &lt;T extends Comparable&gt; T min(T[] arr)&#123;...&#125; Comparable是一个接口，为什么要使用extends？答：表示的是T是绑定类型的子类型（subtype），T和绑定类型可以是类也可以是接口。此外，一个类型变量可以有多个限定，例如：T extends Comparable&amp;Serializable,限定类型用&amp;分割，而逗号用来分割类型变量。此外，在Java的继承中，可以根据需要拥有多个接口超类型，但限定中至多有一个类，且该类必须位于限定列表中的第一个。即T extends Demo1&amp;Demo2是不对的。 12.5 泛型代码和虚拟机虚拟机中没有泛型类型对象—-所有对象都属于普通类。原因是经过编译器的擦除，生成了原始的字节码文件。擦除后的原始类型用第一个限定的类型变量来替换，如果没有给定限定就用Object来替换。详细参考：http://blog.csdn.net/ysjian_pingcx/article/details/40072247 记住一点，虚拟机中没有泛型，只有普通的类。 所有泛型的类型参数都用它们限定的类型代替，没有限定则用Object。 为了保持类型安全性，虚拟机在有必要时插入强制类型转换。 桥方法的合成用来保持多态性。 协变类型允许子类覆盖方法后返回一个更严格的类型。 12.6 约束和局限性 不能用基本类型实例化类型参数具体原因是：类型擦除以后，原始类型若为Object，Object去不能存储基本类型的数据。 运行时类型查询只适用于原始类型，即getClass方法总是返回原始类型。比如instanceof、getClass()、强制类型转换，a instanceof (Pair),在类型擦除后便是 a instanceof Pair,因此以上运行的一些操作在虚拟机中操作都是对原始类型进行操作，无论写的多么虚幻，都逃不出类型擦除，因为在虚拟机种并不存在泛型。 不能创建参数化类型的数组。详见参考：http://www.cnblogs.com/fantasy01/p/3963593.html12GenericTest&lt;Integer&gt;[] a;//声明一个参数化类型数组是可以的GenericTest&lt;Integer&gt;[] b = new GenericTest&lt;Integer&gt;[10];//new 报 Error 如果需要收集参数化类型对象，只有一种安全 而有效的方法，即使用集合。 不能实例化类型变量，即不能出现以下代码： 123T t = new T();//或T.Class 因为在类型擦除后，便是Object t = new Object();与用意不符合，即本意肯定不是要调用Object。 不能在静态域或方法中引用类型变量以下代码错误：12345678class Test&lt;T&gt;&#123; private static T example; //error public static T showExample() //error &#123; action about T.... &#125;&#125; 首先方法是一个返回类型为T的普通方法，而非泛型方法，这和在静态方法中使用非静态参数是一样的，静态方法是先于对象而存在内存中的，因此在编译的时候，T的类型无法确定，一定会出现“Cannot make a static reference to a non_static reference”这样类似的错误。但是这样的代码就是正确的： 123456class Test&lt;T&gt;&#123;public static &lt;T&gt; T show() &#123; action &#125;&#125; 因为此处的静态方法是泛型方法，可以使用。 不能抛出或捕获泛型类的实例既不能抛出也不能捕获泛型类对象。实际上，泛型类不能扩展Throwable，注意是类不能继承Throwable，类型参数的限定还是可以的。catch子句不能使用类型变量，如下代码 12345678try&#123; ....&#125;catch(T e) //error&#123; ...&#125; 注意擦除后的冲突 1234567class Pair&lt;T&gt;&#123; public boolean equals(T value) //error &#123; .... &#125;&#125; 此处的错误的原因不能存在同一个方法，在类型擦除后，Pair的方法为，public boolean equals(Object value),这与从Object.class中继承下来的equals(Object obj)冲突。 一个类不能同时成为两个接口类型的子类，而这两个接口是同一接口的不同参数化。其原因是与合成的桥方法产生冲突。 12class Calendar implements Comparable&lt;Calender&gt;&#123;...&#125;class GregorianCalendar extends Calendar implements Comparable&lt;GregorianCalendar&gt;&#123;...&#125; 12.7 泛型类型的继承规则 通常GenericClass和GenericClass没有什么联系，更不存在子类关系。 泛型类可以拓展或实现其他的泛型类。如ArrayList实现了List接口。 12.8 通配符类型12class GenericClass&lt;? extends Employee&gt;&#123;...&#125;//带有子类型限定的通配符class GenericClass&lt;? super Manager&gt;&#123;...&#125;//带有超类型限定的通配符 Comparable接口本身就是一个泛型类型。其CompareTo方法的显式参数为T类型； 123public interface Comparable&lt;T&gt; &#123; public int compareTo(T o);&#125; 无限定通配符：class GenericClass&lt;?&gt;{...} 12.9 反射和泛型Class类是泛型的，String.getClass实际上是一个Class&lt;String&gt;类的对象。Class类中的方法： 12345678T newInstance();//newInstance返回一个实例，这个实例所属的类由默认的构造器获得，返回的类型目前被声明为T，其类型与Class&lt;T&gt;描述的类相同，这样就免除了类型转换。T cast(Object obj);//如果给定了类型确实是T的一个子类型，cast方法就会返回一个现在声明为类型T的对象，否则，抛出一个BadCastException的异常。T[] getEnumConstants();Class&lt;? super T&gt; getSuperClass();Constructor&lt;T&gt; getConstructor(Class... parameterTypes);Constructor&lt;T&gt; getDeclaredConstructor(Class... parameterTypes); 使用Class&lt;T&gt; 参数进行类型匹配 123456public static &lt;T&gt; GenericTest&lt;T&gt; returnGeneric(Class&lt;T&gt; c1)&#123; return new GenericTest&lt;T&gt;();&#125;public static void main(String[] args) &#123; GenericTest&lt;Integer&gt; returnGeneric = returnGeneric(Integer.class);&#125; Integer.class是Class&lt;Integer&gt;的一个对象，编译器能够判断出这个方法将要返回一个GenericClass&lt;Integer&gt;的对象。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java核心技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>核心技术</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java核心技术（卷一）（第六章 接口与内部类）]]></title>
    <url>%2F2019%2F02%2F14%2FJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%88%E5%8D%B7%E4%B8%80%EF%BC%89%EF%BC%88%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java核心技术（卷一）（第六章 接口与内部类）接口、内部类、对象克隆、代理、接口与回调个人笔记，如有错误，恳请批评指正。 6.1 接口 接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式定义。 接口中所有的方法自动属于public，不必特殊声明。 在接口中还可以定义常量，也可以定义变量。但是不能有实例域，也不能在接口中实现方法。可以将接口看成是没有实例域的抽象类，但是两者还是有一定区别的。 语言标准规定：compareTo方法中，如果调换了参数，结果的符号也需要调换。 可以使用instanceof检查一个对象是否实现了某个特定的接口。 接口可以用作拓展，即interface1 extends interface2； 虽然接口中不能包含实例域或静态方法，但却可以定义常量，与接口中的方法都自动设置成public一样，接口中的域将被自动设置成public static final； 有些接口只定义了常量，却没有定义方法，实现该接口的类自动继承了这些常量。 6.1.2 接口与抽象类 接口和抽象类是两个不同的概念，尽管两者有很多相似性。使用抽象类表示通用属性存在这样一个问题，Java只提供单继承，如果需要拓展别的类就不行了。而可以通过多实现来实现多个接口。 6.2 对象克隆 当拷贝一个对象时，拷贝对象与原对象引用同一个对象，任一改变将对另一方产生影响。要实现各自互不影响，可以用clone。 浅克隆的步骤：被克隆的类实现Cloneable接口，并重写clone方法，改protected为public。protected访问权限：同包或子类访问，但是，不能在一个子类中访问另一个子类的protected方法，尽管这两个子类继承自同一父类。浅克隆不会克隆对象中的对象，也不会调用构造方法。 Cloneable接口的出现与接口的正常使用没有任何关系。Cloneable只是一个标记接口，并没有任何方法。clone方法继承自Object。如果一个对象需要clone，但没有实现cloneable接口，就会出现一个已检查异常（cheched exception）。 引用：http://www.cnblogs.com/Qian123/p/5710533.html 关于String为什么是不变的？引用http://blog.csdn.net/renfufei/article/details/16808775 字符串常量池的需要。字符串常量池(String pool, String intern pool, String保留池) 是Java堆内存中一个特殊的存储区域, 当创建一个String对象时,假如此字符串值已经存在于常量池中,则不会创建一个新的对象,而是引用已经存在的对象。假若字符串对象允许改变,那么将会导致各种逻辑错误,比如改变一个对象会影响到另一个独立对象. 严格来说，这种常量池的思想,是一种优化手段。 允许String缓存hashCode 安全性 6.3 接口与回调 回调（callback）是一种常见的程序设计模式，在这种模式中，可以指出某个特定事件发生时应采取的动作。 java.swing包中有一个Timer类，可以使用它在到达给定的时间间隔时发出通告，传入(delay,actionListener)。 6.4 内部类 内部类（inner class）的优势： 内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据。 内部类可以对同一个包中的其他类隐藏起来。 当想要编写一个回调函数且不想编写大量代码时，使用匿名（anonymous）内部类比较便捷。 内部类的访问方式： 在外部类提供一个方法创建内部类的对象进行访问。 直接创建内部类的对象，其格式如下： 外部类.内部类 变量名 = new 外部类（）.new 内部类（）； 1OuterClass.InnerClass oi = new OuterClass().new InnerClass(); 注意：因为外部类的作用就是为了访问外部类的成员变量，所以必须要有外部类的对象才能生成内部类的对象。 内部类中的变量访问形式： 内部类在没有同名成员变量和局部变量的情况下，则直接访问外部类的变量。 若有同名，访问内部类本身的成员变量可以使用this，也可以直接访问。 若有同名，访问外部类的成员变量需使用OutClassName.this.属性名。 静态内部类：成员变量中一旦出现静态成员，该类也必须用static修饰。此时创建对象的格式是：外部类.内部类 变量名 = new 外部类.内部类（）； 1OuterClass.InnerClass oi = new OuterClass.InnerClass(); 注意：Out.In可以作为一个整体通过类名访问static，生不生成外部类对象都没关系。 私有内部类：若有一个内部类只希望被外部类访问，则可通过private修饰。相当于外部类的一个私有的成员变量。 局部内部类：在一个类的方法内部定义一个类。局部内部类只能在所在方法的内部通过创建访问，方法以外不知道他的存在。局部类不能用public或private访问说明符声明，它的作用域被限定在声明这个局部类的块中。可在局部内部类直接访问方法外的变量（方法外的变量为全局变量，其生命周期和方法以及局部内部类一样长）在方法内，内部类外的局部变量须加final才能在内部类中访问（因其：局部变量生命周期短，加final访问其复制品（不可修改）） 匿名内部类（anonymous inner class） 匿名内部类可以实现一个接口，或者直接拓展一个类。 关于final关键字final关键字可以应用于局部变量、实例变量和静态变量。在所有的这些情况下，他们的含义都是：在创建这个变量之后，只能够为之赋值一次，此后再也不能修改他们的值。 关于内部类的编译过程内部类是一种编译器现象，与虚拟机无关。编译器将会把内部类翻译成用$分隔外部类名与内部类名的常规类文件，而虚拟机对此却一无所知。嵌套类分静态和非静态，非静态嵌套类称为内部类。 6.5 代理代理类可以在运行时创建全新的类，这样的代理类能够实现指定的接口。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java核心技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>核心技术</tag>
        <tag>接口</tag>
        <tag>内部类</tag>
        <tag>克隆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程实战（1-5）]]></title>
    <url>%2F2019%2F02%2F14%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%EF%BC%881-5%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java并发编程实战（1-5） 个人笔记，如有错误，恳请批评指正。 chapter 2 线程安全性2.1 什么是线程安全 线程安全性的定义：当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。在线程安全类的对象实例上执行的任何串行或并行操作都不会使对象处于无效状态。 无状态对象一定是线程安全的，比如说大部分的Servlet，它们即不包含任何域，也不包含任何对其他类中域的引用，计算过程中的临时状态仅存在于线程方法栈帧上的局部变量中，并且只能由正在执行的线程访问。 2.2 原子性2.2.1 竞态条件竞态条件的本质：基于一种可能失效的观察结果做判断或者执行某个计算。 2.3 加锁机制2.3.1 内置锁静态的synchronized方法以Class对象作为锁。 每个Java对象（this、Lock、…）都可以作为一个实现同步的锁，这些锁被称为内置锁或监视器锁。Java的内置锁相当于一种互斥锁，最多只有一个线程能持有这种锁。 123456789sychronized(this)&#123; //code here&#125;public synchronized void method()&#123; //code here&#125;public synchronized static void method()&#123; //code here&#125; 2.3.2 重入内置锁是可重入的，JVM维护了每个锁的持有者和计数值，已经持有锁的线程可以再次获取这个锁，此时计数值加1，如果计数值为0，说明此时该锁没有被线程持有。 2.5 活跃性和性能尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去，从而在这些操作的执行过程中，其他线程可以访问共享状态。 简单性和并发性需要平衡，获取和释放锁等操作上都需要一定的开销，因此过于细粒度的同步代码块会影响效率。 当执行较长的计算或者无法快速完成的操作时，一定不要持有锁。 chapter 3 对象的共享3.1 可见性同步：一个线程改变的状态应该对其他的线程可见，并且保证按照程序的顺序执行而不会被重排序。 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得到正确的结论。 3.1.1 失效数据一个线程读取到另一个线程修改之前的数据，这种数据称为失效数据，失效数据出现的原因是没有足够的同步机制。可以通过synchronized同步代码块进行同步。 3.2.1 非原子的64位操作最低安全性（out-of-thin-air-safety），只失效数据只可能是修改之前的值，而不会是某个随机值。对32位数据，其是适用的。 JVM允许将64位数据（long和double）的读操作和写操作分解为两个32位的操作，因此如果同步不够，可能只会读取到前32位或者后32位的数据。因此需要对其用关键字volatile或者用锁保护起来。 3.1.3 加锁和可见性假设线程A获取到了锁并对变量进行操作，在A释放锁之前，该变量对线程B同样具有可见性。因此，在访问某个共享且可变的变量时要求所有的线程在同一个锁上同步。 加锁的含义不仅仅局限在互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上进行同步。 3.1.4 volatile变量volatile变量时一种比synchronized关键字更轻量级的同步机制。但是不要过度依赖该关键字。 volatile的正确使用方式：确保它们自身状态的可见性，确保它们所引用对象的可见性，以及标识一些重要的程序生命周期事件的发生。（例如：初始化或关闭） 数绵羊的例程：12345678910111213141516171819202122public class Demo2 &#123; private static boolean asleep = false;//如果不添加volatile，主线程的修改将不可见，数绵羊线程将会死循环下去、 //private static volatile boolean asleep = false; //数绵羊线程 public static class CountSheeps extends Thread&#123; @Override public void run() &#123; while(!asleep)&#123; count(); &#125; &#125; public void count()&#123;&#125; &#125; //主线程 public static void main(String[] args) throws Exception &#123; new CountSheeps().start(); Thread.sleep(10); asleep = true;//主线程对asleep的状态进行修改，如果没有volatile，数绵羊线程不可见该状态，将会导致死循环。 &#125;&#125; 值得注意的是：volatile关键字只是保证了变量的可见性，并不保证原子性。例如：多个线程对volatile int i的自增操作将会出现线程安全问题。只有加锁机制既保证了原子性还保证了可见性。 因此，只有对变量的写操作不依赖变量的当前值时，才应该使用volatile，否则其他情况下加锁机制更加合适。 3.2 发布与逸出封装的目的：防止引用逸出。 外部方法：一个方法，不完全由A类来规定（包括其他类的定义方法、A类中可被改写的方法（既不是private也不是final））。当把一个对象传递给外部方法时，该对象就已经被逸出了。这可能会破坏封装性。如： 123456789public class Demo3 &#123; private Class1 field;//要封装的对象 public Class1 getField() &#123; return field;//破坏了封装性，引用逸出了。 &#125; public class Class1&#123;&#125;&#125; 3.3 线程封闭不在线程之间共享数据，只在单线程内访问数据，不需要同步。典型的例子是：JDBC中的Connection对象。 3.3.2 栈封闭栈封闭中，只有使用局部变量才能访问对象。即方法中的局部变量若为基本类型时，永远不会逸出；在维持对象引用的栈封闭性时，发布该对象将会破坏封闭性导致对象逸出。 3.3.3 ThreadLocal类维持线程封闭类的一种更规范的方法是使用ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来。例如：通过将JDBC的连接保存到ThreadLocal对象中，每个线程都会拥有属于自己的连接。 Thinking in Java 和Java Core中都有说明，记得复习一下。 ThreadLocal API T get() 返回此线程局部变量的当前线程副本中的值。 protected T initialValue() 返回此线程局部变量的当前线程的“初始值”。 void remove() 移除此线程局部变量当前线程的值。 void set(T value) 将此线程局部变量的当前线程副本中的值设置为指定值。 1234567891011121314151617181920212223import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;public class Demo4 &#123; private static String DB_URL = ""; private static ThreadLocal&lt;Connection&gt; connectionHolder = new ThreadLocal&lt;Connection&gt;() &#123; protected Connection initialValue() &#123; Connection connection = null; try &#123; connection = DriverManager.getConnection(DB_URL); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return connection; &#125;; &#125;; public static Connection getConnection()&#123; return connectionHolder.get(); &#125;&#125; 3.4 不变性不可变对象，只有一种状态，并且该状态由构造函数来控制。 不可变的对象一定是线程安全的。当满足下列条件时，对象才是不可变的：即不可变性的所有需求： 对象创建之后其状态就不能修改了。 对象的所有域都是final型的。 对象都是正确创建的（在对象创建期间，this引用没有逸出）。 不可变的对象内部仍然可以使用可变对象来管理他们的状态。 将不可变的域声明为一个final域是良好的编程习惯。 在某些情况下，可以通过不可变对象实现一种弱形式的原子性，因为不可变对象的状态是不可变的，防止了其他线程的修改。在配以volatile，保持该不可变对象的可见性，可以使得volatile Unchangable object = new Unchangable()在没有显式的使用锁的情况下仍然是线程安全的。 任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。其final类型的域可以安全的访问， 3.5 安全发布3.5.3 安全发布的常用模式要安全的发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见，一个正确构造的对象可以通过以下方式安全地发布： 在静态初始化函数中初始化一个对象引用。 将对象的引用保存到volatile类型的域或者AtomicReference对象中。（volatile、AtomicReference） 将对象的引用保存到某个正确构造对象的final类型域中。 将对象的引用保存到一个由锁保护的域中。（Collections.synchronizedMap…） 3.5.4 事实不可变对象事实不可变对象：一个对象从技术上是可以改变的，但其状态在发布之后不会再改变。这些对象不需要严格满足不变性的所有需求。在没有额外的同步的情况下，任何线程都可以安全的使用被安全发布的事实不可变对象。 例如：Date本身是可变的，但如果将其作为不可变对象使用，多个线程之间共享Date对象时，可以省去对锁的使用，从而提高性能。 1public Map&lt;String,Date&gt; lastLogin = Collections.synchronizedMap(new HashMap&lt;String,Date&gt;); 如果Date对象在被放入Map之后就不会改变，那么synchronizedMap中的同步机制就足够使Date值被安全地发布，并且在访问这些Date值时不需要额外的同步。 3.5.5 可变对象可变对象：不仅在发布时需要使用同步，而且在每次访问时都需要使用同步，因为其状态可能改变。 对象的发布需求取决于它的可变性： 不可变对象可以通过任意机制来发布。 事实不可变对象必须通过安全方式来发布。 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。 在并发程序中使用和共享对象时，可以使用一些使用的策略： 线程封闭：线程封闭的对象只能由一个线程拥有和修改，对象被封闭在该线程中。如：Connction池中的Connection对象。 只读共享：允许多个线程访问，但不允许修改。共享的只读对象包括不可变对象和事实不可变对象。 线程安全共享：线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口进行访问而不需要进一步的同步。如：Atomic类。 保护对象：被保护的对象只能通过持有特定的锁来访问。 Chapter 4 对象的组合同步策略：定义了如何在不违背对象不变条件或后验条件的情况下对其状态的访问操作进行协同。 4.1.2 依赖状态的操作如果某个操作中包含有基于状态的先验条件，那么这个操作就称为依赖状态的操作。 4.2 实例封闭通过将封闭机制与合适的加锁策略结合起来，可以确保以线程安全的方式来使用非线程安全的对象。实例封闭：线程独占对象。 Collections.synchronizedList();通过装饰者模式将一个线程不安全的类装换为一个线程安全的类。返回的是synchronized类中定义的内部类，所有的方法都是线程安全的，包装器对象拥有对底层容器对象（包装前的容器）的唯一引用。 ConcurrentHashMap，高并发的HashMap。参考：http://www.importnew.com/22007.htmlCollections.unmodifiedMap(new HashMap&lt;&gt;())；返回一个map的实时视图，不可修改。 4.3 线程安全性的组合大多数对象都是组合对象，如果各个组件已经是线程安全的，且组件之间不存在耦合，即不存在多的不变性条件，那么该对象不需要增加额外的线程安全层也是线程安全的。 如果一个类是由多个独立且线程安全的状态变量组成，并且在所有的操作中都不包含无效状态转换，那么可以将线程安全性委托给底层的状态变量。如果一个状态变量时线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全地发布这个变量。 Chapter 5 基础构建模块5.1 同步容器Vector、HashTable同步容器都是线程安全的，但是某些情况下需要额外加锁来保护复合操作。 ConcurrentModicationException是一种“及时失败”的提醒机制，是一种设计上的平衡。降低了需要在迭代 时整块加锁带来的性能上的影响。 5.2 并发容器Java 5.0中添加了ConcurrentHashMap用来替代HashMap和CopyOnWriteArrayList用于遍历操作为主要操作的情况下代替同步容器List。 通过并发容器来替代同步容器，可以极大地提高伸缩性并降低风险。 ConcurrentMap接口中添加了：“若没有则添加”、“若相等则移除”、“若相等则替换” 12345678910public interface ConcurrentMap&lt;K,V&gt; extends Map&lt;K,V&gt;&#123; //没有则添加 V putIfAbsent(K key,V value); //相等则移除（Remove-if-Equal） boolean remove(K key,V value); //相等则替换 boolean replace(K key,V value,V newValue); //相等则替换 V replace(K key,V newValue);&#125; CopyOnWriteArrayList、CopyOnWriteSet：替代同步List、替代同步Set。读、写分离的思想。每当修改容器时都会复制底层数组，需要一定的开销，仅当迭代操作远远多于修改操作时，才应该使用CopyOnWrite容器。 5.3 阻塞队列和生产者-消费者模式 在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具：它们能抑制并防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。 5.5 同步工具类同步工具类可以是任何一个对象，只要它根据其自身的状态来协调状态的控制流。 5.5.1 闭锁P79 5.5.2 FutureTaskP80 5.5.3 信号量Semaphore对象，acquire()、release()。 5.5.4 栅栏第一部分小结 可变状态是至关重要的。所有的并发问题都可以归结为如何协调对并发状态的访问，可变状态越少，越容易确保线程的安全性。 尽量将域声明为final型的，除非需要他们是可变的。 不可变对象一定是线程安全的。不可变对象能极大地降低并发编程的复杂性。他们更为简单且安全，可以任意共享而无须使用加锁或保护性复制等机制。 封装有助于管理复杂性在编写线程的程序时，虽然可以将所有数据都保存在全局变量中，但为什么要这么做？将数据封装在对象中，更易于维持不变性条件；将同步机制封装在对象中，更易于遵循同步策略。 用锁来保护每个可变变量。 当保护同一个不变性条件中的所有变量时，要使用同一个锁。 在执行复合操作期间，要持有锁。 如果从多个线程中访问同一个可变变量时没有同步机制，那么程序会出现问题。 不要轻易的推断出对象是线程安全的从而不需要使用同步。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java并发编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图解HTTP（8、9、10） 身份的认证、基于HTTP的功能追加协议、构建Web内容的技术]]></title>
    <url>%2F2019%2F02%2F14%2F%E5%9B%BE%E8%A7%A3HTTP%EF%BC%888%E3%80%819%E3%80%8110%EF%BC%89%20%E7%A1%AE%E8%AE%A4%E8%AE%BF%E9%97%AE%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E7%9A%84%E8%AE%A4%E8%AF%81%E3%80%81%E5%9F%BA%E4%BA%8EHTTP%E7%9A%84%E5%8A%9F%E8%83%BD%E8%BF%BD%E5%8A%A0%E5%8D%8F%E8%AE%AE%E3%80%81%E6%9E%84%E5%BB%BAWeb%E5%86%85%E5%AE%B9%E7%9A%84%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[图解HTTP（8、9、10） 确认访问用户身份的认证、基于HTTP的功能追加协议、构建Web内容的技术 第八章 确认访问用户身份的认证HTTP认证的方式 BASIC认证（基本认证） DIGEST认证（摘要认证） SSL认证（客户端认证） FORMBASE（基于表单认证） 8.2 BASIC认证从HTTP/1.0开始。 BASIC虽然采用Base64的编码方式，但这不是加密处理。 8.3 DIGEST认证使用质询/响应的方式（challenge/response），不会像BASIC认证发送明文密码。MD5加密。P172 8.4 SSL客户端认证凭借SSL客户端证书的一种认证方式。 8.4.1 SSL客户端认证的认证步骤服务器通过私钥验证认证机构颁发给客户端的证书的有效性，有效就发送公钥证书，开始进行HTTPS加密通信。 8.4.2 SSL客户端认证采用双因素认证证书+表单认证。确认用户本人正在使用匹配正确的客户端访问。证书：确认客户端的真实性。表单验证：确认用户是本人。 8.5 基于表单认证对于SSH和FTP协议，服务器和客户端之间的认证是合乎标准规范的，并且满足最基本的安全级别，因此这些协议的认证可以直接拿来使用。对于SSL，能够满足安全级别的标准规范并不存在，因此只好使用由Web应用程序各自实现的基于表单的认证方式。 8.5.2 Session管理及Cookie应用 客户端把用户ID和密码放入报文的实体，通过POST方式发送给服务器，使用HTTPS通信来进行HTML表单画面的显示和用户输入数据的发送。 服务器验证身份后，发放用于记录登陆信息的SessionID，并将登陆状态（Session）和SessionID绑定后保存在服务端。 客户端接收到服务端发送来的SessionID后，会将其作为Cookie保存在本地。下次访问时，自动发送Cookie，服务端通过验证接受到的SessionID识别用户和其认证状态。JSESSIONID的Cookie消失，即使服务端还存在Session信息，也需要重新登录了。 第九章 基于HTTP的功能追加协议9.2 消除HTTP瓶颈的SPDYGoogle在2010年发布了SPDY（SPeeDY），旨在缩短web页面的加载时间。 HTTP以下标准成为突破Web功能的瓶颈： 一条连接上只可发送一个请求。 请求只能从客户端开始。客户端不可接受除响应以外的指令。 请求/响应首部未经压缩就发送。首部信息越多延迟就越大。 发送冗长的首部。每次互相发送相同的首部造成的浪费就越多。 可任意选择数据压缩格式。非强制压缩发送。 Ajax的解决办法Ajax，异步Javascript和XML技术。 Comet的解决办法通过延迟应答，模拟实现服务端想客户端推送的功能。在接受到客户端的请求时，Comet会先将响应置于挂起状态，当服务器端有内容更新时，再返回该响应。 Ajax和Comet并不能解决HTTP协议层面上的本身的瓶颈，SPDY协议能做到。 9.2.2 SPDY的设计与功能SPDY没有完全改写HTTP协议，而是以会话层的形式加入到应用层和传输层之间，强制规定通信中使用SSL。 SPDY控制对数据的流动，但还是采用HTTP建立通信连接。 HTTP协议额外获得的功能：多路复合流通多单一的TCP连接，可以无限制的处理多个HTTP请求，所有的请求的处理都在一条TCP连接上完成，因此TCP的处理效率得到提高。 赋予请求优先级多个请求中可以赋予优先级，解决因带宽低导致响应变慢的问题。 压缩HTTP首部压缩HTTP请求和响应的首部，减少数据量。 推送功能支持服务器主动向客户端推送数据的功能，这样服务器可直接发送数据，而不必等待客户端的请求。 服务器提示功能服务器可以主动提示客户端请求所需的资源。 9.2.3 SPDY消除Web瓶颈了吗SPDY只是将单个域名（IP地址）的通信多路复用，对于多域名的资源，效果欠佳。SPDY确实有效消除了HTTP的瓶颈，但是很多Web服务器存在的问题并非仅仅由HTTP的瓶颈造成。对速度的提升还应该从其他更细致的地方入手，比如改善Web内容的编写方式。 9.3 使用浏览器进行全双工通信的WebSocketWebSocket已逐步成为一套独立的协议标准。 9.3.1 WebSocket的设计与功能主要解决的是Ajax和Comet里XMLHttpRequest附带缺陷所引起的问题。 9.3.2 WebSocket协议一旦服务器和客户端建立起WebSocket协议的通信连接，之后的所有通信都依靠这个专用协议进行，通信过程可以相互发送JSON、XML、HTML或图片等任意格式的数据。 一旦建立WebSocket连接，任意一方都可以直接向对方发送报文。 WebSocket协议的主要特点： 推送服务服务器可直接向客户端发送数据，不必等待客户端的请求。 减少通信量一直连接，并且首部信息少，通信量减少。 为了实现WebSocket通信，在建立HTTP通信之后，需要完成一次“握手”的步骤。 用到HTTP的Upgrade首部字段，告知服务器通信协议发生了改变。 服务器对于之前的请求，返回状态码101 Switching Protocols的响应 123456789101112131415GET /chat HTTP/1.1Host:server.example.comUpgrade:websocketConnection:websocketSec-WebSocket-Key:fahfiuefusyhbfsns==Origin:http://example.comSec-WebSocket-Protocol:chat,superchatSec-WebSocket-Version:13HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8= 成功握手确立WebSocket连接之后，通信时不再使用HTTP的数据帧，而采用WebSocket独立的数据帧。 WebSocket APIJavascript可调用“The WebSocket API”内提供的WebSocket程序接口，以实现WebSocket协议下全双工通信。 以下为调用WebSocket API，每50ms发送一次数据的实例。 1234567var socket = new WebSocket('ws://game/example/com:12010/updates');socket.onopen = function()&#123; setInterval(function()&#123; if(socket.bufferAmount == 0) socket.send(getUpdateData()); &#125;);&#125;; 9.4关于HTTP/2.0P189 9.5 关于WebDAVP190 第十章 构建Web内容的技术CGI：相当于Java的Servlet。每次请求都启动新的CGI，访问量过大时服务器负载较大。 JSON（JavaScript Object Notation）：一种以JavaScript（ECMAScript）的对象表示法为基础的轻量级数据标记语言。{&quot;name&quot;:&quot;Web Application Security&quot;,&quot;num&quot;:&quot;TR001&quot;}能够处理的数据类型：false、null、true、对象、数组、数字、字符串。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>图解HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解HTTP（6、7） HTTP首部、HTTPS]]></title>
    <url>%2F2019%2F02%2F14%2F%E5%9B%BE%E8%A7%A3HTTP%EF%BC%886%E3%80%817%EF%BC%89%20HTTP%E9%A6%96%E9%83%A8%E3%80%81HTTPS%2F</url>
    <content type="text"><![CDATA[图解HTTP（6、7） HTTP首部、HTTPS 第六章 HTTP首部首部重复，根据浏览器的解析逻辑而定，或前或后有效。 6.2.3 四种HTTP首部字段类型 通用首部字段（General HEader Fields）：请求和响应都用的。 请求首部字段（Request HEader Fields） 响应首部字段（Response Header Fields） 实体首部字段（Entity Header Fields）：补充资源内容更新时间等与实体相关的信息。 6.2.5 非HTTP/1.1首部字段Cookie、Set-Cookie和Content-Disposition… 6.3.1 Cache-Control操作缓存的工作机制。P84指令一览。 public：所有用户可以使用缓存 private：特定用户 no-cache：请求：强制向源服务器再次验证。响应：缓存前必须确认其有效性。 no-store：不缓存请求或响应的内容。 s-maxage：缓存期限。只适用于对多用户使用的公共缓存服务器。优先级大于Expires（过期日期时间）和max-age max-age：缓存期限。在HTTP1.1中，优先级大于Expires。HTTP1.0相反。 min-fresh：缓存新鲜时间限制。如设置成600。在600秒内过期的缓存都不要返回了。 。。。P89 6.3.2 Connenction 请求：控制不再转发给代理的首部字段 响应：管理持久连接 HTTP1.1默认持久连接，当想断开时，一方的报文中附带Close。HTTP1.1以前则是非持久，需指定Keep-Alive。 6.3.3 Date报文的日期时间。 6.3.5 Trailer（追踪者）事先说明在报文主体后记录了哪些首部字段，该首部字段可应用在HTTP1.1版本分块传输编码时使用。 6.3.6 Transfer-Encoding规定了传输报文主体时采用的编码方式。HTTP1.1的传输编码方式仅对分块传输编码有效。 6.3.7 Upgrade用于检测HTTP协议及其他协议是否可以使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。P97. 6.3.8 Via追踪传输路径。 6.3.9 Warning告知用户一些与缓存相关的警告信息。P99。 6.4 请求首部字段6.4.1 Accept用户能够处理的媒体类型及媒体类型的相对优先级。 6.4.2 Accept-Charset支持的字符集及相对优先级。可一次性指定多种。iso、utf 6.4.3 Accept-Encoding用户代理支持的内容编码格式及优先级。一次性可指定多个。 6.4.4 Accept-Language告知服务器用户代理能够处理的自然语言集，以及优先级。 6.4.5 Authorization告知服务器用户代理的认证信息。 6.4.6 Expect期望出现的某种行为。若无法满足，返回417Expection Failed。 6.4.7 From告知用户代理用户的电子邮件地址。 6.4.8 Host虚拟主机运行在同一IP上，因此使用Host加以区分访问目标。唯一一个必须包含在请求内的首部字段。若服务器为设定主机名，直接发送一个空值即可。 6.4.9 If-Match形如If-XXX的都可称为条件请求。告知服务器匹配资源所用的Etag信息。不匹配返回412 Precondition Failed信息。 If-Modified-Since、If-None-Matched、If-Range、If-Unmodified-Since 6.4.14 Max-Forwards可经过的服务器最大数。当为0时，服务器立即返回响应。 6.4.15 Proxy-Authorization告知代理服务器认证所需要的信息。 6.4.16 Range获取部分资源。 6.4.17 Referer告知服务器请求的原始资源URI。 6.4.18 TE（Transfer-Encoding）告知服务器能够处理响应的传输编码方式及相对优先级。它与Accept-Encoding的功能很像，但是用于传输编码。 6.4.19 User-Agent用户信息。 6.5 响应首部字段6.5.1 Accept-Ranges能否处理的请求范围。能：bytes 否：none 6.5.2 Age源服务器多久前创建了响应。代理创建响应时必须加上Age。 6.5.3 Etag资源的唯一性标识。服务器分配。强Etag：不管资源实体多么细微的变化都会改变。若Etag：发生根本性改变时才会改变，字段最开始处附加W/。 6.5.4 Location提供重定向的URI。客户端只要接收到该字段，都会尝试性的对该URI进行访问。 6.5.5 Proxy-Authenticate把代理服务器要求的认证信息发送给客户端。它与客户端和服务器之间的HTTP访问认证的行为类似，不同之处在于其认证行为是在客户端和代理之间进行的。 6.5.6 Retry-After某个时间段后或某个时间点再来。 6.5.7 Server当前服务器上安装的HTTP服务器应用程序的信息。 6.5.8 Vary可以用来控制缓存。若客户端的首部信息和Vary中的信息相同，直接返回缓存。否则，需从源服务器再次获取资源。 6.5.9 WWW-Authenticate用于HTTP访问认证，告知客户端适用于访问请求URI指定资源的认证方案。状态码401Unauthorized响应中，肯定带有首部字段WWW-Authenticate。 6.6 实体首部字段补充内容的更新时间等与实体相关的信息。 6.6.1 Allow通知客户端能够支持的Request-URI指定资源的所有HTTP方法。当服务器接受到不支持的HTTP方法时，会以405 Method Not Allowed作为响应返回。 6.6.2 Content-Encoding告知客户端服务器对实体内容进行的内容编码方式。 6.6.3 Content-Language实体主题使用的自然语言。 6.6.4 Content-Length实体大小。单位：字节 6.6.5 Content-Location报文主体部分相对应的URI。 6.6.6 Content-MD5告知客户端对实体进行相同MD5算法编码然后比对，检查主体在传输过程中保持完整。这种方式无法放篡改，原因是MD5值可能在被篡改之后重新更新。 6.6.7 Content-Range返回主体内容的范围。 6.6.8 Content-Type实体主体对象的媒体类型。Content-Type: text/html; charset = UTF-8 6.6.9 Expires缓存到期时间。优先级低于max-age。 6.6.10 Last-Modified资源最终修改时间。 6.7 为Cookie服务的首部字段6.7.1 Set-CookieSet-Cookie:status=enable;expires = Tue；path=/;dpmain=.hacker.jp expires：有效期，缺省浏览器关闭无效。服务器端不存在显示删除cookie方法，但可以更新覆盖同名cookie。 path：限制指定Cookie发送范围的文件目录。 domain：匹配上URI，发送cookie。 secure：仅在HTTPS安全连接时才发送cookie。缺省HTTP和HTTPS都会对Cookie进行回收。 HttpOnly：防止JavaScript脚本劫持cookie。 6.7.2 CookieCookie：status=enable告知服务器，使用了cookie。 6.8 其他首部字段P137 第七章 确保Web安全的HTTPS###7.1 HTTP缺点： 通信使用明文，不安全。 不验证通信方的身份，因此有可能遭遇伪装。 无法证明报文的完整性，有可能已遭篡改。 7.1.1 通信使用明文可能会被窃听由于HTTP本身不具备加密的功能，所以也无法做到对通信整体（请求和响应内容）进行加密。 问题：TCP/IP是可能被窃听的网络：通过特定软件进行抓包解析。 应对：加密处理防止被窃听： 通信的加密：HTTP没有加密机制，但可以通过和SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全传输层协议）的组合使用，加密HTTP的通信内容。与SSL组合使用的HTTP被称为HTTPS（HTTP Secure，超文本传输安全协议）或HTTP over SSL。 内容的加密：只对报文主体的内容进行加密，报文首部不加密。要求客户端和服务器同时具有加密和解密机制。由于不同于对整个通信线路进行加密，内容仍有被篡改的可能。 7.1.2 不验证通信方的身份可能遭遇伪装问题：任何人都可以发起请求：伪装服务器，伪装客户端，超越权限的操作，无法阻止海量请求下的DoS攻击（Denial of Service，拒绝服务攻击） 应对：查看对手的证书证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。客户端或服务器有证书，则大体可以判断为非伪装。 7.1.3 无法证明报文完整性，可能已遭篡改问题：接受的内容可能有误：请求或响应再传输途中，可能遭遇中间人攻击（Man-in-the-Middle attack，MITM）。 如何防篡改MD5和SHA-1等散列值校验。以及用来确认文件的数字签名方法。PGP（Pretty Good Privacy，完美签名）。该方法也不能完全保证安全，因为MD5和PGP可能本身被篡改。 SSL提供认证和加密处理及摘要功能。 7.2 HTTP+通信加密+认证+完整性保护=HTTPS7.2.2 HTTPS是身披SSL外壳的HTTPSSL是独立于HTTP的协议，所以不光是HTTP，其他运行在应用层的SMTP和Telnet等协议均可配合SSL协议使用。可以说SSL是当今世界应用最为广泛的网络安全技术。 共享密钥加密的困境密钥随数据一起传输，解密和加密用同一把密钥，同样的不安全。 SSL采用，公开密钥加密（Public-key Cryptography）加密方式，非对称加密私钥（private-key）和公钥（public-key），公钥和私钥 是配对的一套密钥。公钥随数据传输，加密用公钥，解密用各自的私钥，私钥不参与传输，也就不存在泄漏的风险。 HTTPS采用的方式：混合加密机制。由于公开密钥加密机制比共享密钥加密要复杂，因此效率更低。所以最好采用混合制。 使用公开密钥交换稍后需要使用到的密钥。 确保密钥安全交换的前提下，使用共享密钥对资源进行加密。 7.2.4 证明公开密钥正确性的证书还存在的问题。公钥的真实性确认，如果公钥被攻击者替换，服务器利用该公钥加密的内容很容易被攻击者的私钥解密。 解决办法：使用数字证书认证机构（CA，Certificate Authority）和其他相关机关颁发的公开密钥证书。 数字证书认证机构是客户端和服务器端都认可的第三方机构。如威瑞信（VeriSign）。 数字证书认证机构的业务流程： 服务器运营人员向数字证书认证机构提出公开密钥的申请。认证机构判定身份后，会对已申请的公钥做数字签名（私有密钥进行签名，数字证书认证的公钥已实现植入到浏览器即客户端）。然后将公钥和公钥证书绑定在一起。 服务器将证书发送给用户，已进行公钥加密方式进行通信。 接受证书的客户端利用实现植入的公钥对证书进行验证，一旦验证通过，便可明确：1.认证服务器的公钥是证实有效的数字认证机构的。2.服务器的公钥是指的信赖的。 如何将数字机构的公钥传给客户端？大多数浏览器发布时，会实现内部植入认证机关的公开密钥。 可证明组织真实性的EV SSL证书证书的一个作用是证明服务器方是否规范，另一个作用是确认服务器背后运营的企业是否真实存在。其严格规定了对运营组织是否真实的确认方针，因此，通过认证的web网站具有更高的认可度。持有EV SSL证书的网站地址栏显示绿色并在左侧显示了组织名称和颁发证书的认证机构的名称。改机制意图是为了防钓鱼。 用以确认客户端的客户端证书其机制和服务器证书如出一辙，但是让每个客户端都购买证书是不现实的，现状是：仅在用于特殊用途的客户端颁发证书，如银行的网上银行就采用了客户端证书，在登录网银时不仅需要用户确认id和密码，还会要求用户的客户端证书，以确认用户从特定的客户终端访问网银。 认证机构信誉第一偶尔出现认证机构被黑的情况时，可以通过：将证书无效化的证书吊销列表（Certificate Revocation List，CRL）机制，以及从客户端删除根证书颁发机构（Root Certificate Authority，RCA）的对策止损。 自己的理解：私钥加密用于数字证书，对应的公钥用于验证数字证书的有效性。公钥加密用于数据传递，对应私钥用于解密。 由自认证机构颁发的证书成为自签名证书如果使用OpenSSL这套开源程序，每个人可以构建一套属于自己的认证机构，从而给自己颁发服务器证书。但该证书在互联网上不可作为证书使用。 浏览器访问自签名证书服务器时，会显示“无法确认连接安全性”或“改网站的安全证书存在问题”等警告消息。 浏览器中的中级认证机构的证书一般可能会当做正规证书对待，也可能会当做自签名证书。 7.2.5 HTTPS的安全通信机制步骤： 客户端发送Client Hello报文开始SSL通信，报文中包含客户端支持的SSL的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。 服务器可进行SSL通信时，会以Server Hello报文作为应答。报文中同样包含SSL版本和加密组件，该组件内容是从接受到的客户端组件里面筛选出来的。 之后服务器发送Certificate报文。报文中包含公钥证书。 最后服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束。 SSL第一次握手结束之后，客户端以Client Key Exchange报文作为回应。报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串，该报文已用3中的公钥加密了。 客户端发送finished报文，该报文包含连接至今全部报文的整体校验值。这次握手协商是否能成功，要以服务器能够正确解密该报文作为判断标准。 服务器同样发送Change Cipher Spec报文。 服务器同样发送finished报文。 服务器和客户端的Finished报文交换完毕以后，SSL连接就算建立完成。当然，通信会受到SSL保护。从此处开始进行应用层协议的通信，即发送HTTP请求。 最后有客户端断开连接，断开连接时，发送close_notify报文。 具体流程图见P163. SSL（Secure Socket Layer）和TLS（Transport Layer Security）这两个协议。 为什么不一直使用HTTPS？原因：HTTPS慢，SSL增加了通信量，并且增加了解密和加密运算处理，消耗内存和CPU。因此较HTTP更慢。在不包含个人敏感信息传送时 ，使用的 是HTTP传送。另一方面，购买CA认证证书需要支付一定的费用。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>图解HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解HTTP（4、5） 返回结果的HTTP状态码、与HTTP协作的Web服务器]]></title>
    <url>%2F2019%2F02%2F14%2F%E5%9B%BE%E8%A7%A3HTTP%EF%BC%884%E3%80%815%EF%BC%89%20%20%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E3%80%81%E4%B8%8EHTTP%E5%8D%8F%E4%BD%9C%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[图解HTTP（4、5） 返回结果的HTTP状态码、与HTTP协作的Web服务器 4.1 状态码告知服务器端返回的请求结果4.1 2XX 成功 200 OK：正常处理了。随状态码一起返回的信息可能因为方法的不同发生改变。如HEAD方法只返回首部，不返回实体。 204 No Content：返回的响应报文不含也不允许包含实体的主体。 206 Partial Content：表示客户端进行了范围请求，而服务器也成功执行了。响应报文中包含有Content-Range指定范围的实体内容。 4.3 3XX 重定向 301 MOved Permanently：请求的资源永久性的迁移URI，以后应使用改URI。如果客户端已保存书签，应该按首度Location提示的URI重新保存。 302 Not Found：暂时性重定向，希望客户端本次使用新的URI访问。和Location一起用。 303 See Other：请求的资源存在着另一个URI，并要求客户端使用GET方法查看。302没有要求用GET。 当301302303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。 304 NotModified：当客户端发送了带条件的请求时（If-Match、If-Modified-Since等），服务器允许访问资源，但因为没有满足条件才返回。所以不包含任何响应的主体部分。和重定向没什么关系。 307 TemporaryRedirect：临时重定向。 4.4 4XX客户端错误 400 BadRequest：请求报文中存在语法错误。 401 Unauthorized：需要HTTP验证，若之前进行了一次请求，则表示用户验证失败。 403 Forbidden：不允许访问该资源。 404 NotFOund：该资源不存在。 4.5 5XX服务器错误 500 Internal Server Error：服务器内部错误。 503 Service Unavailable：服务器处于超负载或维护。 5.1 用单台虚拟主机实现多个域名HTTP/1.1 允许一台HTTP服务器搭建多个Web站点。可以利用虚拟主机实现。在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的Web网站，因此在请求时，必须在Host首部内完整的指定主机名或域名的URI。 5.2 通信数据转发程序：代理、网关、隧道HTTP通信时，除了客户端和服务器之外，还有一些用于通信数据转发的一些应用程序，配合服务器工作。 这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接受上一台服务器发送的响应再转发给客户端。 5.2.1 代理：具有转发功能的应用程序，扮演服务器和客户端的中间人角色。 代理不改变URI。在HTTP通信过程中 ，可级联多台代理服务器。转发时，需要附加Via首部字段标记经过的主机信息。 代理的理由：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的等等。 缓存代理：客户端再次请求相同资源时，可以不存源服务器而从缓存代理获取内容。 透明代理：转发请求或响应时，不对报文做任何加工的代理类型成为透明代理。反之称为非透明。 5.2.2 网管：转发其他服务器通信数据的服务器，接受从客户端发来的请求时，它就像自己拥有资源的源服务器一样进行处理，有时客户端都不会察觉自己的通信目标是一个网关。 和代理相似，但是网管可以使通信路线上的服务器提供非HTTP协议服务。利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。 5.2.3 隧道：隧道在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。 隧道使用SSL等加密手段建立通信，目的是确保客户端能与服务器进行安全的通信。隧道本身不会解析HTTP请求，原样传送。 5.3 保存资源的缓存缓存服务器是代理服务器的一种，并归类与缓存代理类型中。 5.3.1 缓存的有效期限存在一个时效性的问题，过时效，重新从源服务器获取资源。 5.3.2 客户端的缓存临时网络文件（Temporary Internet File），也存在有效期。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>图解HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解HTTP（2） 简单的HTTP协议]]></title>
    <url>%2F2019%2F02%2F14%2F%E5%9B%BE%E8%A7%A3HTTP%EF%BC%882%EF%BC%89%20%E7%AE%80%E5%8D%95%E7%9A%84HTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[图解HTTP（2） 简单的HTTP协议整理了从开始学习Java以来在纸质本上做的一些笔记，如有错误，恳请批评指正。 请求头和响应头HTTP是不保存状态的协议重复请求，重复响应，协议本身并不保留之前一切的请求或响应报文的信息。这是为了更好的处理大量事务，确保协议的可伸缩性。 HTTP1.1虽然是无状态协议，但为了能实现期望的保持状态功能，引入了Cookie技术。有了Cookie再用HTTP协议通信，就可以管理状态了。 告知服务器意图的HTTP方法GET如果访问的资源是文本，则原样返回；如果是像CHI（Common Gateway Interface，通用网管接口）那样的程序，则返回执行后的结果。 POST和GET相似，但POST的主要目的并不是获取响应的主体内容。倾向于传输实体主体。 PUT传输文件。保存到URI指定的位置，由于不带验证机制导致所有人都可以上传文件，存在安全性问题，较少用到。 HEAD和GET方法一样，知识不返回报文主体部分，用于确认URI的有效性及资源更新的日期时间等。 DELETE和PUT相反的方法，DELETE方法按请求URI删除指定的资源。不带验证机制，不安全，较少用到。 OPTIOND询问支持的方法。查询针对请求URI指定的资源支持的方法。 TRACE让WEB服务器端将之前的请求通信环回给客户端的方法。较少用到。 CONNECT要求用隧道协议连接代理，实现用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 HTTP1.0、HTTP1.1支持的方法 持久连接节省通信量HTTP协议的早期版本中，每进行一次HTTP通信就要断开一次TCP链接，当访问包含多个资源的资源集时，开销过大。 持久连接HTTP1.1和一部分HTTP1.0发明了持久连接（HTTP Persistent Connections，也称HTTP keep-alive或HTTP connection reuse）的方法。持久连接的特点是：只要任意一方没有提出明确提出断开连接，则保持TCP连接状态。 管线化不用等待上次请求的响应结果，直接发送下一次请求。比持久化连接的效率更高。 使用Cookie的状态管理响应信息包含set-cookie的响应行，通知客户端保存cookie，下次访问发送cookie到服务端，服务端对比服务器上的记录，得到客户端之前的状态信息。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>图解HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解HTTP（1） 了解Web及网络基础]]></title>
    <url>%2F2019%2F02%2F14%2F%E5%9B%BE%E8%A7%A3HTTP%EF%BC%881%EF%BC%89%20%E4%BA%86%E8%A7%A3Web%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[图解HTTP（1） 了解Web及网络基础整理了从开始学习Java以来在纸质本上做的一些笔记，如有错误，恳请批评指正。 HTTP HTTP（HyperText Transfer Protocol），超文本传输协议，一种规范，完成从客户端到服务器端等一系列运作流程。协议是指规则的约定，可以说，Web是建立在HTTP协议上通信的。 HTTP /1.1是目前主流的HTTP协议版本 目前已提出的3想WWW构建技术： 把SGML（Standard Generalized Markup Language，标准通用标记语言）作为页面的文本标记语言的HTML（HyberText Markup Language，超文本标记语言）； 作为文档传输协议的HTTP； 指定文档所在地址的URL（Uniform Resource Locator，统一资源定位符） TCP/IP协议族通常使用的网络是在TCP/IP协议族的基础上运作的，而HTTP属于它内部的一个子集。 TCP/IP协议族按层次分别分为以下4层：应用层、传输层、网络层和数据链路层。 应用层应用层决定了向用户提供应用服务时通信的活动。 TCP/IP协议族内预存了各类通用的引用服务：FTP（File Transfer Protocol，文件传输协议）和DNS（Domain Name System，域名系统）服务就处于该层。 HTTP协议也处于该层。 传输层传输层对上层应用层，提供处于网络连接中的两台电脑间的数据传输。 传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol，用户数据报协议）。 网络层（又名网络互连层）网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。选择一条传输路线在不同的计算机之间进行网络传输。 链路层（又名数据链路层，网络接口层）用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（NextWord InterFace Card，网络适配器，即网卡），及光纤等物理可见部分。硬件上的范畴均在链路层的作用范围之内。 利用TCP/Ip协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。发送端时，没经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种把数据信息包装起来的做法称为封装（encapsulate）。 与HTTP关系密切的协议：IP、TCP和DNS负责传输的IP协议IP协议：确保数据传输能传到正确的位置。包括：IP地址和MAC地址（Media Access Control Address）。 IP地址：指定节点被分配到的地址。 MAC地址：网卡所属的固定地址。 使用ARP协议凭借MAC地址进行通信ARP：一种解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。 确保可靠性的TCP协议TCP位于传输层，提供可靠的字节流服务。所谓字节流服务（Byte Stream Service），是指为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。 三次握手机制三次握手（Three-way handshaking），握手过程中使用了TCP的标志（flag）—-SYN（synchronized）和ACK（acknowledgment）。 负责域名解析的DNS服务DNS（Domain Name System）服务是和HTTP协议一样位于应用层的协议，它提供域名到IP地址之间的解析服务。 各种协议与HTTP协议的关系 URL和URIURIURI（Uniform Resource Identifdier），有某个协议方法表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。 采用HTTP协议时，协议方案就是http。除此以外，还以ftp、mailto、telnet、file等。标准的URI协议方案有30种左右。 URI用字符串标识某一互联网资源，而URL表示资源的地点（互联网上所处的位置），课件URL是URI的子集。 URI示例：12345678ftp://ftp.is.co.za/rfc/rfc1808.txthttp://www.ietf.org/rfc/rfc2396.txtldap://[2001:db8::7]/c=GB?objectClass?onemailto:John.Doe@example.comnews:comp.infosystems.www.servers.unixtel:+1-816-555-1212telnet://192.0.2.16:80/urn:oasis:names:specification:docbook:dtd:xml:4.1.2]]></content>
      <categories>
        <category>学习笔记</category>
        <category>图解HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法分析（JAVA描述）（第一章）]]></title>
    <url>%2F2019%2F02%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%88JAVA%E6%8F%8F%E8%BF%B0%EF%BC%89%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构与算法分析（JAVA描述）（第一章）chapter1#引论个人笔记，如有错误，恳请批评指正。 1.4 实现泛型构件 Pre-Java 5JDK1.5新特性： 泛型（Generics） 增强的“for”循环（Enhanced For loop） 自动装箱/ 自动拆箱（Autoboxing/unboxing） 类型安全的枚举（Type safe enums） 静态导入（Static import） 可变参数(Var args) 1.4.1 使用Object表示泛型略 1.4.2 基本类型的包装Java为8总不能和Object相容的基本类型提供包装类，如int为Integer，每一个包装对象不可变（即状态不能被改变）。 1.4.3 使用接口类型表示泛型 总的来说就是用接口定义类型，比如Comparable接口，只有实现此接口并在其CompareTo方法中定义了对应的比较方法时，此类才有可比较性。实现了同一接口的类在某种意义上可以视为同一类。 如果comparable数组总有两个不相容的对象（例如，一个String一个Shape），那么CompareTo方法将抛出ClassCastException的异常。 如前所示，基本类型不能作为COmparable传递，但是包装类型可以，因为其实现了Comparable接口。 1.4.4 数组类型的兼容性为了避免不同数组之间相互引用产生类型混乱（Employee IS-A Person; Student IS-A Person;Employee IS-NOT Student），最容易的方法是指定这些数组不是数据兼容的。而在Java中，数组是类型兼容的，这叫做协变数组类型（convariant array type），每个数组明确说明其所允许的储存对象的类型，如果将一个不兼容的类型插入到数组，虚拟机将会抛出一个ArrayStoreException的异常。在较早的JDK版本中是需要数组的协变性的。 1.5 利用Java 5 泛型特性实现泛型构件1.5.1 简单的泛型类和接口泛型类略，Java 5 之前，Comparable接口不是泛型的，而它的Comparable方法需要Object作为参数。于是，传递到COmparaTo方法的任何引用变量类型即使不合理也会编译，运行时报ClassCastException异常。Java 5 中，Comparable接口是泛型的，通过使实现类变成泛型类，以前只有在运行时才能报的异常提前到编译时异常了。 1.5.2 自动封箱/自动拆箱Java 5 中，如果一个int型量被传递到一个需要integer对象的地方，那么编译器将在幕后插入一个对Integer构造方法的调用。此过程叫自动装箱。而如果一个Integer对象被放到需要int型量的地方，编译器将在幕后插入一个intvalue方法的调用，这就叫做自动拆箱，对于其他的包装类型同样会发生类似的情形。 1.5.3 菱形运算Java 7 中添加的新特性 1Map&lt;String&gt; map = new HashMap&lt;&gt;();//右边的类型声明可以不写 1.5.4 限制通配符12Collection&lt;? extends Shape&gt; arr;//表示Shape及其子类Collection&lt;? super Square&gt;;//表示Square及其超类 1.5.5 泛型static方法泛型方法特别像泛型类，因为类型参数表使用相同的语法。在泛型方法中的类型参数位于返回类型之前。 123456789/***判断数组中是否含有指定元素，泛型声明数组类型*/public static &lt;T&gt; boolean contains(T[] arr,T x)&#123; for(T item:arr)&#123; if(x.equals(item))return true; &#125; return false;&#125; 1.5.6 类型限界略 1.5.7类型擦除泛型在很大程度上是Java语言中的成分而不是虚拟机中的结构。泛型类可以由编译器通过所谓的类型擦除（Type erasure）过程而转变成非泛型类。这样，编译器就生成了一种与泛型类同名的原始类（raw class），但是类型参数都被删除了。类型变量由它们的类型限界来代替，当一个具有擦除返回类型的泛型方法被调用的时候，一些特性被自动的插入。如果一个泛型类而不带类型参数，就是原始类。类型擦除的显著优点是：程序员不需要把一些类型转换代码放到代码中，编译器将进行重要的类型检验。 练习：T1.5 编写一种递归方法，他返回数N的二进制表示中1的个数。利用这样的事实：如果N为奇数，其1的个数为N/2的二进制表示中1的个数加1。 12345678910111213141516171819202122232425262728package cn.ustb.chapter1;public class Demo3 &#123; /** * 只考虑正数，返回传入数字二进制中1的个数，利用原理：如果N是奇数，那么其1的个数等于N/2的二进制1的个数加1。 * * @return */ public static int return1count(int num) &#123; /** * 奇数：迭代 1:1 2:10 3:11 4:100 5:101 6:110 7:111 8:1000 * */ if (num == 0)//终止条件 return 0; else &#123; if (num % 2 != 0) &#123;// 奇数 return return1count(num/2) + 1; &#125; else &#123;//偶数 return return1count(num/2); &#125; &#125; &#125; public static void main(String[] args) &#123; int num = 100123; int count = return1count(num); System.out.println(num+"二进制中1的个数为："+count); &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构与算法分析</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法分析（JAVA描述）（第五章 散列）]]></title>
    <url>%2F2019%2F02%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%88JAVA%E6%8F%8F%E8%BF%B0%EF%BC%89%EF%BC%88%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%95%A3%E5%88%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构与算法分析（JAVA描述）（第五章 散列） 个人笔记，如有错误，恳请批评指正。 理想的散列表数据结构只不过是一个包含一些项（item）的具有固定大小的数组。组成：关键字+数据域。表的大小称为tablesize，通常的习惯是让表从0-tablesize-1变化。 散列表（hash table）5.2 散列函数 （hash function）散列函数的作用是根据key和tablesize返回存储的位置，均匀的分布于散列表中。 1234567891011public static int hash(String key,int tableSize)&#123; int hashVal = 0; for(int i = 0;i&lt;key.length();i++) hashVal = 37*hashVal+key.charAt(i); hashVal %= tableSize; if(hashVal&lt;0) hashVal += tableSize; return hashVal;&#125; 解决散列函数（即存储地址）相同引起的冲突有两种方法：分离链接法和开放定址法。 5.3 分离链接法（separate chaining）链表结构存储相同散列函数值的数据，新元素插入到链表的前端。表的大小即为list的个数。装填因子是指：散列表的元素个数/表的大小。改因子影响了散列表的平均查找代价。实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class SeparateChainingHashTable&lt;T&gt; &#123; private static final int DEFAULT_TABLE_SIZE = 101; private List&lt;T&gt;[] theLists; private int currentSize; public SeparateChainingHashTable() &#123; this(DEFAULT_TABLE_SIZE); &#125; public SeparateChainingHashTable(int size) &#123; theLists = new LinkedList[size]; for(int i = 0;i&lt;theLists.length;i++) theLists[i] = new LinkedList&lt;T&gt;(); &#125; public int size()&#123; return currentSize; &#125; public void insert(T element)&#123; List&lt;T&gt; whichList = theLists[myhash(element)]; if(!whichList.contains(element)) whichList.add(element); if(++currentSize&gt;theLists.length)//装填因子&gt;1了 rehash(); System.out.println("存入的hash位置是："+myhash(element)); System.out.println("当前size为"+currentSize); &#125; public void remove(T element)&#123; List&lt;T&gt; whichList = theLists[myhash(element)]; if(whichList.contains(element))&#123; whichList.remove(element); currentSize--; &#125; &#125; public void makeEmpty()&#123; //保留之前的size，只清除数据 for(int i = 0;i&lt;theLists.length;i++) theLists[i].clear(); currentSize = 0; &#125; public boolean contains(T element)&#123; List&lt;T&gt; whichList = theLists[myhash(element)]; return whichList.contains(element); &#125; /** * 再散列 */ private void rehash()&#123; System.out.println("rehash方法调用了"); List&lt;T&gt;[] oldLists = theLists; theLists = new List[theLists.length*2]; for(int i = 0;i&lt;theLists.length;i++) theLists[i] = new LinkedList&lt;T&gt;(); currentSize = 0; for(int j = 0;j&lt;oldLists.length;j++)&#123; for (T t : oldLists[j]) &#123; insert(t);//因为size改变，不能简单的复制关键值，重新进行insert操作。 &#125; &#125; &#125; /** * 确定地址 * @param element * @return */ private int myhash(T element)&#123; int hashVal = element.hashCode(); hashVal %= theLists.length; if(hashVal&lt;0) hashVal += theLists.length; return hashVal; &#125; public static void main(String[] args) &#123; SeparateChainingHashTable&lt;Integer&gt; hashTable = new SeparateChainingHashTable&lt;Integer&gt;(101); for (int j = 0; j &lt; 100; j++) &#123; hashTable.insert(j); &#125; hashTable.makeEmpty(); System.out.println(hashTable.size()); System.out.println(hashTable.theLists.length); &#125;&#125; 5.4 不用链表的散列表不用链表，当hash冲突时，尝试另外的存储单元，知道找到空的为止，此种方法要使用的表要比分离链接散列的表大，一般来说，对于不使用分离链接的散列表来说，其装填因子应该低于0.5。这样的表称为探测散列表（probing hash table）。 5.4.1 线性探测法产生一次聚集的问题（primary clustering），散列到区块的任何关键字都需要多次试选单元才能够解决冲突，然后该关键字被添加到相应的区块中。 5.4.2 平方探测法定理5.1：如果使用平方探测，且标的大小是素数，当表至少有一半是空时，总能够插入一个新的元素。此定理用于确定rehash的时机。实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120public class QuadraticProbingHashTable&lt;T&gt; &#123; private static final int DEFAULT_TABLE_SIZE = 101; private int currentSize; private HashEntry&lt;T&gt;[] array; /** * 嵌套类,自定义的表格单元 */ private static class HashEntry&lt;T&gt;&#123; public T element; public boolean isActive; public HashEntry(T element) &#123; this(element,true); &#125; public HashEntry(T element, boolean isActive) &#123; this.element = element; this.isActive = isActive; &#125; &#125; public QuadraticProbingHashTable() &#123; this(DEFAULT_TABLE_SIZE); &#125; public QuadraticProbingHashTable(int size)&#123; array = new HashEntry[size]; &#125; public int size()&#123; return currentSize; &#125; public void makeEmpty()&#123; currentSize = 0; for(int i = 0;i&lt;array.length;i++) array[i] = null; &#125; public boolean contains(T element)&#123; int currentPos = findPos(element); return isActive(currentPos); &#125; /** * 实施对冲突的解决 * @param element * @return */ private int findPos(T element)&#123; int offset = 1; int currentPos = myhash(element); while(array[currentPos] != null &amp;&amp; !array[currentPos].element.equals(element))&#123;//探测 currentPos += offset;//计算i探测的指针位置 offset为第i次的步长 offset += 2; /* * +1 1 * +3 4 * +5 9 * +7 16 */ if(currentPos&gt;=array.length) currentPos %= array.length; &#125; return currentPos; &#125; public void insert(T element)&#123; int currentPos = findPos(element); if(isActive(currentPos)) return;//不做任何操作，说明该位置有数，并且元素和插入元素重复 array[currentPos] = new HashEntry&lt;T&gt;(element); if(++currentSize&gt;array.length/2)//根据定理，过半则探测不到，进行rehash rehash(); System.out.println("插入的元素是"+element); System.out.println("currentPos"+currentPos); System.out.println("currentSize:"+size()); System.out.println("======================="); &#125; public void remove(T element)&#123; int currentPos= findPos(element); if(isActive(currentPos))&#123; currentSize--; array[currentPos].isActive = false;//element会被覆盖 &#125; System.out.println("remove的元素"+element); System.out.println("currentPos"+currentPos); System.out.println("currentSize"+size()); System.out.println("++++++++++++++++++++++++"); &#125; private void rehash()&#123; HashEntry&lt;T&gt;[] oldArray = array; array = new HashEntry[array.length*2]; currentSize = 0; for (HashEntry&lt;T&gt; entry : oldArray) &#123; if(entry!=null&amp;&amp;entry.isActive)//判空和判Active insert(entry.element); &#125; &#125; private boolean isActive(int currentPos)&#123; return array[currentPos] !=null &amp;&amp; array[currentPos].isActive; &#125; private int myhash(T element)&#123; int hashVal = element.hashCode(); hashVal %= array.length; if(hashVal&lt;0) hashVal += array.length; return hashVal; &#125; /** *test */ public static void main(String[] args) &#123; QuadraticProbingHashTable&lt;Integer&gt; hashTable = new QuadraticProbingHashTable&lt;Integer&gt;(101); System.out.println(hashTable.size()); for(int i = 0;i&lt;101;i++)&#123; hashTable.insert(i); hashTable.remove(i); &#125; System.out.println(hashTable.size()); &#125;&#125; remove时不能直接将HashEntry=null，原因是之前插入过数据的HashEntry除非再次插入一样的数据，不能插入别的数据，否则会引起混乱。 虽然平方探测排除了一次聚集，但是散列到同一位置上的那些元素将探测相同的备选单元。这叫做二次聚集（secondary clustering）。 5.4.3 双散列5.5 再散列对于使用平方探测的开放地址散列法，如果散列表填的太满，那么操作的运行时间消耗过长，且插入可能会失败。解决办法是及时拓容。及再散列（rehashing）。 5.6 标准库中的散列表标准库包括set和map的散列表的实现，即Hashset类和Hashmap类。Hashset中的项必须提供equals方法和hashcode方法，Hashset和Hashmap通常是用分离链接散列实现的。 小结散列表可以以常数平均时间实现insert和查找操作。当使用散列表时注意注入装填因子这样的细节特别重要，否则时间界将不再有效。当关键字不是短的串或整数时，仔细选择散列函数也是特别重要的。对于分离链接散列法，虽然装填因子不很大时性能并不明显降低，但是装填因子还是应该接近于1。对于探测散列算法，除非不可避免，否则装填因子不应该超过0.5。二叉查找树也可以用来实现insert和contains运算，支持那些需要序从而功能更强大的程序。使用散列表不可能找到最值元素，除非明确的知道字符串，否则散列表也不可能有效地查找到他。二叉查找树可以迅速的找到在一定范围内的所有项；散列表做不到。另一方面，散列的最坏情况一般来自于实现的错误，而有序的输入却是二叉查找树的噩梦。平衡查找树的代价很高，因此，如果不需要有序的信息以及对输入是否有序存有怀疑，就应该选择散列这种数据结构。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构与算法分析</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法分析</tag>
        <tag>散列表</tag>
        <tag>分离链接散列</tag>
        <tag>平方探测法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法分析（JAVA描述）（第四章 树）]]></title>
    <url>%2F2019%2F02%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%88JAVA%E6%8F%8F%E8%BF%B0%EF%BC%89%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%20%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构与算法分析（JAVA描述）（第四章 树）二叉查找树BST，AVL树，伸展树，B树个人笔记，如有错误，恳请批评指正。 二叉查找树（binary search tree），两中库集合类TreeSet、TreeMap实现的基础。 4.1 预备知识根（root）边（edge）父（parent）子（child）树叶（leaf）：没有子节点的节点。兄弟（siblings）：具有相同父节点。祖父（grandparent）孙子（grandchild）一棵树是N个节点和N-1条边的集合。路径（path）的长（length）：路径上的边的条数深度（depth）：根到该节点的路径长。高（height）：该节点到树叶最长的一条路径。树高=根高先序遍历（preorder traversal）/后序遍历（postorder traversal） 4.2 二叉树二叉树（binary tree），每个节点都不能有多余两个的子节点。其一个性质就是：一棵平均二叉树的深度要比节点个数N小的多，这个性质有时候很重要。分析表明，其平均深度为O（√N），而对于特殊类型的二叉查找树（binary search tree），其深度的平均值是O（logN）。 4.2.1 实现树节点的声明在结构上类似于双链表的声明，节点由element的信息加上两个到其他节点的引用组成的结构。 12345class BinaryNode &#123; Object element; BinaryNode left; BinaryNode right;&#125; 4.2.2 例子：表达式树遍历策略1：通过递归的产生一个带括号的左表达式，然后打印出在根处的运算符，最后再递归地产生一个带括号的右表达式而得到一个中缀表达式。这种一般的方法成为中序遍历（inorder traversal）。遍历策略2：递归的打印出左子树、右子树，然后打印运算符。输出 ：a b c x + d e x f + g x +；这种遍历策略一般称为后序遍历。遍历策略3：先打印出运算符，然后递归的打印出左子树和右子树。此时得到的表达式是：+ + a x b c x + x d e f g；不太常用，前缀记法，先序遍历策略。 4.3 查找树ADT–二叉查找树binary search tree的Java实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/** * Java实现二叉查找树 * @author Wch * * @param &lt;T&gt; */public class BinarySearchTree&lt;T extends Comparable&lt;? super T&gt;&gt;&#123; private static class BinaryNode&lt;T&gt;&#123; public T element; public BinaryNode&lt;T&gt; left; public BinaryNode&lt;T&gt; right; public BinaryNode(T element)&#123; this.element = element; this.left = null; this.right = null; &#125; &#125; private BinaryNode&lt;T&gt; root; public BinarySearchTree() &#123; root = null; &#125; public void makeEmpty()&#123; root = null; &#125; public boolean isEmpty()&#123; return root == null; &#125; public boolean contains(T element)&#123; return contains(element,root); &#125; private boolean contains(T element,BinaryNode&lt;T&gt; node)&#123; if(node == null) return false; if(element.compareTo(node.element)&lt;0) return contains(element,node.left); else if(element.compareTo(node.element)&gt;0) return contains(element,node.right); return true;//存在 &#125; public T findMin()&#123; if(!isEmpty()) return findMin(root); else try &#123; throw new Exception("不存在元素"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; private T findMin(BinaryNode&lt;T&gt; node)&#123; if(node.left!=null) return findMin(node.left); return node.element; &#125; public T findMax()&#123; if(!isEmpty()) return findMax(root); else try &#123; throw new Exception("不存在元素"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; private T findMax(BinaryNode&lt;T&gt; node)&#123; /* * 利用非递归来实现 */ while(node.right!=null) node = node.right; return node.element; &#125; public void insert(T element)&#123; root = insert(element,root); &#125; private BinaryNode&lt;T&gt; insert(T element,BinaryNode&lt;T&gt; node)&#123;//node为插入点 if(node==null) return new BinaryNode&lt;T&gt;(element); if(element.compareTo(node.element)&lt;0)//往左走 node.left = insert(element,node.left); if(element.compareTo(node.element)&gt;0) node.right = insert(element,node.right); return node; &#125; public void remove(T element)&#123; remove(element,root); &#125; /** remove方法 */ private BinaryNode&lt;T&gt; remove(T element,BinaryNode&lt;T&gt; node)&#123; if(node == null) try &#123; throw new Exception("不存在该元素"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; int compareResult = element.compareTo(node.element); if(compareResult&lt;0) node.left = remove(element, node.left); else if(compareResult&gt;0) node.right = remove(element, node.right); /** * 判断目标的位置 */ else if(node.left!=null&amp;&amp;node.right!=null)&#123; node.element = findMin(node.right);//把右端最小的值放入！！！ node.right = remove(node.element, node.right); &#125; else node = (node.left==null)? node.right:node.left; return node; &#125; /** * 打印出树 */ public void printTree() &#123; printTree(root, 0); &#125; private void printTree(AvlNode&lt;T&gt; node, int depth) &#123; if (node != null) &#123; String indent = ""; for (int i = 0; i &lt; depth; i++) &#123; indent += " "; &#125; printTree(node.right, depth + 1); System.out.println(indent+node.element.toString()); printTree(node.left, depth + 1); &#125; &#125;&#125; remove 方法删除策略：如果节点含有两个子节点，一般用其右子树的最小的数据代替该节点的数据并且递归的删除那个节点，因为右子树中的最小的节点不可能有左儿子，所以第二次remove要容易些。上述程序尽管完成了删除的操作 ，但是效率并不高，因为它沿着该树进行了两趟搜索以查找和删除右子树中最小的节点，通过写一个特殊的removeMin方法可以改善。开始的位置即目标节点的右节点（不管有没有都可传入）。此时避免了从头开始搜索。 123456789101112131415/** * 从指定的Node开始查找，并删除最小的node值 * @param node * @return */ public void removeMin(BinaryNode&lt;T&gt; node)&#123; if(node == null) return; if(node.left==null)&#123; node.element = node.right.element; removeMin(node.right); &#125; else if (node.left!=null) removeMin(node.left); &#125; 烧脑！！ 4.3.5 平均情况分析一颗树的所有节点的深度的和称为内部路径长（internal path length）。经数学推到推知N个节点的内部路径长D(N) = O(N logN)，任意节点个数预期的深度为O(N)。对于标准二叉查找树算法，在没有删除或者使用懒惰删除（lazy deletion）的情况下，可以断言：基本操作所花费的时间为O(LogN)。许多一般的算法都能实现平衡树（balance tree），但是大部分算法都要比标准的二叉查找树复杂的多，而且更新要平均花费更长的时间。不过他们确实防止了处理起来非常麻烦的一些简单情形，下面将学习AVL树。较新的算法是放弃了平衡条件，允许树有任意的深度，但在每次操作之后要使用一个调整规则进行调整，使得最后的操作效率要高。这种类型的数据结构一般属于自调整（self-adjusting）类结构。此类结构叫伸展树（splay tree），11章将进行讨论。 4.4 AVL树AVL树是具有平衡条件（balance condition）的二叉查找树。这种平衡条件必须要容易保持，而且它保证树的深度须是O(LogN)。其平衡条件是：其每个节点的左子树和右子树的高度最多相差1（空树的高度定义为-1）。当对AVL插入数据时候，可能会破坏其平衡，这个时候需要简单的修正，称为旋转（rotation）。破坏平衡出现的四种情况，有且仅有四种： 左左，左右，右左，右右 即对a的左节点的左子树的一次插入。 分类：外边的情况，左左、右右 解决办法：单旋转（single rotation） 分类：内部的情况。左右、右左 解决办法：双旋转（double rotation） 4.4.1 单旋转不满足AVL平衡性质的节点与较长链的下一节点旋转交换，子节点转移。只适合左左或者右右的不平衡情况。示例如下图：出旋转引起的局部变化以外，书的其余部分必须被告知该变化，如下图中的2节点的右节点变为了4。 4.4.2 双旋转 左右或右左的情况，两次旋转。 AVL树的Java实现关键在于：单双旋转的代码实现，在insert和remove操作之后插入balance操作。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199public class AvlTree&lt;T extends Comparable&lt;? super T&gt;&gt; &#123; private static class AvlNode&lt;T&gt; &#123; public T element; public AvlNode&lt;T&gt; left; public AvlNode&lt;T&gt; right; int height; public AvlNode(T element, AvlNode&lt;T&gt; left, AvlNode&lt;T&gt; right) &#123; super(); this.element = element; this.left = left; this.right = right; height = 0; &#125; public AvlNode(T element) &#123; this(element, null, null); &#125; &#125; private AvlNode&lt;T&gt; root; public AvlTree() &#123; makeEmpty(); &#125; public boolean isEmpty() &#123; return root == null; &#125; public void makeEmpty() &#123; root = null; &#125; private int height(AvlNode&lt;T&gt; node) &#123; return (node == null) ? -1 : node.height; &#125; public void insert(T element) &#123; root = insert(element, root); &#125; public void remove(T element) &#123; root = remove(element, root); &#125; private AvlNode&lt;T&gt; remove(T element, AvlNode&lt;T&gt; node) &#123; if (node == null) return node; int compareResult = element.compareTo(node.element); if (compareResult &lt; 0) node.left = remove(element, node.left); else if (compareResult &gt; 0) node.right = remove(element, node.right); /** * 判断目标的位置 */ else if (node.left != null &amp;&amp; node.right != null) &#123; node.element = findMin(node.right);// 把右端最小的值放入！！！ node.right = remove(node.element, node.right); // removeMin(node.right); &#125; else node = (node.left == null) ? node.right : node.left; return balance(node); &#125; public T findMin() &#123; if (isEmpty()) try &#123; throw new Exception(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return findMin(root); &#125; private T findMin(AvlNode&lt;T&gt; node) &#123; return (node.left == null) ? node.element : findMin(node.left); &#125; public T findMax() &#123; if (isEmpty()) try &#123; throw new Exception(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return findMax(root); &#125; public boolean contains(T element) &#123; return contains(root, element); &#125; private boolean contains(AvlNode&lt;T&gt; node, T element) &#123; if (node == null) return false; int compareResult = element.compareTo(node.element); if (compareResult &lt; 0) return contains(node.left, element); if (compareResult &gt; 0) return contains(node.right, element); return true; &#125; private T findMax(AvlNode&lt;T&gt; node) &#123; return (node.right == null) ? node.element : findMin(node.right); &#125; private AvlNode&lt;T&gt; insert(T element, AvlNode&lt;T&gt; node) &#123; if (node == null) return new AvlNode&lt;T&gt;(element); int compareResult = element.compareTo(node.element); if (compareResult &lt; 0) node.left = insert(element, node.left); if (compareResult &gt; 0) node.right = insert(element, node.right); else ;// 重复插入，不做操作 return balance(node); &#125; /** * 平衡操作 * * @param node * @return */ private static final int ALLOWED_IMBALANCE = 1; private AvlNode&lt;T&gt; balance(AvlNode&lt;T&gt; node) &#123; /* * 四种不平衡的解决办法 */ if (node == null) return node; if (height(node.left) - height(node.right) &gt; ALLOWED_IMBALANCE) if (height(node.left.left) &gt;= height(node.left.right)) node = rotateWithLeftChild(node); else node = doubleWithLeftChild(node); else if (height(node.right) - height(node.left) &gt; ALLOWED_IMBALANCE) if (height(node.right.right) &gt;= height(node.right.left)) node = rotateWithRightChild(node); else node = doubleWithRightChild(node); node.height = Math.max(height(node.left), height(node.right)) + 1; return node; &#125; private AvlNode&lt;T&gt; rotateWithLeftChild(AvlNode&lt;T&gt; k2) &#123; AvlNode&lt;T&gt; k1 = k2.left; k2.left = k1.right; k1.right = k2; k2.height = Math.max(height(k2.left), height(k2.right)) + 1; k1.height = Math.max(height(k1.left), k2.height) + 1; return k1; &#125; private AvlNode&lt;T&gt; rotateWithRightChild(AvlNode&lt;T&gt; k1) &#123; AvlNode&lt;T&gt; k2 = k1.right; k1.right = k2.left; k2.left = k1; k1.height = Math.max(height(k1.left), height(k1.right)) + 1; k2.height = Math.max(height(k2.right), k1.height) + 1; return k2; &#125; private AvlNode&lt;T&gt; doubleWithLeftChild(AvlNode&lt;T&gt; k3) &#123; k3.left = rotateWithRightChild(k3.left); return rotateWithLeftChild(k3); &#125; private AvlNode&lt;T&gt; doubleWithRightChild(AvlNode&lt;T&gt; k1) &#123; k1.right = rotateWithLeftChild(k1.right); return rotateWithRightChild(k1); &#125; public void printTree() &#123; printTree(root, 0); &#125; private void printTree(AvlNode&lt;T&gt; node, int depth) &#123; if (node != null) &#123; String indent = ""; for (int i = 0; i &lt; depth; i++) &#123; indent += " "; &#125; printTree(node.right, depth + 1); System.out.println(indent+node.element.toString()); printTree(node.left, depth + 1); &#125; &#125;&#125; 4.5 伸展树基本想法：当一个节点被访问以后，它就要经过一系列的AVL树的旋转被推到根上。如果某个节点很深，其访问路径上就包含很多相对也较深的节点，通过重新构造可以减少对这些节点的访问花费的时间。因此如果节点很深，就需要重新构造。 此外，伸展树不要求保留高度或平衡信息。 4.6 树的遍历中序遍历：123456789101112131415public void printTree() &#123; printTree(root, 0);&#125;private void printTree(AvlNode&lt;T&gt; node, int depth) &#123; if (node != null) &#123; String indent = ""; for (int i = 0; i &lt; depth; i++) &#123; indent += " "; &#125; printTree(node.right, depth + 1); System.out.println(indent+node.element.toString()); printTree(node.left, depth + 1); &#125;&#125; 4.7 B树当设计到I/O交互时候，磁盘访问速度限制了程序的执行速度，不平衡的二叉查找树具有线性的深度，需要更多次的磁盘访问。最差：随机构造的树，深三倍。其次：不平衡的二叉查找树。再其次：AVL树。解决办法：复杂的程序换取合适的结构，减少机械访问磁盘的次数从而提高运行的效率。随着分支的增加，相同节点的深度在减少，具体是LogmN（m为分支数）。阶为M的B树是一棵具有下列特性的树： 数据项存储在树叶上。 非叶节点存储知道M-1个关键字以指示搜索的方向；关键字i代表子树i+1中的最小的关键字。 树的根或者是一片树叶，或者其儿子数在2-M之间。（2是分裂的结果） 除根外，所有非树叶节点的儿子数在【M/2】和M之间。 所有的树叶都在相同的深度上并有【L/2】和L之间个数据项，L和M根据所存储的项的大小确定，深度在存储的过程中进行分裂、借子、合并等操作改变。 4.8 标准库中的集合与映射4.8.1 Set接口4.8.2 Map接口小结查找树：对数平均开销很小，查找树的非递归实现要快一些，但是递归更巧妙和精彩。查找树的问题在于，如果输入不随机，将会退化成昂贵的链表结构。AVL树有平衡限制，保证树不会太深，改变结构后要重新平衡。伸展树，一个节点被访问后被推知根部，节省了多次访问节点的消耗。但实际效果是，任意M次访问消耗O(M logN)，与平衡树花费相同。B树，多阶的平衡M路树，能有效的减少深度，适应磁盘操作。实践中，任何平衡树方案的插入和删除都不如简单二叉查找树省时，但是平衡的约束可以防止轻易得到最坏情形的输入。通过中序遍历得到的是排序的元素，这给出了一种O(N log N)算法。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构与算法分析</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法分析</tag>
        <tag>二叉查找树</tag>
        <tag>AVL树</tag>
        <tag>B树</tag>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法分析（JAVA描述）（第十二章 高级数据结构及其实现）]]></title>
    <url>%2F2019%2F02%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%88JAVA%E6%8F%8F%E8%BF%B0%EF%BC%89%EF%BC%88%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构与算法分析（JAVA描述）（第十二章 高级数据结构及其实现） 个人笔记，如有错误，恳请批评指正。 红黑树红黑树的每个节点上都有存储位表示节点的颜色，颜色是红(Red)或黑(Black)。红黑树的特性: (1) 每个节点或者是黑色，或者是红色。 (2) 根节点是黑色。 (3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！] (4) 如果一个节点是红色的，则它的子节点必须是黑色的。 (5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 关于它的特性，需要注意的是：第一，特性(3)中的叶子节点，是只为空(NIL或null)的节点。第二，特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构与算法分析</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法分析</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法分析（JAVA描述）（第三章 表、栈和队列）]]></title>
    <url>%2F2019%2F02%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%88JAVA%E6%8F%8F%E8%BF%B0%EF%BC%89%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E8%A1%A8%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构与算法分析（JAVA描述）（第三章 表、栈和队列）表、栈和队列个人笔记，如有错误，恳请批评指正。 3.1 抽象类型数据抽象数据类型（abstract data type ADT）是带有一组操作的一些对象的集合。诸如表、集合、图以及与他们各自的操作一起形成的这些对象都可以看做是抽象数据类型。 3.2 表ADT功能操作： printList makeEmpty find： 首次出现的index insert/remove findKth： 返回某个位置上的元素 next/previous 3.2.1 表的简单数组实现数组实现表的结构，容量是固定的，需要时候可以进行扩容，即新建一个数组并赋值，适合高端操作和查询。数组实现的缺点，增删发生在前端进行，需花费较多的时间O(N)。解决的另外一种数据结构：链表结构（linked list）。 3.2.2 简单链表为了避免增删操作中的线性开销，我们需要保证表可以不连续储存，否则表的各个部分可能需要整体移动。链表由一系列节点组成，这些节点不必要在内存中连续。每个节点包含表元素和到包含该元素后继元的节点的链（link），我们称之为next链，最后一个单元的next链引用null；printList和find操作和数组实现一样，遍历花耗线性时间。findKth操作不如数组实现的效率高，findKth(i)需要花费O(i)的时间，而数组只需花费O(1)的时间。remove操作通过修改next链的引用实现，比如要删除A3，即可修改A2的引用到A4。insert方法需要使用new操作符从系统获取一个新的节点，此后执行两次引用的调整，比如在A2和A3中插入新的Ax元素，即可将A2的引用修改为Ax，Ax的引用指向A3。链表结构的优点是增删快，然而在经典的链表中，每个节点均存储到其下一节点的链，而拥有指向最后节点的链并不提供最后节点的前驱节点的任何信息，即删除最后一项在找到它的环节上遇到了困难，好的做法是：让每个节点持有一个指向它在表中的前驱节点的链，这样的结构称为双链表（doubly linked list）。 3.3 Java Collection API中的表Java中普通数据结构的实现，表APT是Collelction API 中实现的数据结构之一，第四章介绍其他的数据结构、 3.3.1 Collection接口集合类接口，该接口拓展了Iterable接口，实现Iterable接口的集合类拥有增强for循环。 3.3.2 Iterator接口实现该接口需要提供iterator的方法，返回Iterator的对象，next/hasNext/remove的方法，iterator的remove可以删除有next最新返回的项。注意：对正在被迭代的集合进行结构上的改变（改变个数 add，clear，remove）是不合法的（抛出ConcurrentModificationException）。iterator的remove操作却是合法的。因为iterator自己内部维护这关于集合结构的变量。外部的操作会导致异常。 3.3.3 List接口、ArrayList类和LinkedList类重要的方法 ： get/set/add/remove。指定了listIterator方法，产生比通常认为还要复杂的迭代器。将在3.3.5中讨论。 ArrayList特点：查询快，增删慢。 LinkedListt特点：查询慢，增删快，双链表！特有的方法：addFirst/removeFirst/addLast/removeLastlinkedList的迭代器Iterator可以提高LinkedList遍历的效率。对搜索而言，ArrayList和LinkedList都是低效的。 3.3.4 例子：remove方法对LinkedList类的使用需求：清除集合中的偶数项。方法1：get、remove操作。缺点：Arraylist的remove效率低下，LinkedList的get效率低下，remove的调用同样低下，因为达到位置i的代价是昂贵的。方法2：for循环+remove，底层使用了迭代器了，但是collection的remove同样低效，因为存在着先搜索再删除，并且，for循环底层用来迭代器，这样在remove改变了数据结构以后，会抛出ConcurrentModificationException的异常！！方法3：iterator+iterator’s remove，对LinkedList是高效的，对ArrayList，remove操作同样需要花费二次时间。 3.3.5 关于ListIterator接口123456789101112public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); boolean hasPrevious(); E previous(); int nextIndex(); int previousIndex(); void remove(); void set(E e); void add(E e);&#125; 3.4 ArrayList类的实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** * 自定义ArrayList类，具备： * 1、容量机制 * 2、get/set的实现 * 3、size|isEmpty|clear|remove|add * 4、iterator返回Iterator接口的实现类，并提供next,hasnext,remove等方法的实现 * @author Wch * * @param &lt;T&gt; 泛型类 */public class MyArrayList&lt;T&gt; implements Iterable&lt;T&gt; &#123; private static final int DEFAULT_CAPACITY = 10; private int theSize;//初始为0，只有add操作后会自增 private T[] theItems;//初始为DEFAULT_CAPACITY public MyArrayList() &#123; super(); theSize = 0; ensureCapacity(DEFAULT_CAPACITY); &#125; public int size()&#123; return theSize; &#125; public boolean isEmpty()&#123; return size() == 0; &#125; public void clear()&#123;//清除集合 theSize = 0; theItems = (T[]) new Object[DEFAULT_CAPACITY]; &#125; public T set(int index,T obj)&#123;//新增,返回改位置原来的值 if(index&lt;0||index&gt;size()-1) throw new ArrayIndexOutOfBoundsException(); T old = theItems[index]; theItems[index] = obj; return old; &#125; public T get(int idx)&#123;//返回idx处的元素 if(idx&lt;0||idx&gt;size()-1) throw new ArrayIndexOutOfBoundsException(); return theItems[idx]; &#125; public void trimToSize()&#123;//修剪，减少无畏容量消耗 ensureCapacity(size()); &#125; private void ensureCapacity(int newCapacity) &#123;//扩容 if(size()&gt;newCapacity) return; T[] old = theItems; theItems = (T[]) new Object[newCapacity]; for(int i = 0;i&lt;theSize;i++)&#123; theItems[i] = old[i]; &#125; &#125; public boolean add(T obj)&#123;//末尾添加，若容量不够，需要扩容 add(size(),obj); return true; &#125; private void add(int idx,T obj)&#123; if(theItems.length == idx)//超 &#123; int newCapacity = (theSize*2)+1;//2倍+1，+1用于size=0的情形 ensureCapacity(newCapacity); &#125; theItems[idx] = obj; theSize++; &#125; public T remove(int idx)&#123; if(idx&lt;0||idx&gt;size()-1) throw new ArrayIndexOutOfBoundsException(); T removeItem = theItems[idx]; for(int i = idx;i&lt;size()-1;i++)&#123;//整体前移 theItems[i] = theItems[i+1]; &#125; theSize--; return removeItem; &#125; public Iterator&lt;T&gt; iterator() &#123; return new ArrayListIterator(); &#125; /** *迭代器是一个内部类并存储当前位置和一个连接到MyArrayList的隐式链！ */ private class ArrayListIterator implements Iterator&lt;T&gt;&#123;//内部类定义ArrayListIterator private int current;//储存了当前的位置信息，每next一次，++一次，remove则-- public boolean hasNext() &#123; return current&lt;size(); &#125; public T next() &#123; if(!hasNext()) throw new NoSuchElementException(); return theItems[current++]; &#125; public void remove() &#123; MyArrayList.this.remove(--current); &#125; &#125;&#125; class文件中编译器对源文件进行的编译： 1234567891011121314151617181920212223242526272829private class ArrayListIterator implements Iterator&lt;T&gt; &#123; private int current; private ArrayListIterator() &#123;&#125; public boolean hasNext() &#123; return this.current &lt; MyArrayList.this.size(); &#125; public T next() &#123; if (!hasNext()) &#123; throw new NoSuchElementException(); &#125; /* 编译器会编写是内部类对象和外部类对象相关联所需要的附加代码 */ return (T)MyArrayList.this.theItems[(this.current++)];//return theItems[current++]; &#125; public void remove() &#123; MyArrayList.this.remove(--this.current); &#125; &#125;&#125; 3.4.2 迭代器、Java嵌套类和内部类内部类可以访问内部的私有成员变量，这也是上述例程中为何ArrayListIterator能next操作的原因。如果不利用内部类，则需要在不同的类中相互存在引用，并且要改变变量的可见性（如public，默认的，同一个包中可见，包可见性（package visibility）），不过这违反了良好的面向对象的编程的基本原则。嵌套类当在外部类中用static声明一个类时候，得到外部类（outer class），若无static，则是内部类（inner class）。嵌套类可以被设计成private，此时除外部类以外的其他类不可访问。嵌套类的缺点，由于static的原因，编译器在编译的时候事先编译嵌套类，如果嵌套类引用了外部类中的成员变量，而外部类只有在被实例化时才被编译。内部类当声明一个内部类时，编译器则添加对外部类对象的一个隐式引用，该对象引起内部类对象的构造。Outer.this引用的是内部类的外部类。 3.5 LinkedList类的实现 List是一种数据结构，这种数据结构已经规定了其功能就是按照顺序排放数据的。这点是你我都无法改变的了。不过具体的顺序还有：顺序排放，链表排放等。Map也是一种数据结构，这种数据结构规定了一个key必须对应一个value。有些Map的实现是无序的，例如：HashMap；有些Map的实现是有序的，例如：LinkedHashMap和TreeMap。 链表排放的实现： 使用了头节点（header node）和尾节点（tail node），这些额外的节点的优点在于，通过排除许多特殊情形极大地简化了编码。头节点和尾节点只用作定位，不用做存储数据。 维护了modCount，在迭代器生成以后，迭代器中的iteratorModCount和modCount要保持一致，若非法的结构修改会导致抛出ConcurrentModificationException异常。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163package cn.ustb.chapter3;import java.util.ConcurrentModificationException;import java.util.Iterator;import java.util.NoSuchElementException;import javax.resource.spi.IllegalStateException;/** * 自定义LinkedList结构，具备： * 1、MyLinkedList类本身，包含到两端的链，表的大小，一些方法 * 2、Node类，节点类，私有的嵌套类。包含数据、到前一节点的链和到后一节点的链，还有一些适当的构造方法 * 3、LinkedListIterator类，抽象了位置的概念，是一个私有类，并实现了Iterator接口，提供next等方法。 * @author Wch * * @param &lt;T&gt; */public class MyLinkedList&lt;T&gt; implements Iterable&lt;T&gt; &#123; private int size; private Node&lt;T&gt; beginMarker;//头结点 private Node&lt;T&gt; endMarker;//尾节点 private int modCount;//维护修改次数的变量 /** * 节点类：data，上链，下链 */ private static class Node&lt;T&gt;&#123; public Node(T data, Node&lt;T&gt; next, Node&lt;T&gt; pre) &#123; super(); this.data = data; this.next = next; this.pre = pre; &#125; public T data; public Node&lt;T&gt; next; public Node&lt;T&gt; pre; &#125; public MyLinkedList() &#123; doclear(); &#125; public void clear()&#123; doclear(); &#125; private void doclear() &#123; beginMarker = new Node&lt;T&gt;(null, null, null); endMarker = new Node&lt;T&gt;(null, null, null);//从这里可以看出。头结点和尾节点只作为定位用，不存储数据 beginMarker.next = endMarker; endMarker.pre = beginMarker; size = 0; modCount = 0; &#125; public int size()&#123;return size;&#125; public boolean isEmpty()&#123;return size==0;&#125; public boolean add(T data)&#123;add(size(),data);return true;&#125;//添加 private void add(int size, T data) &#123;//添加到最后 addBefore(getNode(size,0,size()),data); &#125; public T get(int idx)&#123;return getNode(idx).data;&#125; public T set(int idx,T newData)&#123;//更行idx出的数据，返回旧数据 Node&lt;T&gt; p = getNode(idx); T old = p.data; p.data = newData; return old; &#125; public T remove(int idx)&#123; return remove(getNode(idx)); &#125; /** * 删除指定的节点 * @param p * @return */ private T remove(Node&lt;T&gt; p)&#123; Node&lt;T&gt; next = p.next; Node&lt;T&gt; pre = p.pre; next.pre = pre; pre.next = next; size--; modCount++; return p.data; &#125; /** * 根据index获取到节点 * @param idx 指定index位置 * @param lower 开始位置 * @param upper 结束位置 * @return */ private Node&lt;T&gt; getNode(int idx, int lower, int upper) &#123; Node&lt;T&gt; p = beginMarker; if(idx&lt;lower||idx&gt;upper) throw new IndexOutOfBoundsException(); for(int i = 0;i&lt;=idx;i++)//依次遍历，从beginMarker开始遍历，到指定index位置返回node。 //实际上链表结构中不存在index，这也是为什么查询操作效率低下的原因。必要时可以先判断，将遍历区间先对折。 p = p.next; return p; &#125; private Node&lt;T&gt; getNode(int idx)&#123; return getNode(idx,0,size()); &#125; /** * 添加数据到指定节点之前 * @param p 指定节点 * @param data */ private void addBefore(Node&lt;T&gt; p,T data)&#123;//添加到指定节点的前面 Node&lt;T&gt; newNode = new Node(data,p,p.pre);//data,next,pre p.pre.next = newNode;//修改后节点的前链 p.pre = newNode;//修改前节点的后链 size++; modCount++;//改变了数据结构，需要增加modCount的次数 &#125; /** * 迭代器操作 */ public Iterator&lt;T&gt; iterator() &#123; return new LinkedListIterator(); &#125; /** * @author Wch */ private class LinkedListIterator implements Iterator&lt;T&gt;&#123; private int iteratorModCount = modCount; private Node&lt;T&gt; current = beginMarker.next; private boolean okToRemove = false;//表示是否可以删除次节点，防止删除掉头结点和尾节点 public boolean hasNext() &#123; return current != endMarker; &#125; public T next() &#123; if(iteratorModCount != modCount) throw new ConcurrentModificationException();//验证是否存非法的结构修改 if(!hasNext()) throw new NoSuchElementException();//验证是否还有next元素 T t = current.data; current = current.next; okToRemove = true;//可以删除 return t; &#125; public void remove() &#123; if(modCount != iteratorModCount) throw new ConcurrentModificationException();//验证是否存非法的结构修改 if(!okToRemove)//不能删除了，即不存在普通节点了 try &#123; throw new IllegalStateException(); &#125; catch (IllegalStateException e) &#123; e.printStackTrace(); &#125; MyLinkedList.this.remove(current.pre); iteratorModCount++;//与remove方法中的modCount同步更新 okToRemove = false;//只有next才能判断是否还可以继续删除 &#125; &#125;&#125; 3.6 栈ADT3.6.1 栈模型栈（stack）是限制插入和删除只能在一个地方进行的表，该位置是表的末端，叫做栈顶（top）。基本操作：push（进栈），pop（出栈）。对空栈进行pop或top一般被认为是错误操作；另一方面，当运行push时空间用尽是一个实现限制，但不是一个错误。栈有时候称作LIFO（后进先出表）表。存在于栈顶的元素是栈中唯一可见的元素。 3.6.2 栈的实现栈是一个表，因此任何实现表的方法都能实现栈。两个非常流行的实现方法：链式结构和数组结构，均简化了在LinkedList和ArrayList中的逻辑。 栈的链表实现栈的第一种实现方法是使用单链表。push：插入insert；pop：删除remove；top：查询栈顶元素，但是不删除。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 栈的单链表实现 * @author Wch * */public class ArrayListSatck&lt;T&gt; &#123; private int theSize; private ArrayList&lt;T&gt; theItems; private static final int DEFAULT_CAPACITY = 10; public ArrayListSatck() &#123; doclear(); &#125; public void clear()&#123; doclear(); &#125; private void doclear() &#123; theSize = 0; ensureCapacity(DEFAULT_CAPACITY); &#125; public int size()&#123; return theSize; &#125; public boolean isEmpty()&#123; return theSize == 0; &#125; private void ensureCapacity(int newCapacity) &#123; if(newCapacity&lt;theSize) return; ArrayList&lt;T&gt; newItems = new ArrayList&lt;T&gt;(newCapacity); for(int i = 0;i&lt;size();i++) newItems.add(i, theItems.get(i)); theItems = newItems; &#125; public void push(T element)&#123; if(theItems.size() == theSize) ensureCapacity(theItems.size()*2+1); theItems.add(theSize++,element); &#125; public T pop()&#123; if(theSize == 0) return null; return theItems.get(--theSize); &#125; public static void main(String[] args) &#123; ArrayListSatck&lt;Integer&gt; als = new ArrayListSatck&lt;Integer&gt;(); System.out.println(als.size()); als.push(1); System.out.println(als.size()); als.push(2); als.push(3); als.push(4); als.push(5); als.push(8); System.out.println(als.pop()); System.out.println(als.pop()); System.out.println(als.pop()); System.out.println(als.pop()); System.out.println(als.pop()); System.out.println(als.pop()); System.out.println(als.pop()); &#125;&#125; 栈的数组实现模仿了ArrayList的add实现，利用topOfStack进行定位操作。操作非常迅速。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 数组模拟栈操作 * @author Wch * */public class ArrayStack&lt;T&gt; &#123; private int theSize; private T[] theItems; private static final int DEFAULT_SIZE = 10; public ArrayStack() &#123; doclear(); &#125; public void clear()&#123; doclear(); &#125; public void doclear()&#123; theSize = 0; ensureCapacity(DEFAULT_SIZE); &#125; private void ensureCapacity(int newCapacity) &#123; if(newCapacity&lt;theSize) return ; T[] newItems = (T[]) new Object[newCapacity]; for(int i = 0;i&lt;size();i++)&#123; newItems[i] = theItems[i]; &#125; this.theItems = newItems; &#125; public boolean isEmpty()&#123; return size() == 0; &#125; public int size()&#123; return theSize; &#125; public void push(T element)&#123; if(theItems.length == size()) ensureCapacity(size()*2+1); theItems[theSize++] = element; &#125; public T pop()&#123; if(theSize == 0) return null; return theItems[--theSize]; &#125; public static void main(String[] args) &#123; ArrayStack&lt;Integer&gt; s = new ArrayStack&lt;Integer&gt;(); System.out.println(s.size()); s.push(1); s.push(2); s.push(3); s.push(4); System.out.println(s.size()); System.out.println(s.pop()); System.out.println(s.size()); &#125;&#125; 3.6.3 应用 平衡符号需求：检测括号是否完整。 做一个空栈。读入字符直到文件结尾，如果是字符是一个开放符号，则推入栈中。如果字符是一个封闭符号，则当栈空时报错。否则，弹出栈元素，若不能匹配上对应的封闭符号则报错。在文件的结尾处，如果栈非空则报错。 后缀表达式后缀（postfix）或逆波兰（reverse polish）记法。改记法不需要知道优先的规则，处理速度快。规则：扫描到数字，压入栈中，扫描到运算符，弹出两个数字运算，并将结果再次压入。 6 5 2 3 + 8 + 3 + 6 5 5 8 + 3 + 6 5 40 + 3 + * 6 45 3 + * 6 48 * 288 中缀到后缀的转换尾递归（tail recursion），尾递归涉及在最后一行的递归调用，可通过while（true）解决。 3.7 队列ADT队列（queue）也是表，一端进一端出。 3.7.1 队列模型基本操作时enqueue（入队），它是在表的末端（队尾rear）插入一个元素。出队（dequeue），它是删除并返回表的开头（队头front）的元素、 3.7.2 队列的数组实现队列的链表实现：add，removeFirst数组实现：循环数组（circular array），只要front或者back到达数组的末端，它就又回到开头，当back = front -1 时，队列为空。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 循环数组实现队列模型 * enqueue:入队 offer * dequeue:出队 poll * @author Wch * * @param &lt;T&gt; */public class CirArrayQueue&lt;T&gt; &#123; private T[] theItems; private int front;//前指针 private int back;//后指针 private int theSize; private static final int DEFAULT_CAPACITY = 10; public CirArrayQueue() &#123; doclear(); &#125; public void clear()&#123; doclear(); &#125; public int size()&#123; return theSize; &#125; public boolean isEmpty()&#123; return size()==0; &#125; private void doclear()&#123; front = back = theSize = 0; theItems = (T[]) new Object[DEFAULT_CAPACITY]; &#125; /** * 循环数组，当后标大于size时候回到开头 * @param element */ public void enqueue(T element)&#123; theSize++; if(back&gt;theItems.length) back = 0; theItems[back++] = element; &#125; public T dequeue()&#123; if(isEmpty()) return null; theSize--; return theItems[front++]; &#125;&#125; 小结描述了一些ADT的概念，并且利用最常见的表ADT，栈ADT，队列ADT阐述了这种概念。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构与算法分析</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法分析</tag>
        <tag>链表</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法分析（JAVA描述）（第七章 排序）]]></title>
    <url>%2F2019%2F02%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%88JAVA%E6%8F%8F%E8%BF%B0%EF%BC%89%EF%BC%88%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构与算法分析（JAVA描述）（第七章 排序）插入排序、希尔排序、归并排序、堆排序、快速排序 个人笔记，如有错误，恳请批评指正。 7.2 插入排序（insertion sort）位置p上的元素存储于temp，而所有更大的元素都被向右移动一个位置，然后temp被置于正确的位置上。左滤？这是与在二叉堆实现时所用到的相同技巧。 Java实现123456789101112/***插入排序*/public static &lt;T extends Comparable&gt; void insertionSort(T[] a)&#123; int j; for(int p = 1;p&lt;a.length;p++)&#123; T temp = a[p]; for(j = p;j&gt;0&amp;&amp;temp.compareTo(a[j-1])&lt;0;j--)//从前往后有序 a[j] = a[j-1]; a[j] = temp; &#125; &#125; 7.3 一些简单排序算法的下界 定理7.1 N个互异数的数组的平均逆序数是N(N-1)/4。这个定理意味着插入排序平均是二次的，同时也提供了只交换相邻元素的任何算法的一个很强的下界。 定理7.2 通过交换相邻元素进行排序的任何算法平均都需要Ω（N^2）时间。为了使一个算法以亚二次时间运行，必须执行一些比较，特别要对相距较远的元素进行交换，一个排序算法通过删除逆序得以向前进行，而为了有效地进行，必须使每次交换删除不止一个逆序。 7.4 希尔排序（Shellsort）———–冲破二次时间屏障的第一批算法之一。希尔排序通过比较相距一定间隔的元素来工作，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。由于这个原因，希尔排序有时候也叫做缩减增量排序（diminishing increment sort）。希尔排序使用一个序列h1,h2,h3…ht,叫做增量序列（increment sequence）。具体的排序规则是，经过一次hk排序以后有：a[i]&lt;=a[i+hk]。所有相隔hk的元素都被排序。希尔排序的一个重要性质是：一个hk排序的文件保持它的hk排序性。序列对拍的性能影响巨大，增量序列使用shell建议的序列是：ht = [N/2]和hk = [h(k+1) /2]。 Java实现12345678910111213141516171819202122232425262728293031/** * 希尔排序 * @param a */ public static &lt;T extends Comparable&gt; void shellSort(T[] a)&#123; int j; for(int gap = a.length/2;gap&gt;0;gap /= 2)//确定序列 for(int i = gap;i&lt;a.length;i++)&#123; T temp = a[i]; for(j = i;j&gt;=gap&amp;&amp;temp.compareTo(a[j-gap])&lt;0;j -= gap) a[j] = a[j-gap]; a[j] = temp; &#125; &#125; /** * 希尔排序2 * @param a */ public static &lt;T extends Comparable&gt; void sort(T[] a)&#123; int j; for(int gap = a.length/2;gap&gt;=1;gap /= 2) for(int i = gap;i&lt;a.length;i++)&#123; for(j = i;j-gap&gt;=0;j -= gap)&#123; if(a[j].compareTo(a[j-gap])&lt;0)&#123; T temp = a[j]; a[j] = a[j-gap]; a[j-gap] = temp; &#125; &#125; &#125; &#125; 定理7.3 使用希尔排序时希尔排序的最坏情形运行时间为Θ(N^2)。 定理7.4 使用Hibbard增量的希尔排序的最坏情形运行时间是Θ(N^3/2)。Hibbard增量：1,3,7，…，2^k-1 7.5 堆排序Java实现12345678910111213141516171819202122232425262728293031323334353637383940414243public class Demo2 &#123; public static &lt;T extends Comparable&gt; void heapSort(T[] a)&#123; for(int i = a.length-1;i&gt;=0;i--)&#123;//buildHeap a.length/2-1是最优 percDown(a,i,a.length); &#125; for(int i = a.length-1;i&gt;0;i--)&#123;//deleteMax&amp;&amp;buildHeap T temp = a[0]; a[0] = a[i]; a[i] = temp; percDown(a, 0, i); &#125; &#125; /** * 对i到n个元素进行堆排序 * @param a * @param i * @param n */ private static &lt;T extends Comparable&gt; void percDown(T[] a ,int i ,int n)&#123; int child; T temp; for(temp = a[i];leftChild(i)&lt;n;i = child)&#123; child = leftChild(i); if(child!=(n-1)&amp;&amp;a[child].compareTo(a[child+1])&lt;0) child++; if(temp.compareTo(a[child])&lt;0) a[i] = a[child]; else break; &#125; a[i] = temp; System.out.println(Arrays.toString(a)); &#125; private static int leftChild(int i)&#123;//这里不像二叉堆，二叉堆 时的数据在数组下标1处开始，这里从0开始。 return 2*i+1; &#125; public static void main(String[] args) &#123; Integer[] arr = &#123;1,54,21,456,23,6,523,8,7841,8,56,23&#125;; heapSort(arr); System.out.println(Arrays.toString(arr)); &#125;&#125; 7.6 归并排序（mergeSort）Java实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MergeSort &#123; public static &lt;T extends Comparable&gt; void mergeSort(T[] a)&#123; T[] arr = (T[]) new Comparable[a.length];//别 new Object mergeSort(a,arr,0,a.length-1); &#125; private static &lt;T extends Comparable&gt; void mergeSort(T[] a,T[] tempArr,int left,int right)&#123; if(left&lt;right)&#123; int center = (left+right)/2; mergeSort(a,tempArr,left,center); mergeSort(a,tempArr,center+1,right); merge(a,tempArr,left,center+1,right); &#125; &#125; /** * * @param a 源数组 * @param tempArr 临时数组，存储合并后的数组 * @param leftPos 左半部起始点 * @param rightPos 右半部起始点 * @param rightEnd 右半部结点 */ private static &lt;T extends Comparable&gt; void merge(T[] a,T[] tempArr,int leftPos,int rightPos,int rightEnd)&#123; int leftEnd = rightPos-1;//左半结点 int tempPos = leftPos;//临时数组指起始点 int tempSize = rightEnd-leftPos+1;//临时数组范围区间 while(leftPos&lt;=leftEnd&amp;&amp;rightPos&lt;=rightEnd)&#123; if(a[leftPos].compareTo(a[rightPos])&lt;=0) tempArr[tempPos++] = a[leftPos++]; else tempArr[tempPos++] = a[rightPos++]; &#125; while(rightPos&lt;=rightEnd)//左半为空 tempArr[tempPos++] = a[rightPos++]; while(leftPos&lt;=leftEnd)//右半为空 tempArr[tempPos++] = a[leftPos++]; //将tempArr的内容拷会源数组 for(int i = 0;i&lt;tempSize;i++)&#123; int index = rightEnd--; a[index] = tempArr[index]; &#125; System.out.println(Arrays.toString(a)); &#125; public static void main(String[] args) &#123; Integer[] arr = &#123;9,7,5,4,2,1,8,3&#125;; System.out.println(Arrays.toString(arr)); mergeSort(arr); System.out.println(Arrays.toString(arr)); &#125;&#125; 7.7 快速排序（quickSort）Java实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class QuickSort &#123; private static final int CUT_OFF = 10;//小于改规模用快排 public static &lt;T extends Comparable&gt; void quickSort(T[] a)&#123; quickSort(a,0,a.length-1); &#125; private static &lt;T extends Comparable&gt; void quickSort(T[] a,int left, int right)&#123; if(left+CUT_OFF&lt;=right)&#123; T pivot = midian3(a, left, right); int i = left; int j = right-1; while(true)&#123; while(a[++i].compareTo(pivot)&lt;0)&#123;&#125; while(a[--j].compareTo(pivot)&gt;0)&#123;&#125; if(i&lt;j) swapReference(a, i, j); else break; &#125; swapReference(a, i,right-1); quickSort(a,left,i-1);//对小数据继续排序 quickSort(a,i+1,right);//对大数据继续排序 &#125;else&#123; insertionSort(a,left,right);//快排 &#125; &#125; public static &lt;T extends Comparable&gt; void insertionSort(T[] a,int left,int right)&#123; int j; for(int p = left+1;p&lt;=right;p++)&#123; T temp = a[p]; for(j = p;j&gt;left&amp;&amp;temp.compareTo(a[j-1])&lt;0;j--) a[j] = a[j-1]; a[j] = temp; &#125; &#125; private static &lt;T extends Comparable&gt; T midian3(T[] a,int left,int right)&#123; int center = (left+right)/2; if(a[center].compareTo(a[left])&lt;0) swapReference(a, left, center); if(a[right].compareTo(a[left])&lt;0) swapReference(a, right, left); if(a[right].compareTo(a[center])&lt;0) swapReference(a, right, center); //枢纽换至最后一位 swapReference(a, center, right-1); return a[right-1];//返回枢纽 &#125; private static &lt;T extends Comparable&gt; void swapReference(T[] a,int i1,int i2)&#123; T temp = a[i1]; a[i1] = a[i2]; a[i2] = temp; System.out.println(Arrays.toString(a)); &#125; public static void main(String[] args) &#123;// Integer[] a = &#123;5,1,3&#125;;// midian3(a, 0, a.length-1); Integer[] arr = &#123;1,45,31,38,41,7,41,02,1520,4123,235,218564&#125;; System.out.println(Arrays.toString(arr)); quickSort(arr); System.out.println(Arrays.toString(arr)); &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构与算法分析</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法分析</tag>
        <tag>插入排序</tag>
        <tag>希尔排序</tag>
        <tag>归并排序</tag>
        <tag>堆排序</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法分析（JAVA描述）（第六章 优先队列 堆）]]></title>
    <url>%2F2019%2F02%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%88JAVA%E6%8F%8F%E8%BF%B0%EF%BC%89%EF%BC%88%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%20%E5%A0%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构与算法分析（JAVA描述）（第六章 优先队列 堆）堆，二叉堆，二项队列个人笔记，如有错误，恳请批评指正。 优先队列（priority queue）， 6.3 二叉堆（binary heap）两个性质：结构性、堆序性。 6.3.1 结构性质堆是一棵被完全填满的二叉树，有可能的例外是最底层，底层的元素从左到右填入，这样的结构称为完全二叉树（complete binary tree）。一个堆结构的框架将由一个（Comparable）数组和一个代表当前堆大小的整数组成。 6.3.2 堆序性质堆序性质（heap-order property）。最小的元素在根上，任意节点小于他的所有后裔 6.3.3 基本操作insert：使用的策略为上滤（percolate up），空穴上冒。deleteMin：删除一个元素时，在根处建立一个空穴，堆中的最后一个元素X必须移动到该堆的某个地方，具体的做法是将X置入沿着从根开始包含最小儿子的一条路径上的一个正确位置。空穴下滤（percolate down）； 二叉堆的数组实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124public class BinaryHeap&lt;T extends Comparable&lt;T&gt;&gt; &#123; private static final int DEFAULT_CAPACITY = 10; private int currentSize;//堆元素个数 private T[] array;//数组堆 public BinaryHeap() &#123; this(DEFAULT_CAPACITY); &#125; public BinaryHeap(int capacity)&#123; array = (T[]) new Comparable[capacity]; &#125; /** * 添加数组的构造方法 * @param items */ public BinaryHeap(T[] items) &#123; currentSize = items.length; array = (T[]) new Comparable[(currentSize+2)*11/10]; int i = 1; for (T t : items) array[i++] = t; buildHeap();//buildHeap &#125; /** * 构建二叉堆结构 */ private void buildHeap()&#123; for(int i = currentSize/2;i&gt;0;i--)//从下往上下滤，建立二叉堆 percolateDown(i); &#125; /** * 上滤 * @param element */ public void insert(T element)&#123;//重复元素也会插入 if(currentSize == array.length-1) enlargeArray(array.length*2+1); int hole = ++currentSize;//空穴位置 //空穴元素和父节点元素比较，父节点小，则交换;array[0]是必要赋值的，不然会nullException报错，hole/2得到父节点位置 for(array[0] = element;element.compareTo(array[hole/2])&lt;0;hole /= 2) array[hole] = array[hole/2]; array[hole] = element; &#125;; public T findMin()&#123; if(isEmpty()) throw new RuntimeException(); return array[1]; &#125;; public T deleteMin()&#123; if(isEmpty()) throw new RuntimeException(); T min = findMin(); array[1] = array[currentSize--];//将最后的元素先赋值到根，在进行判断，下滤 percolateDown(1);//1表示从1位置开始下滤，即空穴的位置 return min; &#125;; private void percolateDown(int hole)&#123; int child;//儿子的位置 //child = hole*2得到左儿子的位置，要确保只有一个儿子的情况此时 child = child+1 T temp = array[hole]; for(;hole * 2 &lt;= currentSize;hole = child)&#123; child = hole * 2; if(child != currentSize&amp;&amp; array[child+1].compareTo(array[child])&lt;0)//判断没有右儿子的情况 child++; if(array[child].compareTo(temp)&lt;0) array[hole] = array[child]; else break; &#125; array[hole] = temp; &#125; /** * 扩大Array * @param newSize */ private void enlargeArray(int newSize)&#123; T[] newArray = (T[]) new Comparable[newSize]; for(int i = 0;i&lt;array.length;i++) newArray[i] = array[i]; array = newArray; &#125; public boolean isEmpty()&#123; return currentSize == 0; &#125;; public void makeEmpty()&#123; currentSize = 0; int length = array.length; array = (T[]) new Object[length]; &#125;; /** * test */ public static void main(String[] args) &#123; BinaryHeap&lt;Integer&gt; binaryHeap = new BinaryHeap&lt;Integer&gt;(5); binaryHeap.insert(10); binaryHeap.insert(13); binaryHeap.insert(15); binaryHeap.insert(16); binaryHeap.insert(9); binaryHeap.insert(9); System.out.println(binaryHeap.currentSize); System.out.println(binaryHeap.deleteMin()); System.out.println(binaryHeap.deleteMin()); System.out.println(binaryHeap.deleteMin()); System.out.println(binaryHeap.deleteMin()); System.out.println("++++++++++++++++++++++++++++++++++++++++"); Integer[] arr = &#123;21,2,1,47,65,1236,6,3&#125;; BinaryHeap&lt;Integer&gt; b2 = new BinaryHeap&lt;Integer&gt;(arr); System.out.println(b2.deleteMin()); System.out.println(b2.deleteMin()); System.out.println(b2.deleteMin()); System.out.println(b2.deleteMin()); System.out.println(b2.deleteMin()); System.out.println(b2.deleteMin()); System.out.println(b2.deleteMin()); System.out.println(b2.deleteMin()); &#125;&#125; 下滤图解 堆的缺点：除了不能实施find操作外，堆实现最明显的缺点是：将两个堆合并成一个堆是困难的操作，这种附加的操作叫做合并（merge）。 6.8.1 二项队列结构二项队列（binomial queue）：不是一棵队列的树，而是队列的树的集合，称为森林（forest）。每一棵堆序树都是有约束的形式，叫做二项树（binomial tree）,每个高度至多存在一棵二项树。高度为0的二项树是一棵单节点树。高度为K的二项树由两个高度为K-1的二项树附接而成。 高度为K的二项树恰好有2^k个节点。 insert实际就是特殊情形的合并，因为我们只要创建一棵单节点树并执行一次合并即可。这种操作的最坏情形运行时间也是O(LogN)。 deleteMin可以通过首先找出一棵具有最小根的二项树来完成。 6.8.3 二项队列的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205package cn.ustb.chapter6;public class BinomialQueue&lt;T extends Comparable&gt; &#123; private int currentSize; private Node&lt;T&gt;[] theTrees; private static final int DEFAULT_TREES = 1; public BinomialQueue() &#123; theTrees = new Node[DEFAULT_TREES]; makeEmpty(); &#125; public BinomialQueue(T item) &#123; currentSize = 1; theTrees = new Node[1]; theTrees[0] = new Node(item, null, null); &#125; public void merge(BinomialQueue&lt;T&gt; rhs) &#123; if (this == rhs) return; currentSize += rhs.currentSize; if (currentSize &gt; capacity()) &#123; int newTreeNum = Math.max(theTrees.length, rhs.theTrees.length) + 1; expandCapacity(newTreeNum); &#125; Node&lt;T&gt; carry = null; for (int i = 0, j = 1; j &lt;= currentSize; i++, j *= 2) &#123; Node&lt;T&gt; t1 = theTrees[i]; Node&lt;T&gt; t2 = i &lt; rhs.theTrees.length ? rhs.theTrees[i] : null; int whichCase = t1 == null ? 0 : 1; whichCase += t2 == null ? 0 : 2; whichCase += carry == null ? 0 : 4; switch (whichCase) &#123; case 0: /* No trees */ case 1: /* Only this */ break; case 2: /* Only rhs */ theTrees[i] = t2; rhs.theTrees[i] = null; break; case 4: /* Only carry */ theTrees[i] = carry; carry = null; break; case 3: /* this and rhs */ carry = combineTrees(t1, t2); theTrees[i] = rhs.theTrees[i] = null; break; case 5: /* this and carry */ carry = combineTrees(t1, carry); theTrees[i] = null; break; case 6: /* rhs and carry */ carry = combineTrees(t2, carry); rhs.theTrees[i] = null; break; case 7: /* All three */ theTrees[i] = carry; carry = combineTrees(t1, t2); rhs.theTrees[i] = null; break; &#125; &#125; for (int k = 0; k &lt; rhs.theTrees.length; k++) rhs.theTrees[k] = null; rhs.currentSize = 0; &#125; public void insert(T element) &#123; merge(new BinomialQueue&lt;T&gt;(element)); &#125; public T findMin() &#123; if (isEmpty()) try &#123; throw new Exception(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return theTrees[findMinIndex()].element; &#125; public T deleteMin() &#123; int minIndex = findMinIndex(); T minItem = theTrees[minIndex].element; Node&lt;T&gt; deletedTree = theTrees[minIndex].leftChild; BinomialQueue&lt;T&gt; deletedQueue = new BinomialQueue&lt;T&gt;(); deletedQueue.expandCapacity(minIndex + 1); deletedQueue.currentSize = (1 &lt;&lt; minIndex) - 1; for (int j = minIndex - 1; j &gt;= 0; j--) &#123; deletedQueue.theTrees[j] = deletedTree; deletedTree = deletedTree.rightSibling; deletedQueue.theTrees[j].rightSibling = null; &#125; theTrees[minIndex] = null; currentSize -= deletedQueue.currentSize + 1; merge(deletedQueue); return minItem; &#125; public boolean isEmpty() &#123; return currentSize == 0; &#125; public void makeEmpty() &#123; currentSize = 0; for (int i = 0; i &lt; theTrees.length; i++) &#123; theTrees[i] = null; &#125; &#125; private int capacity() &#123; return (1 &lt;&lt; theTrees.length) - 1;// 返回节点数 高度为k的节点数为2^k &#125; private int findMinIndex() &#123; int i; int minIndex; for (i = 0; theTrees[i] == null; i++) ; for (minIndex = i; i &lt; theTrees.length; i++) &#123; if (theTrees[i] != null &amp;&amp; theTrees[i].element .compareTo(theTrees[minIndex].element) &lt; 0) &#123; minIndex = i; &#125; &#125; return minIndex; &#125; private void expandCapacity(int newCapacity) &#123; Node&lt;T&gt;[] old = theTrees; int oldTreeNum = old.length; theTrees = new Node[newCapacity]; for (int i = 0; i &lt; oldTreeNum; i++) theTrees[i] = old[i]; for (int i = oldTreeNum; i &lt; newCapacity; i++) theTrees[i] = null; &#125; private Node&lt;T&gt; combineTrees(Node&lt;T&gt; t1, Node&lt;T&gt; t2) &#123; if (t1.element.compareTo(t2.element) &gt; 0) return combineTrees(t2, t1); t2.rightSibling = t1.leftChild; t1.leftChild = t2; return t1; &#125; /** * 节点类 * * @author Wch * * @param &lt;T&gt; */ private static class Node&lt;T&gt; &#123; public T element; private Node&lt;T&gt; leftChild; private Node&lt;T&gt; rightSibling; public Node(T element) &#123; this(element, null, null); &#125; public Node(T element, Node&lt;T&gt; leftChild, Node&lt;T&gt; rightChild) &#123; this.element = element; this.leftChild = leftChild; this.rightSibling = rightChild; &#125; &#125; public static void main(String[] args) &#123; int numItems = 10000; BinomialQueue&lt;Integer&gt; h = new BinomialQueue&lt;Integer&gt;(); BinomialQueue&lt;Integer&gt; h1 = new BinomialQueue&lt;Integer&gt;(); int i = 37; System.out.println("Starting check."); for (i = 37; i != 0; i = (i + 37) % numItems) if (i % 2 == 0) h1.insert(i); else h.insert(i); h.merge(h1); for (i = 1; i &lt; numItems; i++) if (h.deleteMin() != i) System.out.println("Oops! " + i); System.out.println("Check done."); &#125;&#125; 具体分析链接：http://www.cnblogs.com/hapjin/p/5468817.htmlhttp://blog.csdn.net/PacosonSWJTU/article/details/50563228 6.9 标准库的优先列表JDK 1.5 之后出现的PriorityQueue支持了优先队列。 小结学习了ADT优先队列的各种实现方法和用途，标准的二叉堆实现具有简单和快速的有点，它不需要链，只需要常量的附加空间，且有效地支持优先队列的操作。二项队列指出了一个简单的想法如何能够用来达到好的时间界。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构与算法分析</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法分析</tag>
        <tag>二叉堆</tag>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法分析（JAVA描述）（第二章 算法分析）]]></title>
    <url>%2F2019%2F02%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%88JAVA%E6%8F%8F%E8%BF%B0%EF%BC%89%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构与算法分析（JAVA描述）（第二章 算法分析）chapter2#算法分析个人笔记，如有错误，恳请批评指正。 1.3 递归理论递归的四个基本法则 基准情形 存在某些基准情形，它无需递归就能解出。 不断推进 对于那些需要递归解出的情形，每一次递归都必须要使状况朝向一种基准情形推进。 设计法则 假设所有的递归调用都能运行。 合成效益法则 在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。 2.1 数学基础引入了相对增长率的概念以及数学定义。 T(N)=O (g(N))：T增长率小于或等于g T(N)=Ω (g(N))：T增长率大于或等于g T(N)=θ (g(N))：T增长率等于g T(N)=o (g(N))：T增长率小于g 关于增长率引入的四个法则 如果T=O F 且 T = O G; T1+T2 = O(F+G); T1T2 = O(FG); 阶数相同增长率相同 对数增长率非常慢（小于一次幂） 2.4 运行时间估算2.4.2 一般法则 法则一——for循环 运行时间：每一次循环的时间（包含测试）*迭代的次数 法则二——嵌套的for循环 运行时间：每一次循环的时间（包含测试）N1N2 法则三——顺序语句 将各个语句的运行时间求和即可，其中的最大值就是所得的运行时间，例如，以下代码的花费总量为O(N)； 12345for(int i = 0; i &lt; n ; i++) a[i] = 0;for(int i = 0; i&lt;n ;i++) for(int i = 0; j&lt;n ;i++) a[i] += a[j] + i + j; 法则四——if/else语句if/else中取较长的运行时间。估多不估少。 2.4.3 最大子序列和问题的求解需求：求解数组最大子序列和的算法 算法1：3层for循环，扫描三次，运算量上界：O(N^3)123456789101112131415public static int maxSubSum1(int[] arr) &#123; int maxSum = 0; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = i; j &lt; arr.length; j++) &#123; int thisSum = 0; for (int k = i; k &lt;= j; k++) &#123; thisSum += arr[k]; &#125; if (thisSum &gt; maxSum) maxSum = thisSum; &#125; &#125; return maxSum; &#125; 算法2：2层for循环，扫描两次，运算量上界：O(N^2)12345678910111213public static int maxSubSum2(int[] arr) &#123; int maxSum = 0; for (int i = 0; i &lt; arr.length; i++) &#123; int thisSum = 0; for (int j = i; j &lt; arr.length; j++) &#123; thisSum += arr[j]; if (thisSum &gt; maxSum) maxSum = thisSum; &#125; &#125; return maxSum; &#125; 算法3：分治算法求子序列的最大值，在前部，后部，中部取最大值，运算量上限：O(N *logN)思路：把问题分成两个大致相等的子问题，然后递归的对他们求解，这是“分”部分。“治”阶段将两个子问题的解修补到一起并可能在做些少量的附加工作，最后得到整个问题的解。12345678910111213141516171819202122232425262728293031323334353637383940414243public static int maxSubSum3(int[] arr)&#123; return maxSumRec(arr, 0, arr.length-1); &#125; private static int maxSumRec(int[] a,int left,int right)&#123; if(left == right)&#123; if(a[left]&gt;0) return a[left]; else return 0; &#125; int center = (left+right)/2; int maxLeftSum = maxSumRec(a,left,center);//迭代 int maxRightSum = maxSumRec(a,center+1,right);//迭代 /** * 从中心向左扫描，获取最大的子序列和 */ int leftBorderSum = 0;//存储left--center子序列的和 int maxLeftBorderSum = 0;//存储left--center子序列的和的最大值 for(int i = center;i&gt;=left;i--)&#123; leftBorderSum += a[i]; if(leftBorderSum&gt;maxLeftBorderSum)&#123; maxLeftBorderSum = leftBorderSum; &#125; &#125; /** * 从中心向右扫描，获取最大的子序列和 */ int rightBorderSum = 0;//存储right--center子序列的和 int maxRightBorderSum = 0;//存储right--center子序列的和的最大值 for(int i = center+1;i&lt;=right;i++)&#123;//center+1 rightBorderSum += a[i]; if(rightBorderSum&gt;maxRightBorderSum)&#123; maxRightBorderSum = rightBorderSum; &#125; &#125; return getMax(maxLeftSum,maxRightSum,maxLeftBorderSum+maxRightBorderSum);//返回三个中的最大值作为结果 &#125; private static int getMax(int a,int b,int c)&#123; int bigger = Math.max(a, b); return Math.max(bigger, c); &#125; 算法4：（perfect!） 利用原理：最大子序列两端剩余的序列的和一定为非正！！运算量：O(N)。附带的有点：只需一次读取数据，在任何时候，算法都能对它已经读入的数据给出正确的结果。具有这种特性的算法叫做联机算法(ion-line algorithm)，算法4只需要常量空间并以线性时间运行的联机算法几乎是完美的！123456789101112131415public static int maxSubSum4(int[] arr)&#123; int maxSubsum = 0; int subSum = 0; /** * 从第一位扫描，每扫一位判断1.大于目前的最大和，则赋值。2.小于但不小于0，继续保留3.小于0，之前扫描累计的和作废，=0 */ for(int i = 0;i &lt; arr.length;i++)&#123; subSum += arr[i]; if(subSum&gt;maxSubsum) maxSubsum = subSum; else if(subSum&lt;0) subSum = 0; &#125; return maxSubsum; &#125; 2.4.4 运行时间中的对数 分析算法最混乱的方面大概集中在对数上面，我们已经看到，某些分治算法将以O(N*logN)时间运行，此外，对数最常出现的规律可以概括为下列一般的法则：如果一个算法用常数时间（O(1））将问题的大小削减为其一部分（1/2），那么该算法就是O(LogN)，另一方面，如果常数时间只是把问题减少一个常数的数量（如将问题减少1），那么这种算法就是O(N)的。 具有对数特点的例子： 折半查找需求：查找有序数组指定数的下标若逐个扫描，结果运算量线性的（O(N)）,采用二分法查找即折半查找： 12345678910111213141516171819202122232425262728293031323334353637383940/** * @author Wch */public class Demo7 &#123; public static int getIndex(int[] arr,int num,int startIndex,int endIndex)&#123; if(startIndex&gt;endIndex) return -1; int midIndex = (startIndex+endIndex)/2; if(num&lt;arr[midIndex])&#123; return getIndex(arr,num,startIndex,midIndex-1); &#125;else if (num &gt; arr[midIndex]) return getIndex(arr,num,midIndex+1,endIndex); else return midIndex; &#125; /** * while循环实现 */ public static int getIndex(int[] arr,int num)&#123; int start = 0, end = arr.length-1; while(start&lt;=end)&#123; int mid = (start+end)/2; if(num&lt;arr[mid]) end = mid - 1; else if(num&gt;arr[mid]) start = mid + 1; else return mid;//找到了 &#125; return -1;//不存在该元素 &#125; @Test public void test1()&#123; int[] arr = &#123;1,2,3,8,9,11,12,14,19,20,21,99&#125;; int num = 998; int index = getIndex(arr, num, 0, arr.length-1); System.out.println(index); int index2 = getIndex(arr, num); System.out.println(index2); &#125;&#125; 欧几里得算法需求：求两个数的最大公因数原理：大数除以小数，连续除以余数知道余数为零，最后的非零余数就是最大公因数。在两次迭代之后，余数最多是原始值的一半，这就证明了迭代次数最多是2LogN = O LogN。 定理2.1 如果M&gt;N，则M mod N&lt;M/212345678910111213141516171819/** * 最大公因数 * @author Wch */public class Demo8 &#123; public long gcd(long a, long b)&#123;//欧几里得算法 if(a&lt;b)&#123;//确保a&gt;b long temp = a; a = b; b = temp; &#125; while(b!=0)&#123; long rem = a%b; a = b; b = rem; &#125; return a; &#125; &#125; 幂运算需求：求X^N的值。普通做法：做N-1次自乘运算。递归算法：N为偶数，=X^N/2+X^N/2；若N是奇数，则X^N = X^(N-1)/2 X^(N-1)/2 X，所需乘法次数为2LogN。 1234567891011121314151617181920/** * 幂运算 * @author Wch * */public class Demo9 &#123; public static long miyunsuan(long x, long n)&#123; if(n == 0) return 1; if(n%2 == 0)&#123;//偶数 return miyunsuan (x*x,n/2); &#125;else return miyunsuan(x*x,n/2)*x; &#125; @Test public void test1()&#123; long result = miyunsuan(2, 10); System.out.println(result); &#125;&#125; 2.4.5 分析结果的准确性对于某些坏的算法，最坏的界通过某些坏的输入是可以达到的，但在实践中它通常是估计过大的。平均情形的分析是极其复杂的，而最坏的情形的界虽然过分悲观，但却是最好的已知解析结果。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构与算法分析</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法分析 排序算法总结]]></title>
    <url>%2F2019%2F02%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[数据结构与算法分析 排序算法总结冒泡排序，快速排序，插入排序，希尔排序，简单排序，堆排序，归并排序 之前的记录： 别人家的记录：http://blog.csdn.net/jianyuerensheng/article/details/51258460 各排序算法复杂度比较 冒泡排序 时间复杂度：O(n^2) 空间复杂度：O(1) 没有辅助空间 稳定性：稳定 123456789101112131415161718192021222324252627/** * 冒泡排序是最慢的排序算法。在实际运用中它是效率最低的算法。它通过一趟又一趟地比较数组中的每一个元素，使 * 较大的数据下沉，较小的数据上升。它是O(n^2)的算法。 * * 步骤： * （1）比较相邻的元素。如果第一个比第二个大，就交换他们两个。 * （2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 * （3）针对所有的元素重复以上的步骤，除了最后一个。 * （4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 * * * * 时间复杂度：O(n^2) 空间复杂度：O(1) 没有辅助空间 */ public static void bubbleSort(int[] arr) &#123; int len = arr.length; for (int i = 0; i &lt; len; i++) &#123; for (int j = 0; j &lt; len-1-i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; System.out.println(Arrays.toString(arr)); &#125; &#125; 选择排序 时间复杂度：O(n^2) 空间复杂度：O(1) 稳定性：不稳定 1234567891011121314151617181920212223/** * 选择排序(Selection * sort)是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后， * 再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。以此类推，直到所有元素均排序完毕。 这种排序方法效率是 * O(n2)。在实际应用中处于和冒泡排序基本相同的地位。它们只是排序算法发展的初级阶段，在实际中使用较少 * * @param arr * * 时间复杂度：O(n^2) 空间复杂度：O(1) 稳定性：bu稳定 */ public static void selectSort(int[] arr) &#123; int len = arr.length; for (int i = 0; i &lt; len; i++) &#123; for (int j = i + 1; j &lt; len; j++) &#123; if (arr[i] &gt; arr[j]) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; System.out.println(Arrays.toString(arr)); &#125; &#125; 插入排序 时间复杂度：O(n^2) 空间复杂度：O(1) 稳定性：稳定 12345678910111213141516171819202122232425262728/** * 插入排序（Insertion * Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描 * ，找到相应位置并插入。插入排序在实现上 * ，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位 * ，为最新元素提供插入空间。 * 插入排序是对冒泡排序的改进。它比冒泡排序快2倍。一般不用在数据大于1000的场合下使用插入排序，或者重复排序超过200数据项的序列。 * 步骤： * （1）从第一个元素开始，该元素可以认为已经被排序 * （2）取出下一个元素，在已经排序的元素序列中从后向前扫描 * （3）如果该元素（已排序）大于新元素，将该元素移到下一位置 （4）重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置中 * （4）重复步骤2 * * @param arr * 时间复杂度：O(n^2) 空间复杂度：O(1) 直接插入排序法比冒泡和简单选择排序的性能要好一些。 */ public static void insertSort(int[] arr)&#123; int len = arr.length; int j; for(int i = 1;i&lt;len;i++)&#123; int insert = arr[i];//插入元素位置 for(j=i-1;j&gt;=0&amp;&amp;insert&lt;arr[j];j--)&#123;//&#123;2,3,4,5插入1&#125; arr[j+1] = arr[j]; &#125; arr[j+1] = insert;//+1的原因是此时的j不满足insert&lt;arr[j],因此insert插入到j之后的位置 System.out.println(Arrays.toString(arr)); &#125; &#125; 希尔排序希尔排序，也称递减增量排序算法，是插入排序的一种高速而稳定的改进版本。希尔排序是基于插入排序的以下两点性质而提出改进方法的：（1）插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率（2）但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位 时间复杂度：O(n logn) 空间复杂度：O(1) 不稳定 Shell排序比冒泡排序快5倍，比插入排序大致快2倍。Shell排序比起QuickSort，MergeSort，HeapSort慢很多。但是它相对比较简单，它适合于数据量在5000以下并且速度并不是特别重要的场合。它对于数据量较小的数列重复排序是非常好的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 希尔排序：对直接插入排序的升级和优化 * * @param arr * 时间复杂度:O(n*logn) * 空间复杂度：O(1) * 稳定性：不稳定 * * * * Shell排序通过将数据分成不同的组，先对每一组进行排序，然后再对所有的元素进行一次插入排序，以减少数据交换和移动的次数。 * 平均效率是O(nlogn)。其中分组的合理性会对算法产生重要的影响。现在多用D.E.Knuth的分组方法。 * * Shell排序比冒泡排序快5倍，比插入排序大致快2倍。Shell排序比起QuickSort，MergeSort， * HeapSort慢很多 * 。但是它相对比较简单，它适合于数据量在5000以下并且速度并不是特别重要的场合。它对于数据量较小的数列重复排序是非常好的。 */ public static void shellSort(int[] arr)&#123; int len = arr.length; int step = len/2; int j; while(step&gt;0)&#123;//最后一个step必须要为1。 for(int i = step;i&lt;len;i++)&#123;//从第step的元素开始往前插入 int temp = arr[i];//第i个元素作为插入元素，之前i step间隔的元素默认有序，无序则进行交换。 for(j = i-step;j&gt;=0&amp;&amp;temp&lt;arr[j];j-=step)&#123; arr[j+step] = arr[j]; &#125; arr[j+step] = temp; System.out.println(Arrays.toString(arr)); &#125; step /= 2;//缩小增量 &#125; &#125; public static &lt;T extends Comparable&gt; void shellSort2(T[] a) &#123; int j; for (int gap = a.length / 2; gap &gt;= 1; gap /= 2) for (int i = gap; i &lt; a.length; i++) &#123; for (j = i; j - gap &gt;= 0; j -= gap) &#123; if (a[j].compareTo(a[j - gap]) &lt; 0) &#123; T temp = a[j]; a[j] = a[j - gap]; a[j - gap] = temp; &#125; else break; &#125; &#125; &#125; 堆排序堆排序适合于数据量非常大的场合（百万数据）。 堆排序不需要大量的递归或者多维的暂存数组。这对于数据量非常巨大的序列是合适的。比如超过数百万条记录，因为快速排序，归并排序都使用递归来设计算法，在数据量非常大的时候，可能会发生堆栈溢出错误。 堆排序会将所有的数据建成一个堆，最大的数据在堆顶，然后将堆顶数据和序列的最后一个数据交换。接下来再次重建堆，交换数据，依次下去，就可以排序所有的数据。 二叉堆复习完全二叉堆这么有规律，所以它可以用一个数组表示而不需要使用链。对于数组中任何一个位置i，左儿子为2i。右儿子为2i+1，父节点在i/2的位置。 本例程只学习了小根堆，大根堆是类似的情况。 二叉堆是一个完全的二叉树，其没有儿子的节点只可能出现在末尾处。 上滤在insert操作时，采取的是hole上滤操作。上滤是指：将插入元素放置最后位置，此位置称为空穴，如果该元素能放置该位置而不破坏对的结构，则插入完成，否则，将空穴父节点的元素移入改空穴中，这样，空穴就朝着根的方向上移了一层。直至空穴元素能满足堆结构位置停止上滤值得注意的是：在父节点移入空穴的过程中，有两种方式，一种是直接和空穴元素交换，需要三步。另一种是直接赋值给空穴元素，空穴元素一直存储到temp中，此种做法只要一步。 1234567public void insert(int num)&#123;//上滤 int hole = ++size;//从1开始 for(;hole&gt;=0&amp;&amp;num&lt;arrays[hole/2];hole /=2) arrays[hole] = arrays[hole/2]; arrays[hole] = num; &#125; 下滤deleteMin操作时，采取的是将末尾元素X放入arrays[1]的位置（二叉树的数组从1开始，即堆顶元素下标为1），然后从1位置开始下滤。下滤就是将空穴的两个儿子的较小者放到空穴，空穴下移一层，最终直至X能放到合适的位置。具体做法是：将X置入沿着从根开始包含最小儿子的一条路径上的一个正确的位置。 123456789101112131415public void percDown(int hole)&#123;//下滤 int temp = arrays[hole]; int child; for(;hole*2&lt;=size;hole =child)&#123; child = hole*2; if(child!=size&amp;&amp;arrays[child+1]&lt;arrays[child])&#123;//child==size表示没有右儿子 小根堆 ，往较小的儿子下滤，较小的儿子上移 child++; &#125; if(temp&gt;arrays[child]) arrays[hole] = arrays[child]; else break; &#125; arrays[hole] = temp; &#125; buildHeap操作初始集合如何获得堆结构？一次一次的percDown即可。 123456789101112131415public BinaryHeap(int[] arr)&#123; size = arr.length; arrays = new int[size*2]; for(int i = 0;i&lt;size;i++)&#123; arrays[i+1] = arr[i]; &#125; buildHeap(); System.out.println(Arrays.toString(arrays)); &#125; private void buildHeap()&#123; for(int i = size/2;i&gt;0;i--)&#123; percDown(i); &#125; &#125; 注意：二叉堆只保证节点的元素比起后代更小（或更大），并没有保证同一级的节点的大小关系。所以：利用小根堆找最大值是不可行的，因为最大值只能确定存在于叶子节点，但是叶子占了一半的位置。堆排序的原理是先构建二叉堆，然后一次一次的剔除，重建，剔除，重建…将数组从后到前进行排序。若要对数组进行从小到大排序，需要构建大根堆！ 堆排序的实现堆是一种特殊的树形数据结构，其每个节点都有一个值，通常提到的堆都是指一颗完全二叉树，根结点的值小于（或大于）两个子节点的值，同时，根节点的两个子树也分别是一个堆。堆排序就是利用堆（假设利用大根堆）进行排序的方法。它的基本思想是，将待排序的序列构造成一个大根堆。此时，整个序列的最大值就是堆顶的根节点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的 n-1 个序列重新构造成一个堆，这样就会得到 n 个元素中次大的值。如此反复执行，便能得到一个有序序列了。堆排序的实现需要解决的两个关键问题：（1）将一个无序序列构成一个堆。（2）输出堆顶元素后，调整剩余元素成为一个新堆。 时间复杂度：O(n logn) 空间复杂度：O(1) 稳定性：不稳定12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MySort2 &#123; public static void heapSort(int[] arr) &#123; int len = arr.length; // 构建大根堆 for (int i = len / 2; i &gt;= 0; i--) &#123; percDown(arr, i, len - 1); &#125; System.out.println(Arrays.toString(arr)); for (int i = len - 1; i &gt;= 0; i--) &#123; int temp = arr[i]; arr[i] = arr[0]; arr[0] = temp; percDown(arr, 0, i); System.out.println(Arrays.toString(arr)); &#125; &#125; /** * * @param arr 排序数组也是堆数组 * @param i 从i元素开始下滤 * @param n */ private static void percDown(int[] arr, int i, int n) &#123;// 下滤 int temp = arr[i]; int child; for (child = leftChild(i); leftChild(i) &lt; n; i = child) &#123;// i父，child子//此处和标准二叉堆不同，数组下标从0开始，因此是&lt;没有= child = leftChild(i); if (child != n-1 &amp;&amp; arr[child] &lt; arr[child + 1]) &#123;// 大根堆，往大儿子下滤 child++; &#125; if (temp &lt; arr[child]) arr[i] = arr[child]; else break; &#125; arr[i] = temp; &#125; private static int leftChild(int i) &#123;// 数组下标从0开始 return 2 * i + 1; &#125; public static void main(String[] args) &#123; int[] arr = &#123; 1, 9, 5, 8, 6, 3, 21, 42, 32, 21, 12, 41, 10 &#125;; heapSort(arr); System.out.println(Arrays.toString(arr)); &#125;&#125; 归并排序合并排序比堆排序稍微快一点，但是需要比堆排序多一倍的内存空间，因为它需要一个额外的数组。归并排序是一种比较占内存，但却效率高且稳定的算法。 时间复杂度：O(n logn) 空间复杂度：O(n+logn) 稳定性：稳定 步骤：（1）申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列（2）设定两个指针，最初位置分别为两个已经排序序列的起始位置（3）比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置（4）重复步骤3直到某一指针达到序列尾（5）将另一序列剩下的所有元素直接复制到合并序列尾 关键操作是merge，即合并两个排好序的表啊表。合并的基本算法是输入两个数组A和B，一个输出数组C，以及3个计数器Acount,Bcount,Ccount。A[Acount]、B[Bcount]中的较小者被拷贝到C中的下一位置，相关的计数器向前推进一步。当两个输入表的一方用完，另一方拷贝剩余部分到C中。每一步merge操作的最后最后将tempArr中排好序的序列拷贝至对应的源数组中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class MergeSort &#123; public void mergeSort(int[] arr)&#123; int[] tempArr = new int[arr.length]; mergeSort(arr,tempArr,0,arr.length-1); &#125; private void mergeSort(int[] arr,int[] tempArr,int left,int right)&#123; if(left&lt;right)&#123; int mid = (left+right)/2; mergeSort(arr, tempArr, left, mid); mergeSort(arr, tempArr, mid+1, right); merge(arr,tempArr,left,mid+1,right); &#125; &#125; /** * * @param arr 原数组 * @param tempArr 临时数组，用于存储合并后的元素 * @param leftPointer 左指针 * @param rightPointer 右指针 * @param rightEnd 右半部数组的结束点 */ private void merge(int[] arr,int[] tempArr,int leftPointer,int rightPointer,int rightEnd)&#123; int tempIndex = leftPointer;//临时数组指针 int leftEnd = rightPointer-1;//左数组结束点 int mergeCount = rightEnd-leftPointer+1;//记录合并的数列的个数，用于最后的拷贝 while(leftPointer&lt;=leftEnd&amp;&amp;rightPointer&lt;=rightEnd)&#123; if(arr[leftPointer]&lt;arr[rightPointer]) tempArr[tempIndex++] = arr[leftPointer++]; else tempArr[tempIndex++] = arr[rightPointer++]; &#125; if(leftPointer&gt;leftEnd)&#123;//左为空 while(rightPointer&lt;=rightEnd) tempArr[tempIndex++] = arr[rightPointer++]; &#125; if(rightPointer&gt;rightEnd)&#123; while(leftPointer&lt;=leftEnd) tempArr[tempIndex++] = arr[leftPointer++]; &#125; //将排好序的队列拷贝到原数组中 for(int i = 0;i&lt;mergeCount;i++)&#123; arr[rightEnd] = tempArr[rightEnd]; rightEnd--; &#125; System.out.println(Arrays.toString(arr)); &#125; public static void main(String[] args) &#123; int[] arr = &#123;15,14,13,12,11,10,9,8,7,6,5,4,3,2,1&#125;; MergeSort ms = new MergeSort(); ms.mergeSort(arr); System.out.println(Arrays.toString(arr)); &#125;[14, 15, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1][14, 15, 12, 13, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1][12, 13, 14, 15, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1][12, 13, 14, 15, 10, 11, 9, 8, 7, 6, 5, 4, 3, 2, 1][12, 13, 14, 15, 10, 11, 8, 9, 7, 6, 5, 4, 3, 2, 1][12, 13, 14, 15, 8, 9, 10, 11, 7, 6, 5, 4, 3, 2, 1][8, 9, 10, 11, 12, 13, 14, 15, 7, 6, 5, 4, 3, 2, 1][8, 9, 10, 11, 12, 13, 14, 15, 6, 7, 5, 4, 3, 2, 1][8, 9, 10, 11, 12, 13, 14, 15, 6, 7, 4, 5, 3, 2, 1][8, 9, 10, 11, 12, 13, 14, 15, 4, 5, 6, 7, 3, 2, 1][8, 9, 10, 11, 12, 13, 14, 15, 4, 5, 6, 7, 2, 3, 1][8, 9, 10, 11, 12, 13, 14, 15, 4, 5, 6, 7, 1, 2, 3][8, 9, 10, 11, 12, 13, 14, 15, 1, 2, 3, 4, 5, 6, 7][1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15][1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]&#125; 快速排序平均运行时间是O(n logn)，该算法之所以快，是因为非常精炼和高度优化的内部循环。像归并排序一样，快速排序也是一种分治的递归算法。 时间复杂度：O(n logn) 空间复杂度：O(logn) 稳定性：不稳定 “经典快速“排序的步骤：（1） 如果不多于1个数据，直接返回。（2） 选取序列中的某一个元素作为支点数据（pivot，枢纽元）。（3） 将序列分割2部分，一部分都大于支点数据，另外一部分都小于支点数据。（4） 对两边利用递归排序数列。 枢纽元的选取 错误做法一：选取第一个元素。预排序或倒序将会产生恶劣的分割。 错误做法二：随机选取，虽然安全，但是随机的开销太大。 三数中值分割法（Median-ofTree Partitioning）选取序列中左中右的中值作为枢纽元。 分割策略枢纽元与最后一个元素进行交换，i指向第一个元素，j指向枢纽元之前的元素。i和j指向的元素分别于枢纽元进行比较，当i指向的元素小于枢纽元时i++，否则不移动；同样当j指向的元素大于枢纽元时，j–，否则不移动。当i和j都停止不动时，交换i和j的值。比较停止的条件是i&gt;j。 停还是不停？当i或j与枢纽元相等时，好一点的做法是指针停止，进行交换。 小数组对于小数组，快速排序不如插入排序，因此在数组数量小于一个值时，可以选择插入排序。由于快速排序是递归的，因此这种情况经常发生。一种好的截止范围是N=10； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public class QuickSort &#123; private static final int QUICK_SORT_LIMIT = 10;//当排序元素小于改数用插入排序，提高约15%的效率 public void quickSort(int[] arr)&#123; quickSort(arr,0,arr.length-1); &#125; /** * * @param arr * @param left * @param right left和right决定了排序的序列区间 */ private void quickSort(int[] arr,int left,int right)&#123; if(left+QUICK_SORT_LIMIT&lt;=right)&#123; int pivot = median3(arr, left, right);//用于比较的枢纽元 int i = left; int j = right-1; while(true)&#123; while(arr[++i]&lt;pivot)&#123;&#125;//小移 while(arr[--j]&gt;pivot)&#123;&#125;//大移 if (i &lt; j)//i=j或i&gt;j不需交换 swapReference(arr, i, j); else break; /* * ij可能存在等于的情况，此时i=j=pivot，此时应该终止判断 */ &#125; swapReference(arr, i, right-1);//恢复枢纽元的位置 quickSort(arr,left,i-1);//i此时为枢纽元，不需再进行排序了 quickSort(arr,i+1,right); &#125;else&#123; insertSort(arr,left,right); &#125; &#125; /** * 简单插入排序 * @param arr * @param left * @param right */ public void insertSort(int[] a,int left,int right)&#123; int j; for(int p = left+1;p&lt;=right;p++)&#123; int temp = a[p]; for(j = p;j&gt;left&amp;&amp;temp&lt;a[j-1];j--) a[j] = a[j-1]; a[j] = temp; &#125; &#125; /** * 三数中值分割法 * * 该方法将会对原数组中的左中右三个数进行提前排序，并将中值（即枢纽元）放置到倒数第二个位置。 * @param arr 原数组 * @param left 左 * @param right 右 * @return 返回左中右中中位数的值 */ private int median3(int[] arr,int left,int right)&#123; int mid = (left+right)/2; if(arr[left]&gt;arr[mid]) swapReference(arr, left, mid); if(arr[left]&gt;arr[right]) swapReference(arr, left, right); if(arr[mid]&gt;arr[right]) swapReference(arr, mid, right); swapReference(arr, mid, right-1); return arr[right-1]; &#125; /* * 交换a，b下标的元素 */ private void swapReference(int[] arr,int a,int b)&#123; int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125; public static void main(String[] args) &#123; QuickSort qs = new QuickSort(); int[] arr = &#123; 20,19,18,17,16,15,11,12,13,10,9,8,7,6,5,4,3,2,1 &#125;; qs.quickSort(arr); System.out.println(Arrays.toString(arr)); &#125; &#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构与算法分析</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法分析 二叉树的遍历]]></title>
    <url>%2F2019%2F02%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[数据结构与算法分析 二叉树的遍历树的三种遍历，递归+非递归。深度优先，广度优先遍历二叉树 树的遍历（先中后）递归版本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package cn.ustb.树的遍历;//递归遍历public class MyBinaryTree &#123; static class Node&#123; Node left; Node right; private int val; public Node(int val) &#123; super(); this.val = val; &#125; &#125; /* * 递归版本 */ //前序 public static void preOrder(Node node)&#123; if(node == null) return; System.out.print(node.val); preOrder(node.left); preOrder(node.right); &#125; //中序 public static void inOrder(Node node)&#123; if(node == null) return; inOrder(node.left); System.out.print(node.val); inOrder(node.right); &#125; //后序 public static void postOrder(Node node)&#123; if(node == null) return; postOrder(node.left); postOrder(node.right); System.out.print(node.val); &#125; public static void main(String[] args) &#123; /* * 4 * / \ * 2 7 * / \ / \ * 1 3 6 9 * */ Node n1 = new Node(4); Node n2 = new Node(2); Node n3 = new Node(7); Node n4 = new Node(1); Node n5 = new Node(3); Node n6 = new Node(6); Node n7 = new Node(9); n1.left = n2; n1.right = n3; n2.left = n4; n2.right = n5; n3.left = n6; n3.right = n7; preOrder(n1);//4213769 System.out.println(); inOrder(n1);//1234679 System.out.println(); postOrder(n1);//1326974 &#125;&#125; 非递归版本MyStack的数组实现stack：数组实现，链表实现，Linkedlist实现queue：数组实现，循环数组实现，链表实现，Linkedlist实现更多关于queue和stack的实现见于：http://www.cnblogs.com/CherishFX/p/4608880.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package cn.ustb.树的遍历;import java.util.Arrays;public class MyStack&lt;T&gt; &#123; private T[] nodes; volatile int size = 0; private static final int PRIMARY_CAPACITY = 10; public MyStack() &#123; super(); this.nodes = (T[]) new Object[PRIMARY_CAPACITY]; this.size = 0; &#125; public void push(T t)&#123; ensureCapacity(); nodes[size++] = t; &#125; public T pop()&#123; if(empty()) throw new RuntimeException("空！"); T temp = nodes[--size]; nodes[size] = null; return temp; &#125; public T peek()&#123; if(empty()) throw new RuntimeException("空！"); return nodes[size-1]; &#125; private void ensureCapacity()&#123; if(size == nodes.length)&#123; nodes = Arrays.copyOf(nodes, size&lt;&lt;2); &#125; &#125; public int size()&#123; return size; &#125; public boolean empty()&#123; return size()==0; &#125;&#125; 非递归123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130package cn.ustb.树的遍历;public class MyBinaryTree2 &#123; static class Node&#123; Node left; Node right; private int val; public Node(int val) &#123; super(); this.val = val; &#125; &#125; /* * 非递归版本，利用栈数据结构 */ //前序遍历 public static void preOrder(Node node)&#123; if(node == null)return; MyStack&lt;Node&gt; stack = new MyStack&lt;&gt;(); while(node!=null||!stack.empty())&#123; while(node!=null)&#123; System.out.print(node.val);//push之前先遍历 stack.push(node); node = node.left; &#125; if(!stack.empty())&#123; node = stack.pop(); node = node.right; &#125; &#125; &#125; //中序遍历 public static void inOrder(Node node)&#123; if(node == null)return; MyStack&lt;Node&gt; stack = new MyStack&lt;&gt;(); while(node!=null||!stack.empty())&#123; while(node !=null)&#123; stack.push(node); node = node.left; &#125; if(!stack.empty())&#123; node = stack.pop(); System.out.print(node.val); node = node.right; &#125; &#125; &#125; //后序遍历 public static void postOrder(Node node)&#123; if(node == null)return; MyStack&lt;Node&gt; stack = new MyStack&lt;&gt;(); MyStack&lt;Node&gt; outputStack = new MyStack&lt;&gt;();//存储遍历顺序 while(node!=null||!stack.empty())&#123; while(node !=null)&#123; stack.push(node); outputStack.push(node); node = node.right; &#125; if(!stack.empty())&#123; node = stack.pop(); node = node.left; &#125; &#125; while(!outputStack.empty()) System.out.print(outputStack.pop().val); &#125; //后序遍历方法2： public static void postOrder(Node node,String method2)&#123; if(node == null)return; MyStack&lt;Node&gt; stack = new MyStack&lt;&gt;(); MyStack&lt;Integer&gt; stateStack = new MyStack&lt;&gt;();//存储对应位置node的输出状态 while(node!=null||!stack.empty())&#123; while(node !=null)&#123; stack.push(node); stateStack.push(0);//0代表默认不输出 node = node.left; &#125; while(!stack.empty()&amp;&amp;stateStack.peek()==1)&#123;//可以输出 stateStack.pop(); System.out.print(stack.pop().val); &#125; if(!stack.empty())&#123;//不可以输出 :node == null&amp;&amp;state == 0 stateStack.pop(); stateStack.push(1); node = stack.peek(); node = node.right; &#125; &#125; &#125; public static void main(String[] args) &#123; /* * 4 * / \ * 2 7 * / \ / \ * 1 3 6 9 * */ Node n1 = new Node(4); Node n2 = new Node(2); Node n3 = new Node(7); Node n4 = new Node(1); Node n5 = new Node(3); Node n6 = new Node(6); Node n7 = new Node(9); n1.left = n2; n1.right = n3; n2.left = n4; n2.right = n5; n3.left = n6; n3.right = n7; preOrder(n1);//4213769 System.out.println(); inOrder(n1);//1234679 System.out.println(); postOrder(n1);//1326974 System.out.println(); postOrder(n1,"");//1326974 &#125;&#125; 树的遍历（深度优先，广度优先）深度优先+广度优先123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package cn.ustb.树的遍历;public class MyBinaryTree3 &#123; static class Node&#123; Node left; Node right; private int val; public Node(int val) &#123; super(); this.val = val; &#125; &#125; /* * 深度优先 * 借助 栈 的数据结构实现 */ public static void deptFirstOrder(Node node)&#123; if(node == null)return ; MyStack&lt;Node&gt; stack = new MyStack&lt;&gt;(); stack.push(node); while(!stack.empty())&#123; node = stack.pop(); System.out.print(node.val); if(node.right!=null) stack.push(node.right); if(node.left!=null) stack.push(node.left); &#125; &#125; /* * 广度优先 * 借助 队列 的数据结构实现 */ public static void breadthFirstOrder(Node node)&#123; if(node == null)return; MyQueue&lt;Node&gt; queue = new MyQueue&lt;&gt;();//或者自己实现queue queue.offer(node); while(!queue.isEmpty())&#123; node = queue.poll(); System.out.print(node.val); if(node.left!=null) queue.offer(node.left); if(node.right!=null) queue.offer(node.right); &#125; &#125; public static void main(String[] args) &#123; /* * 4 * / \ * 2 7 * / \ / \ * 1 3 6 9 * / * 0 */ Node n1 = new Node(4); Node n2 = new Node(2); Node n3 = new Node(7); Node n4 = new Node(1); Node n5 = new Node(3); Node n6 = new Node(6); Node n7 = new Node(9); Node n8 = new Node(0); n1.left = n2; n1.right = n3; n2.left = n4; n2.right = n5; n3.left = n6; n3.right = n7; n4.left = n8; deptFirstOrder(n1);//42103769 System.out.println(); breadthFirstOrder(n1);//42713690 System.out.println(); &#125;&#125; MyQueue的数组实现个人理解：循环数组不存在扩容机制Queue的其他实现见于：http://www.cnblogs.com/CherishFX/p/4608880.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package cn.ustb.树的遍历;import java.util.Arrays;public class MyQueue&lt;T&gt; &#123; private T[] nodes; private int start; private int end; private static final int PRIMARY_CAPACITY = 10; public MyQueue() &#123; super(); nodes = (T[]) new Object[PRIMARY_CAPACITY]; start = end = 0; &#125; public void offer(T t)&#123; ensureCapacity(); nodes[end++] = t; &#125; public T poll()&#123; if(isEmpty()) throw new RuntimeException("empty!"); T temp = nodes[start]; nodes[start++] = null; return temp; &#125; public T peek()&#123; if(isEmpty()) throw new RuntimeException("empty!"); return nodes[start]; &#125; private void ensureCapacity()&#123; if(end == nodes.length)&#123; nodes = Arrays.copyOf(nodes, end&lt;&lt;2);//4倍扩容 &#125; &#125; public int size()&#123; return end-start; &#125; public boolean isEmpty()&#123; return size()==0; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构与算法分析</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>遍历</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机系统（1-2） 计算机系统漫游、信息的表示和处理]]></title>
    <url>%2F2019%2F02%2F14%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%881-2%EF%BC%89%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8%E3%80%81%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[计算机系统（1-2） 计算机系统漫游、信息的表示和处理深入理解计算机系统（原始第三版） 1.2 程序被其他程序翻译成不同的格式编译系统（compilation system）：预处理器、编译器、汇编器和链接器。 预处理阶段：#include&lt;stdio.h&gt;导入stdio.h 编译阶段：编译成汇编语言，更接近计算机底层 汇编阶段：汇编器将编译阶段产物翻译成机器语言指令。字节码文件。 链接阶段 1.7.2 线程一个进程实际上可以由多个线程执行单元组成，多线程之间比多进程之间更容易共享数据，因此是更高效的一种编程模型。 1.7.3 虚拟内存为每个进程提供一种独占使用内存的假象。内存地址由下往上增大，自下往上依次是： 代码和数据区：程序开始的地方。从程序加载进来 堆内存：运行时堆，动态的进行扩张和伸缩 共享库：数据共享区，映射区域。 栈内存：用户栈，动态的扩张和伸缩 内核虚拟内存：保留给操作系统即内核使用过多，用户代码不可见。 1.7.4 文件文件就是字节序列。 1.9.2 并发和并行并发：一个同时具有多个活动的系统。并行：用并发来使一个系统运行的更快。 1、线程级并发2、指令级并行一个时钟周期执行多条指令。 3、单指令、多数据并行1.10 小结计算机系统由硬件和软件组成，他们之间共同协作以运行应用程序。计算机内部的信息被表示为一组组的位，他们根据上下文有着不同的解释方式。程序被其他程序翻译成不同的形式，开始时是ASCII文本，然后被编译器和链接器翻译成二进制可执行文件。处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、I/O设备和CPU寄存器之间复制数据，所以将系统中存储设备划分成层次结构——CPU寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM主存和磁盘存储器。在层次模型中，位于更高层的存储设备比低层的存储设备要更快，单位比特造价也更高。层次结构中较高层次的存储设备可以作为较低层次设备的高速缓存。通过理解和运用这种存储层次结构的知识，可以优化程序的性能。操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象：1、文件是对I/O设备的抽象。2、虚拟内存是对主存和磁盘的抽象。3、进程是处理器、主存和I/O设备的抽象。最后，网络提供了计算机系统之间通信的手段。从特殊系统的角度来看，网络就是一种I/O设备。 2.5 小结计算机将信息编码为位（比特），通常组织成字节序列。有不同的编码方式来表示整数、实数和字符串。不同的计算机模型在编码数字和多字节数据中的字节顺序时使用不同的约定。C语言的设计可以包容多种不同字长和数字编码的实现。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络（8） 计算机网络中的安全]]></title>
    <url>%2F2019%2F02%2F14%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%888%EF%BC%89%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[计算机网络（8） 计算机网络中的安全计算机网络：自顶向下方法（第六版） 8.1 网络安全 机密性：防窃听 报文完整性：防篡改 端点鉴别：防假冒 运行安全性 8.2.1 对称密钥密码体制很有趣的内容，详见P444。对称密钥即共享密钥加密，加密和解密是同一把密钥。 8.2.2 公开密钥加密需要保证： 公钥加密的密文很难被破解。 发送方认证 接收方认证 1、RSA算法公钥加密，私钥解密，具体算法略。 2、会话密钥RSA算法费时，如果用于加密大量数据很慢，通常使用RSA与对称密钥配合使用。利用RSA加密传输共享密钥，在确保共享密钥只有传输双方知道以后，利用共享密钥对数据进行加密传输。 3、RSA的工作原理省略了 P452 8.3 报文完整性和数字签名8.3.3 数字签名私钥加密，公钥解密验证真实性。 公钥认证公钥证书，利用权威CA（Certification Authority，认证中心）对公钥进行私钥加密，包装成证书颁发给服务器。服务器发送给客户端，客户端利用权威机构的公钥对其进行解密，若解密成功，既可以确定：1、服务器是合法的。2、公钥是正确的。 8.4 端点鉴别思路：{口令+不重数（nonce）}加密防止playback attack(回放攻击) 8.6 SSL安全套接字层（Secure Socket Layer，SSL），SSL版本3的一个稍加修改的版本称为运输层安全性（Transport Layer Security，TLS），已经由IETF标准化。P468— 8.6.2 SSL连接过程SSL记录格式类型||版本||长度||数据||MAC 类型：1、是握手报文还是数据报文还是关闭连接报文。 版本：自解释的。 长度：从TCP字节流中提取记录的开始位置。 数据和MAC：加密了。MAC包含序号，防颠倒顺序。 8.9 防火墙防火墙是一个硬件和软件的结合体，三个目标： 从外部到内部的所有流量都通过防火墙。 仅被授权的流量允许通过。 防火墙自身免于渗透。 3类：传统分组过滤器（traditional packet filter）、状态过滤器（stateful filter）、应用程序网关（application gateway） 1、传统分组过滤器在网关路由器处执行分组过滤（packet filtering），过滤标准： IP源或目的地址 在IP数据报中的协议类型字段：TCP、UDP、ICMP（网络层的三个组件之一：分别是：IP协议、路由选择协议、因特网控制报文协议：ICMP）、OSPF TCP或UDP的源和目的端口 TCP标志比特：SYN、ACK等 ICMP报文类型 数据报离开和进入网络的不同规则 对不同路由器接口的不同规则 通过不同的过滤规则过滤不同方向的访问。 2、状态分组过滤器状态过滤器通过一张连接表跟踪了所有用户的连接，并根据访问控制列表决定是否对尝试进入或出去的连接进行核对（和连接表进行核对），没有头尾的连接（攻击连接）将会被拒绝。 3、应用程序网关P485]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络（5） 链路、接入网和局域网]]></title>
    <url>%2F2019%2F02%2F14%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%885%EF%BC%89%20%E9%93%BE%E8%B7%AF%E3%80%81%E6%8E%A5%E5%85%A5%E7%BD%91%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91%2F</url>
    <content type="text"><![CDATA[计算机网络（5） 链路、接入网和局域网计算机网络：自顶向下方法（第六版） 传输结点将数据报封装在链路层帧中，并将该帧传送到链路层。 5.1.1 链路层可能提供的服务 成帧：即封装数据报成链路层帧。 链路接入：多个结点共享单个广播链路时，媒体访问控制（Medium Access Control，MAC）协调多个结点的帧传输。 可靠交付：本地纠错。 差错检测和纠正：硬件实现，差错检测和纠正。 5.1.2 链路层在何处实现链路层的主题部分在网络适配器（network adapter）中实现，网络适配器有时也称为网络接口卡（Network Interface Card，NIC）。 5.2 差错检测和纠正技术比特级差错检测和纠正，即对从一个结点到另一个结点链路层帧中的比特损伤进行检测和纠正，它们通常是链路层提供的两种服务。 5.2.1 奇偶校验二维奇偶校验：二维数组，能准确的确定损伤的位置。 5.2.2 检验和方法相对于CRC提供较弱的差错保护。 为什么运输层使用检验和而链路层使用CRC呢？因为运输层通常使用软件实现，采用简单快速的差错检测机制很重要。链路层的差错检测通常在网络适配器中专用的硬件实现，能够快速的执行更复杂的CRC操作。 5.2.3 循环冗余检测循环冗余检测（Cyclic Redundancy Cheek，CRC）编码，也称为多项式编码。记住是一种比较可靠的差错检测方案。P295 5.3 多路访问链路和协议两种类型的网络链路：点对点链路和广播链路。 点对点链路：由链路的一端的单个发送方和链路另一端的单个接受方组成。许多链路层协议都是为点对点链路设计的。如点对点协议（ponit-to-point protocol，PPP）和高级数据链路控制（high-level data link control，HDLC）。 广播链路：能够让多个发送和接受节点都连接到相同的、单一的、共享的广播信道上。以太网和无线局域网是广播链路层技术的例子。 多路访问问题，衍生出多路访问协议。 多路访问协议的类型：信道划分协议、随机接入协议和轮流协议、 5.3.1 信道划分协议时分多路复用（TDM），频分多路复用（FDM）是两种能够用于在所有共享信道节点之间划分广播信道带宽的技术。 第三种信道划分协议是码分多址（Code Division Multiple Access，CDMA）：CDMA为每个结点分配一种不同的编码。然后每个结点用该编码进行编码传输，如果精心选择这些编码，则不同的结点能够进行同时传输而互不干扰。 5.3.2 随机接入协议检测碰撞，在重发该帧之前等待一个随机时延。 ALOHA一种随机接入协议 载波侦听多路访问（CSMA）载波侦听：结点在传输之前先听信道是否有帧在传输。碰撞检测：自己在传输的同时如果检测到有别的结点在传输帧，则会停止自己的传输。 信道传播时延（channel propaagtion delay）是导致在载波侦听多路访问（Carrier Sense Multiple Access，CSMA）中发生碰撞的原因。 具有碰撞检测的载波侦听多路访问（CSMA/CD）两个结点在检测到碰撞后的很短时间都放弃了他们的传输。 重新发送帧的随机时间间隔：当碰撞结点数量较少时，时间间隔较短；当碰撞结点数量较大时，时间间隔较长。采用二进制指数后退算法（binary exponential backoff）计算。该算法特性：当几个其他适配器处于指数后退状态时，有可能一个具有新帧的结点能够立即插入一次成功的传输。 5.3.3 轮流协议多路访问的两个理想特性： 当只有一个结点活跃时，该活跃结点具有最大的吞吐量，即R bps。 当有M个节点活跃时，每个结点的吞吐量接近R/M bps。 轮流协议解决了第二个特性。 轮询协议主结点以循环的方式轮询（poll）每个结点。 令牌传递协议这种协议中没有主结点，只有一个特殊帧在结点之间按固定的次序传输，称为令牌（token）。持有该令牌时，如果需要发送帧，则发发送最大数目的帧数，否则立即向下一个结点转发该令牌。 5.3.4 DOCSIS：用于电缆因特网接入的链路层协议一个电缆因特网通常在电缆网头端将几千个住宅电缆调制解调器与一个电缆调制解调器端接系统（Cable Modem Termination System，CMTS）连接。数据经电缆服务接口（Date-Over-Cable Service Interface，DOCSIS）规范定义了电缆数据网络体系结构及其协议。 DOCSIS是一种对于电缆接入因特网的链路层协议，包含了FDM、TDM、随机接入和集中分配时隙等技术。 5.4 交换局域网5.4.1 链路层寻址和ARP通过交换机的路径，使用的是链路层地址而不是IP地址。 地址解析协议（ARP），负责网络地址到链路层地址的转换的机制。 1、MAC地址当某适配器要向某些目的适配器发送一个帧时，将目的MAC地址封装到该帧中并进行广播，收到该广播的适配器进行MAC地址匹配，不匹配则丢弃。匹配则将该数据报沿协议栈向上传递。如果适配器需要让局域网中的所有适配器来接受并处理发送的帧，则使用一个特殊的MAC广播地址（broadcast address），如FF-FF-FF-FF-FF-FF。类比于IP地址中的广播地址（255.255.255.255） 不同的层次需要不同的寻址方案以便更加灵活的使用，目前已经接触到了：应用层的主机名（如域名）、网络层的IP地址以及链路层的MAC地址。 2、地址解析协议ARP将一个IP地址解析为MAC地址，类比于DNS。但是ARP只为在同一子网上的主机和路由器接口解析IP地址。 每个主机或路由器在其内存中都具有一个ARP表（ARP table），这张表包含IP地址到MAC地址的映射关系。如果当时发送方的ARP表中不存在目的方的IP和MAC地址映射，发送方首先构造一个称为ARP分组（ARP packet）的特殊分组。ARP查询分组的目的是询问子网中所有其他主机和路由器，以确定对应于要解析的IP地址的那个MAC地址。ARP分组的发送使用广播地址，即发送方知识适配器应该用MAC广播地址（FF-FF-FF-FF-FF-FF），然后，每个适配器都把该帧的ARP分组向上传递进ARP模块，ARP模块进行判断并返回标准帧，发送方更新ARP表并继续进行发送。 ARP是链路层协议还是一个网络层协议？一个ARP分组封装在链路层帧上，因此从结构上说位于链路层。然后ARP分组即包含链路层地址也包含网络层地址，因此可以认为ARP是跨越链路层和网路程边界两边的协议。 局域网中所有主机的ip及MAC地址查看。cmd arp -a 3、发送数据到子网之外一台路由器对他的每个接口都有一个IP地址、一个ARP模块和一个适配器。 当从子网1的某台主机发送一个数据报到子网2的某台主机？过程如何？该数据报的MAC地址指明为路由接口的MAC地址，路由器接收到帧，并将其传递给路由器的网络层，路由器根据转发表将数据报转发到子网2，子网2再根据MAC地址定位到目的主机。 5.4.2 以太网1、以太网帧结构以太网帧封装了IP数据报。其结构是： 所有的以太网技术都向网络层提供无连接服务。即，当适配器A要向适配器B发送一个数据报时，适配器A将以太网帧发送到局域网中，并没有与适配器B事先握手。这种第二层的无连接服务类似于IP的第三层数据报服务和UDP的第4层无连接服务。 以太网技术向网络层提供不可靠的服务。对于传输的帧不发送确认帧或者否定确认帧（直接丢弃出错帧）。 2、以太网技术以太网经过了30多年的发展，变化巨大，速度已经增加了3个数量级。由于现代交换机的应用，协调其传输，在基于交换机的以太局域网中，不会有碰撞，也没有必要使用MAC协议（媒体访问控制协议）了。 5.4.3 链路层交换机将接受入链路层帧并将它们转发到出链路。交换机的特性：1、透明的。2、带有缓存。 交换机功能： 1、交换机转发和过滤过滤（filter）：决定一个帧是转发到某个接口还是应当将其丢弃。转发（forwarding）：决定一个帧应该被导向哪个接口，并移动到那些接口。 过滤和转发依赖于交换机表（switch table） 交换机表项包括：MAC地址||通向该MAC地址的交换机接口||表项放置在表中的时间 交换机工作过程： 当从接口x接收到目的MAC地址时，将对交换机表进行查找，如果匹配不上，则对所有接口进行广播（谁知道目的MAC怎么走？） 如果匹配上了但是接口仍是x，说明该请求是从包含目的MAC地址的局域网网段发送过来的，不需要进行转发而是直接将该副本丢弃执行过滤功能。 如果匹配上了且接口不等于x，说明目的MAC在别的局域网网段，则将帧放在目的接口的输出缓存完成转发功能。 2、自学习交换机表是自动的、动态和自治的建立起来的。即交换机是自学习的。 表现在： 初始表为空 对每个到达帧：1、源MAC地址存储。2、到达接口存储。3、到达时间存储。 超过老化期，将表项删除。（持续更新） 交换机是即插即用设备（plug-and-play device），即不需配置什么的。交换机还是全双工的，意味着可以同时进行接收和发送。 3、链路层交换机的性质 消除了碰撞：交换机存在缓存，不会在网段同时传输多于一个帧。 异质的链路：交换机将链路彼此隔离，因此不同链路能够以不同速率运行并且能在不同的媒体上运行。 管理：更加便于管理。 4、路由器和交换机的比较路由器和交换机都是存储转发分组交换机，但他们还是有区别的： 交换机使用MAC地址转发分组。路由器使用网络地址。 交换机是第二层的分组交换机，而路由器是第三层的分组交换机。 各自的优缺点：交换机的优缺点： 即插即用 交换机处理高至第二层的帧，相对于路由器的第三层，其过滤和转发速率更快。 对网络的结构有限制，对广播风暴没有防护，大型网络容易崩溃。 路由器的优缺点： 网络寻址不想MAC寻址那样扁平化，而是分层次的，即使存在冗余路径，也不会通过路由器循环。 没有生成树限制，允许以丰富的拓扑结构构件因特网。 对广播风暴提供防火墙保护。 缺点：不是即插即用，需要人为的配置路由器的IP地址，对每个分组的处理时间较交换机更长。 什么时候使用交换机？什么时候使用路由器？局域网的规模越大越倾向于使用路由器。其提供了更健壮的流量隔离方式和对广播风暴的控制。 5.4.4 虚拟局域网虚拟局域网（Virtula Local Network，VLAN），支持VLAN的交换机允许一个单一的物理局域网基础设施定义多个虚拟局域网。 在该种交换机中，交换机的端口由管理员划分成组，指定属于每个VLAN的MAC地址的集合并对应正确的端口即可将主机分为不同的局域网络组，无论何时一个设备与一个端口连接时，端口基于设备的MAC地址将其连接进适当的VLAN。 不同的组之间通过VLAN干线（VLAN trunking）连接。跨VLAN的帧通过VLAN标签（VLAN tag）找寻目的VLAN，并在目的VLAN将添加进的首部（VLAN标签）剔除。 5.6 数据中心网络P326 5.7 Web请求页面的流程5.7.1 准备：DHCP、UDP、IP和以太网步骤： 生成一个DHCP请求报文，并将这个报文放入DHCP服务器的67端口和源端口68（DHCP客户）的UDP报文段，该报文段被置于一个具有广播IP地址（255.255.255.255）和源IP地址（0.0.0.0）的IP数据报中，因为此时的机器还不具备IP地址。 包含DHCP的IP数据报被放置到以太网帧中，该以太网帧具有目的MAC地址（FF:FF:FF:FF:FF:FF），使该帧将广播到交换机所连接的所有设备（目标是DHCP服务器）；该帧的源MAC地址是本机的MAC地址（假设BB:BB:BB:BB:BB:BB）。 包含DHCP请求的以太网帧是第一个本机发送到以太网交换机的帧，该交换机在所有的出口端广播帧，包括连接到路由器的端口。 DHCP服务器在它的MAC地址（假设是AA:AA:AA:AA:AA:AA）的接口接受到此以太网帧，该帧中包含DHCP请求，并且从该以太网帧中抽取出IP数据报。该数据报的广播IP地址指示了这个IP数据报应当由在该节点的高层协议处理，因此该数据报的载荷（一个UDP报文段）被分解向上到达UDP，DHCP请求报文从此UDP报文段中抽取出来，此时DHCP服务器收到了DHCP请求报文。 DHCP服务器根据地址快（CIDR）给本机分配了一个IP地址，假设CIDR块为222.28.60.0/24，分配的IP地址为（222.28.60.45）。DHCP服务器生成包含这个IP地址以及DNS服务器的IP地址（202.204.48.8）、默认网关路由器的IP地址（222.28.60.1）和子网块（222.28.60.0/24，等价为“网络掩码”）的一个DHCP ACK报文。该报文被置入一个UDP报文段中，UDP报文段被放置一个IP数据报，IP数据报再被放入一个以太网帧。这个以太网帧的源MAC地址是路由器练到归属网络的接口，目的MAC地址是本机的MAC地址（BB:BB:BB:BB:BB:BB）。 包含DHCP ACK的以太网帧有路由器发送给交换机，因为交换机是自学习的，并且先前从本机收到以太网帧，所以该交换机能寻址到本机的MAC地址所以仅从通往本机的输出端口转发。 本机收到包含DHCP ACK的以太网帧，从该以太网帧中抽取IP数据报，从IP数据报中抽取UDP报文段，从UDP报文段中抽取DHCP ACK报文。DHCP客户记录本机的IP地址、本地DNS服务器地址，且还在IP转发表中安装默认网关的地址。本机将向该默认网关发送目的地址为其子网222.28.60.0/24以外的所有数据报。此时本机已经初始化好了所有的网络组件。 5.7.2 仍在准备：DNS和ARP当键入一个域名网址时。Web浏览器生成一个TCP套接字开始了该过程。套接字用于想baidu.com发送HTTP请求，为知道baidu.com的IP，需要使用DNS协议将域名转换到IP地址 本机生成一个DNS查询报文，将baidu.com放入DNS报文的问题段中，该报文段放置在一个具有53号目的端口的UDP报文段中，该UDP报文段则被放入具有目的IP地址（DNS服务器：202.204.48.8）和源IP地址（本机IP：222.28.60.45）的IP数据报中。 将所有的DNS请求放入一个以太网帧中，该帧将在链路层上寻址到网关路由器，尽管知道了默认网关服务器的IP地址，但在链路层中需要MAC地址，此时需要使用到ARP协议。 本机生成一个具有目的IP地址（222.28.60.1）的ARP查询报文，将该ARP查询报文放置在一个具有广播地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧交付给所有的连接设备，包括网关路由器。 网关路由器在通往本机网络块的端口接收到包含该ARP查询报文的帧，发现其目的IP地址匹配自己接口的IP地址，因此准备了一个ARP回答，指示他的MAC地址（CC:CC:CC:CC:CC:CC）对应IP（222.28.60.1），将回答放入一个以太网帧中，其目的地址是本机（BB:BB:BB:BB:BB:BB），并向交换机发送该帧，再由交换机将帧交付给本机。 本机接受到包含ARP回答报文的帧，并从ARP回答报文中抽取网关路由器的MAC地址（CC:CC:CC:CC:CC:CC）。 本机最终能够使包含DNS查询报文的以太网帧寻址到网关服务器的MAC地址。该帧中的IP数据报具有IP目的地址（202.204.48.8，本地DNS服务器），而该帧具有目的地址（CC:CC:CC:CC:CC:CC，网关服务器），本机向交换机发送该帧，交换机将该帧交付给网关路由器。 5.7.3 仍在准备：域内路由选择到DNS服务器 网关路由器接受该帧并抽取包含DNS查询的IP数据报，查询目的地址（202.204.48.8），根据转发表将数据报发送到指定输出端口。 在路由器之间根据路右转发表确定出接口，而转发表已经根据域内协议（RIP、OSPF或IS-IS）以及因特网域间协议BGP所填写。 最终包含DNS查询的IP数据报到达DNS服务器，在DNS数据库中查找baidu.com，找到包含其IP地址的DNS源记录。这种缓存数据来自权威DNS服务器。该DNS服务器形成了一个包含baidu.com到IP地址的映射的DNS回答报文。该报文放置到UDP报文段，该报文段放置到寻址到本机IP地址的IP数据报中，该数据报将原路返回转发到学校的路由器，并从这里经过以太网交换机到本机。 本机从DNS报文中抽取出baidu.com的IP地址，并开始准备访问。 5.7.4 Web客户-服务器交互：TCP和HTTP 生成TCP套接字（socket），该套接字用于向baidu.com发送HTTP GET报文。当生成socket时，必须与baidu.com执行三次握手。因此首先生成一个具有目的端口80（只针对HTTP）的TCP SYN报文段，该报文放置到具有目的IP地址（119.75.217.109，百度）的IP数据报中，该数据报又封装到具有目的MAC地址（CC:CC:CC:CC:CC:CC，网关路由器）的帧中，并向交换机发送该帧。 从学校网络、联通网络、百度网络中的路由器朝着baidu.com转发包含TCP SYN数据报，使用每台路由器的准发表。联通网络、百度网络之间的转发表是通过域间协议BGP制定的。 最终，包含TCP SYN的数据报到达baidu.com服务器，从数据报抽取出TCP SYN报文并分解到与端口80相联系的欢迎套接字。对于baidu.com和本机之间的连接生成一个连接套接字，产生一个SYNACK报文段，将其放入向本机寻址的一个数据报中，最后放入链路层帧，该链路适合将baidu.com连接到其第一跳路由器。 包含TCP SYNACK报文段的数据报通过百度网络、联通网络、学校网路（自治系统），最终到达本机的以太网卡，数据报在操作系统中分解到步骤18生成的TCP套接字，从而进入连接状态。 借助本机上的套接字（socket），准备向baidu.com发送字节了。浏览器生成包含要获得的URL的HTTP GET报文，HTTP GET报文则写进套接字，其中GET报文成为一个TCP报文段的载荷。该TCP报文段放置进一个数据报中，并交付到baidu.com，如18~20描述的那样。 目的服务器从TCP套接字读取HTTP GET报文，生成一个HTTP响应报文，将请求的Web页面放入HTTP响应体中，并将报文发送到TCP套接字中。 包含HTTP响应报文的数据报通过百度网络、联通网络、学校网络转发到达本机，本机的浏览器程序从套接字读取HTTP响应，从HTTP响应体中抽取Web网页的html，并最终显示到浏览器上。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络（4） 网络层]]></title>
    <url>%2F2019%2F02%2F14%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%884%EF%BC%89%20%E7%BD%91%E7%BB%9C%E5%B1%82%2F</url>
    <content type="text"><![CDATA[计算机网络（4） 网络层计算机网络：自顶向下方法（第六版） 两种用于构造网络层分组交付的方法：数据报模式和虚电路模式。 转发（forwarding）和路由选择(routing)的区别？转发涉及分组在单一的路由器从一条入链路到一条出链路的传送。路由选择涉及一个网络的所有路由器，它们经路由选择协议共同交互，以决定分组从源到目的地节点所采用的路径。 4.1.1 转发和路由选择转发：从入链路到出链路。路由选择：分组所采用的的路由或路径。 类比于出行从某地到某地，路由选择相当于之前的路线规划，而立交桥、环岛之类的分差口则相当于路由器，公路相当于链路。 4.2 虚电路和数据网络报网路层也能够在两台主机之间提供无连接服务或连接服务。网络层：提供主机到主机的服务。运输层：提供进程到进程之间的服务。 网络层连接服务除了在端系统中，也在位于网络核心的路由器中实现。 4.2.1 虚电路网络组成： 源和目的主机之间的路径（即一系列链路和路由器） VC号，沿着改路径的每段链路的一个号码。 沿着该路径的每台路由器的转发表表项。 无论何时跨越一台路由器创建一条新的虚电路，转发表就增加一个新表项；终止则减少。 对一个虚电路网络层，沿两个端系统之间路径上的路由器都要参与虚电路的建立，且每台路由器都完全知道经过它的所有电路。 VC号用来表示虚电路中的链路，在虚电路中，该网络中的路由器必须为进行中的连接维持连接状态信息（connection state information），即维持实时的转发表。 端系统向网路发送指示虚电路启动或终止的报文，以及路由器之间用来建立虚电路的报文，被称为信令报文，用来交换这些报文的协议成为信令协议。 4.2.2 数据报网络数据网络报是无连接的，路由器不维护任何虚电路的状态信息。 每台路由器有一个将目的地址映射到链路接口的转发表。路由器用分组的目的地址的前缀（prefix）与该表中的表项进行匹配，当有多个匹配时，使用最长前缀匹配（longest prefix matching rule），路由器不维护连接状态信息，但是维护了转发状态信息。 转发表由路由选择算法更改和更新，位于软件层，即管理控制平面。 4.3 路由器工作原理4个组成部分： 输入端口：三个功能：1、执行将一条输入物理链路与路由器相连接的物理层功能，即接口。2、执行与入链路远端的数据链路层交互 的数据链路层功能。3、查找功能，通过查找转发表，确定分组转发到哪个输出端口（接口） 交换结构：后面说。 输出端口：输出端口存储从交换结构接受的分组，并通过执行必要的链路层功能在输入链路上传输这些分组。 路由选择处理器：执行路由选择协议，维护路由选择表以及连接的链路状态信息。 前三个部分是路由器转发平面（router forwarding plane），响应快，硬件实现。最后一个是路由器控制平面（router control plane），软件实现，毫秒或秒尺度运行。所以1-5min才更新一次转发表。 4.3.1 输入端口输入端口执行的查找功能尤其重要，分组找到输出端口，等待交换。转发表从路由选择处理器经过PCI总线复制到线路卡，在线路卡上进行查找，推入交换结构。 4.3.2 交换结构 经内存交换：可理解为小型的CPU。 经总线交换。 经互联网络交换。 4.3.3 输出端口输出端口取出存放在输出端口内存中的分组并将其发送到输出链路上。这包括选择和取出排队的分组进行传输，执行所需的链路层和物理层传输功能。 4.3.4 何时需要排队当所有分组去往同一输出端口时，输出端口需要排队。当有过多的 缓存计算：经验方法，缓存数量（B）应等于平均往返时延乘以链路的容量。250msRTT的10Gbps链路的缓存量：RTT*C = 2.5Gbps。当有大量的TCP流（N）流过一条链路时，缓存量再除以开根号N。 线路前部阻塞（Head-Of-the-Line，HOL）：无竞争的分组被迫等待交换。 4.4 网际协议：因特网中的转发和编址IPV4和IPV6 4.4.1 数据报格式 版本号：IPV4 or IPV6？不同版本号使用不同的报文格式。 首部长度：由于选项字段可变，因此首部字段的长度可变，需要4比特的首部长度字段确定数据部分实际从哪里开始。如不包含选项字段，IP数据报则只有20字节的首部。 服务类型：（TOS）区分不同类型的IP数据报。 数据报长度：数据报的总长度，首部加上数据，以字节计算。该字段16bit，因此范围有65535字节，但IP数据报很少超过1500。 标识、标识、片偏移：与IP分片有关系，后面将进行介绍。IPV6上面没有。 寿命：寿命（Time-To-Live，TTL）确保数据报刽永远在网络中循环。没经过一台路由器，字段值减1，到0数据报被丢弃。 协议：仅在一个数据报到达其最终目的地才会有用。指示了IP数据报的数据部分应交给哪个特定的运输层协议。如：6代表TCP，17代表交给UDP。其和运输层中的端口号字段相似。协议号将网路层与运输层绑定在一起，端口号将运输层和应用层绑定到一起。链路层也由一个特殊字段将链路层和网络层绑定在一起。 首部检验和：和UDP的原理一样，但是IP层只检验IP首部的检验和，和TCP/UDP重复检验的原因是两者不一定都必须属于同一个协议栈，原则上TCP能运行在不同的协议上（如ATM），而IP能够携带不一定要传递给TCP、UDP的数据。 源和目的地址：很好理解。 选项：没什么乱用，IPV6已取出。 数据：有效载荷，封装了TCP/UDP报文段，以及其他的数据。如果包含的是TCP报文段，则一个IP数据报共承载了40字节的首部（自身的20+TCP的20）以及应用层报文！ IP数据报分片一个链路层所能承受的最大数据量称为最大传输单元（Maximum Transimission Unit，MTU），链路层协议的MTU严格的限制这IP数据报的长度。 分片：用单路的链路层帧封装小的IP数据报，然后向输出链路发送，每个链路层帧称为片（fragment）。 片到达目的地运输层之前需要重新组装。此时标识、标志和片偏移起到了作用。 标识：相同初始数据报分出来的片具有原始的标识号。 标志：0表示是最后一个片。 片偏移：表示片插入的位置。（偏移量*8 字节，偏移量以8字节块为单位） 分片有开销并且容易被供给，因此IPV6废除了分片。 4.4.2 IPV4编址一台主机通常只有一条链路连接到网络，主机与物理链路之间的边界叫做接口（interface）。 关于IP地址的知识：http://blog.csdn.net/bilter/article/details/6999511 以及什么是网关：http://www.jb51.net/network/299907.html 网关的英文名称：gateway，又叫做网间连接器、协议转换器。网关是在采用不同体系结构或协议的网络之间进行互通时，用于提供协议转换、路由选择、数据交换等网络兼容功能的设施。一般来说，路由器的LAN接口的IP地址就是你所在局域网中的网关。当你所在的局域网的计算机需要和其它局域网中的计算机，或者需要访问互联网的时候，你所在局域网的计算机会先把数据包传输到网关（路由器的LAN接口），然后再由网关进行转发。这就是为什么我们在有路由器上网的时候，必须要把计算机中的默认网关地址设置成路由器LAN接口的地址的原因，因为路由器的LAN接口就是你所在网络的网关，你的电脑要上网，数据包必须要经过网关转发出去。目前家用路由器一般使用192.168.1.1和192.168.0.1作为LAN接口的地址，这两个地址也是最常见的网关地址。作为普通的用户，只需要记住，手动配置ip地址的时候，默认网关的地址就是路由器的LAN接口的地址，也就是你路由器的管理页面登陆地址。如果你选择自动获取ip地址，那么就不需要关注默认网关地址了，但路由器的DHCP服务器分配下来的默认网关也一定是路由器的LAN接口的ip地址。 以及神回复：https://zhidao.baidu.com/question/26545852.html 网关是一种充当转换重任的计算机系统或设备。在使用不同的通信协议、数据格式或语言,甚至体系结构完全不同的两种系统之间，网关是一个翻译器。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。同时，网关也可以提供过滤和安全功能。大多数网关运行在OSI 7层协议的顶层–应用层。大家都知道，从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络向另一个网络发送信息，也必须经过一道“关口”，这道关口就是网关。顾名思义，网关(Gateway)就是一个网络连接到另一个网络的“关口”。按照不同的分类标准，网关也有很多种。TCP/IP协议里的网关是最常用的，在这里我们所讲的“网关”均指TCP/IP协议下的网关。那么网关到底是什么呢？网关实质上是一个网络通向其他网络的IP地址。比如有网络A和网络B，网络A的IP地址范围为“192.168.1.1~192. 168.1.254”，子网掩码为255.255.255.0；网络B的IP地址范围为“192.168.2.1~192.168.2.254”，子网掩码为255.255.255.0。在没有路由器的情况下，两个网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机(或集线器)上，TCP/IP协议也会根据子网掩码(255.255.255.0)判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机(如附图所示)。网络B向网络A转发数据包的过程。所以说，只有设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。那么这个IP地址是哪台机器的IP地址呢？网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器(实质上相当于一台路由器)、代理服务器(也相当于一台路由器)。 子网：隔离的网络岛。 223.1.1.0/24表示：前24位为前缀的子网。可以分配2^8个IP地址。 IP地址255.255.255.255是广播地址，作用之一在获取IP地址时有用。 IP地址由一权威机构负责分配。 获取主机地址：动态主机协议配置动态主机配置协议（Dynamic Host Configuration Protocol，DHCP），动态的从地址池中分配IP地址的技术。通常由一个DHCP服务器来完成，如果没有DHCP服务器，则需要DHCP中继代理，这代理知道DNCP服务器的地址。 主机获取地址的步骤： DHCP服务器发现阶段：DHCP发现报文，向67端口发送改报文，使用广博地址255.255.255.255和本机地址0.0.0.0。 DHCP服务器提供阶段：收到DHCP发现报文，用一个DHCP提供报文作为响应，仍然使用广播（注意端口是68，和源端口一样）。提供报文信息包括收到的发现报文的ID、向客户端推荐的IP地址、网络掩码以及IP地址租用期。 DHCP请求阶段：发送DHCP请求报文，回显配置参数。 DHCP ACK：响应。 网络地址转换网络地址转换（Network Address Translation，NAT），由内网转换到外网。 NAT转换表（NAT Transmission Table），即内网的IP端口对应外网的IP端口。 NAT可以用来缓解IPV4地址不够用的问题，但是却妨碍了P2P程序的运行，因为处于不同内网的用户很难直接建立TCP连接。 UPnPUPnP通用即插即用，允许外部主机使用TCP或UDP向NAT化的主机发起通信会话。 4.4.3 因特网控制报文协议P236网络层3个主要组件：1、IP协议。2、因特网路由选择协议。3、因特网控制报文协议（ICMP）。 ICMP被主机和路由器用来彼此沟通网络层的信息。 ICMP报文被认为IP的一部分，作为有效载荷被承载在IP数据报中（和TCP报文段一样）。 4.4.4 IPV6数据报格式 重要变化： 扩大的地址容量，32bit到128bit。 简化高效的40字节首部 流标签和优先级 字段： 版本：6bit的字段。IPV4为4bit。 流量类型：8bit，可以规定某个流的优先级，相当于IPV4的TOS。 流标签：标识一条数据报的流。 有效载荷长度：数据报中跟在40字节首部之后的字节数量。 下一个首部：和IPV4的上层协议相同，代表交付给哪个运输层协议。 跳限制：和IPV4的TTL相同，没经过一个路由器减一，为零时，该数据报将被丢弃。 源地址和目的地址：IPV6地址。 数据：有效载荷部分。 IPV6丢弃了IPV4中的一些字段： 分片/重新组装：IPV6不允许在路由器上进行分片和重新组装。这种操作只能在源和目的地上执行，路由器如果收到太大的数据报文，则只需要丢弃并返回“分组太大”的ICMP报文。发送方则使用较小长度的IP数据报重发数据。分片与重新组装是一个耗时的操作，将该功能从路由器中删除并放到端系统中，大大加快了网络中的IP转发速度。 首部检验和：IPV4对首部字段进行检验和检验，由于TTL的缘故，没经过一个路由器需要重新计算，此过程费事耗力，IPV6将其去之。 选项字段。 IPV4到IPV6的转换双栈（dual-stack）的方法： 两种报文在不同路由器之间进行转换。缺点：IPV6转到IPV4时，V4上不存在的字段可能会出现丢失。 建隧道（tunneling）的方式，两个IPV6节点中的IPV4集合称为隧道，在隧道发送端，将整个IPV6数据报封装到IPV4的有效载荷中，改IPV4指向该隧道的接收端，到接收端时进行取出IPV6数据报继续进行传输。 4.5 路由选择算法分类方式：1、全局式or分散式全局式路由选择算法：链路状态（Link state，LS）算法。分散式路由选择算法：距离向量（Distance-Vector，DV）算法。 具体实现：P245总目标：找出最短带权路径，即费用最低的路径。 2、静态的or动态的。3、负载敏感or负载不敏感 4.5.3 层次路由选择运行统一路由算法的路由器集合可以成为一个层次。 组织需要按照自己的意愿运行路由器（如运行其选择的某种路由选择算法），或对外隐藏其网络的内部组织。可以通过自治系统（Autonomous System，AS）。 自治系统内部路由选择协议一个自治系统内部运行的路由选择算法叫做自治系统内部路由选择协议（intra-autonomous system routing protocol）。将AS互联的路由器称为网关路由器（gateway router）。 自治系统间路由选择协议自治系统间路由选择协议（inter-autonomous system routing protocol）：从相邻AS获取可达性信息和向该AS中的所有路由器传播可达性信息。AS间路由选择协议：通用BGP4。 因此，每个路由器转发表接受AS内部路由选择协议和一个AS间路由选择协议的信息，并使用来自这两个协议的信息配置它的转发表。 CIDR（无类别域间路由选择，Classless Interdomain Routing）。P227 在路由器的转发表中增加一个AS之外的目的地的步骤： 从AS间协议知道经过多个网关可以到达子网x 使用来自AS内部协议的路由选择信息，以决定到每个网关的最低费用路径的费用。 热土豆路由选择（hot potato routing）：当具有多条AS间路径时，选择具有最小的最低费用的网关路径。 从转发表确定通向最低费用网关的接口I，将（x，I）项添加到转发表中。 4.6 因特网中的路由选择4.6.1 自治系统内部的路由选择：RIPAS内部路由选择协议又称为内部网关协议（inner gateway protocol）。 包括：路由选择信息协议（Routing Information Protocol，RIP）与开放最短优先（Open Shortest Path First，OSPF）。 跳：沿着从源路由器到目的子网的最短路径所经过的子网数量，每个路由器中维护一张称为路由选择表的RIP表，邻居之间通过使用一种RIP响应报文（RIP response message）交换信息，大约30s更新一次路由选择表。 当路由器在180s后没有收到更新，则主动发送RIP请求报文请求更新。 路由器在UDP上使用端口520相互发送RIP请求与响应报文，并封装在标准IP数据报中的UDP报文段在路由器之间传输。简而言之，RIP使用一个位于网络层协议（IP）之上的运输层协议（UDP）来实现网络层功能（一种路由选择算法），而RIP本身是一个运行在UDP上的应用层协议。 4.6.2 因特网中自治系统内部的路由选择：OSPFOSPF具有很多先进特性，核心之一就是使用洪泛链路状态信息的链路状态协议和一个Dijkstra最低费用的路径算法。 使用OSPF时，路由器向自治系统内所有其他路由器广播路由选择信息，而不仅仅是向其相邻路由器广播。每一条链路的状态发生变化，路由器就会广播链路状态信息。 OSPF的优点： 安全：能够鉴别OSPF路由器之间的交换。能够配置简单模式和MD5模式。 多态相同费用的路径：允许使用多条相同费用的路径。 对单播和多播路由选择的综合支持。 支持在单个路由选择域内的层次结构。即在AS内部再次分层次。 一个OSPF自治系统可以配置成多个区域，每个区域都运行自己的OSPF链路状态路由选择算法，一个区域内的每台路由器都向该区域内的所有其他路由器广播其链路状态。而主干区域（一个OSPF自治系统只有一个）负责区域之间的路由选择。 关于RIP和OSPF的区别：http://blog.chinaunix.net/uid-26275986-id-4107596.html 4.6.3 自治系统间的路由选择：BGP边际网关协议（Broder Gateway Protocol，BGP）：决定了分组在自治系统的网关路由器之间如何传输。 步骤： 从相邻AS处获得子网可达性信息。 向本AS内部的所有路由器传播这些可达性信息。 基于可达性信息和AS策略，决定到达子网的“好”路由。 BGP使得每个子网向因特网的其余部分通告它的存在，起到了广而告之的作用。 4.7 广播和多播路由选择先放一放]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络（3） 运输层]]></title>
    <url>%2F2019%2F02%2F14%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%883%EF%BC%89%20%E8%BF%90%E8%BE%93%E5%B1%82%2F</url>
    <content type="text"><![CDATA[计算机网络（3） 运输层计算机网络：自顶向下方法（第六版） 3.1.1 运输层和网络层的关系网络层提供主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供逻辑通信。 3.2 多路复用和多路分解一个进程有一个或多个套接字，它相当于进程向网络或网络向进程传递数据的门户。 将运输层报文段中的数据交付到正确的套接字的工作称为多路分解。从源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（将在以后用于分解）从而生成报文段，然后将报文段传递到网络层，所有这些工作称为多路复用。 1、无连接的多路复用和多路分解UDP的套接字 是一个二元组来标识的，包含目的IP地址和目的端口。 2、面向连接的多路复用与多路分解TCP的套接字是一个四元组，包括源IP地址、源端口号、目的IP地址、目的端口号。 3、Web服务器与TCP连接套接字与进程之间并非一一对应，许多高性能的Web服务器通常只是用一个进程，而为每个客户连接创建一个具有新连接套接字的新线程。（线程可以先背理解成一个轻量级的子进程） 3.3 无连接运输：UDP运输层最低要求：提供数据交付（分解/复用）+差错检查的功能。而UDP仅仅做到了这两点，因此使用UDP近似于应用层和网络层直接连接。 DNS是一个通常使用UDP的应用层协议的例子。 UDP的优点： 更加细粒度，关于何时、发送什么数据的应用层控制更为精细。 无需建立连接：使得DNS速度更快。 无连接状态 分组首部开销小：每个TCP报文段有20字节的首部开销，UDP仅有8字节的首部开销。 3.3.1 UDP报文结构UDP首部包括四个字段：源端口号、目的端口号、长度、检验和。每个字段2个字节，一共8个字节。UDP套接字由一个二元组来全面标识：目的IP、目的端口号。 3.3.2 UDP检验和差错检测，以3个16bit为例：三个相加（溢出要回卷）求反得检验和，检验和再和三个数据相加（同样要回卷），如果最后得到16位1，则说明没有差错。 如果端对端之间要提供差错检测，UDP就必须在端对端基础上在运输层提供差错检测。根据端到端原文，尽可能的在较高级别实现端到端的某种功能以降低实现所付出的代价。 UDP能提供差错检测，但是对差错回复无能为力，只是将受损的报文段交给应用程序并给出警告。 3.4 可靠数据传输原理分组（packet） 3.4.1 构造可靠数据传输协议 停等（stop-and-wait）协议：仅当接受到ACK才能发送下个分组。 先以停等协议作为简化讨论，当接收端接受到数据时，利用检验和（check sum）对数据的正确性进行确认，确认正确返回ACK（positive acknowledgement）。否则返回NAK（negative acknowledgement）。在停等协议中，发送端只有确认上个分组传输正确才会继续发送。但是对于ACK和NAK本身而言又有错误传输的可能性，因此引入了序号（sequence number）的概念。序号的作用是用于接收端比对，如果和之前的分组序号相同，即可确认为重传，否则就是新的分组。停等一次只能发送一个分组，因此序号为模2（即[0,1]）即可。倒计数定时器（countdown timer）的作用是在一个已发送分组迟迟不能收到反馈时（可能已经丢失，接收方也不知道已经发送过来），在计时器终点，应重新发送该组数据并重启计时器。计时器是为了实现基于时间的重传机制。 由于停等协议效率太过低下（实际推入网络在整个分组传输区间所占比重太小），因此出现了流水线（pipelining）技术。 流水线技术：发送方一次可以发送多个分组，而不用等待第一个分组的反馈。它的出现有以下影响： 必须增加序号的范围，因为每次输出的分组必须要一个唯一的序号，停等：{0，1}。流水线：{0,1…，N-1}（N表示窗口大小） 协议的发送方和接收方两端也许（根据处理错误的方式确定）必须能够缓存多个分组，用于重传和确认。 所需序号和对缓冲的要求取决于数据传输协议如何处理错误的传输。两种基本方法：回退N步（Go-Back-N，GBN）和选择重传（Selective Repeat，SR） 3.4.3 回退N步也称滑动窗口协议。 GBN发送方必须响应三种类型的事件： 上层的调用：上层要发送分组，则应该确认当前窗口是否已满，即是否有N个已发送但未被确认的分组。 收到一个ACK，在GBN中，对序号为n的分组的确认采取累计确认（cumulative acknowledgment）的方式，表明接收方已正确收到n及n之前的所有分组。 超时事件：“回退N步”的名字来源于处理丢失和时延过长分组时发送方的行为。举例：N=4，即窗口大小为4,当第0组正确传输，返回ACK0，此时窗口前进1步到第4组；继续传送第1组，返回ACK1，窗口继续前进到第5组；传送第2组，出现丢失（此时计时器已经在计时了）；继续传送第3组，第4组，第5组，由于序号对不上（传来分组的序号不等于上次传送成功的序号+1），因此一直返回的是ACK1（即最后一次正确传输的分组序号），此时窗口并不能继续前进了，等到计时器时间到，从第2组重新传输。 在GBN协议中，接受方丢弃所有失序分组。这种方法的优点是接收缓存简单，即接受方不需要缓存任何失序分组。 GBN中使用到的技术有：使用序号、累计确认、检验、超时重传操作。潜在的允许发送方用多个分组填充流水线（即窗口前进的机制）。存在的问题：存在过多的不必要的重传，即传输错误之后的分组就算传输正确也不得不被丢弃和重传。选择重传解决了此问题。 3.4.4 选择重传P151起； 失序之后的分组不会丢弃，而是将其放入缓存之中并返回ACK，等待失序的分组重传之后再依次进行交付。发送方中已经确认收到的分组将不会再被发送。 定时器再次用于防止丢失分组，每个分组都要有自己的逻辑计数器，因为超时发生后只能发送一个分组。 在窗口无可发送分组的时候，窗口的第一位一定是丢失的分组，重传改分组会使窗口继续前移。 值得注意的是，当接受方成功接收分组并返回了ACK后，由于某种原因发送方没有收到ACK，在某个时段之后重传了该分组，则接收方应该重新发送一个ACK给发送方，以使窗口前进。 表3-1 可靠数据传输机制及其用途的总结 机制 用途和说明 检验和 检测一个分组传输中的比特错误 定时器 用于处理分组丢失和ACK丢失的超时事件 序号 传输的分组按顺序编号。不连续说明有丢失，重复说明有冗余 确认 传输的一个分组或一组分组（累计确认）被正确的接收到了。确认可以是逐个的或累计的，这取决于协议 否定确认 未被正确的接受，携带未被正确接受的分组号 窗口、流水线 发送方也许被限制仅能发送那些序号落在一个指定范围内的分组。停等模式效率低，流水线模式在未反馈的情况下一次发送多个分组。窗口的长度可以根据接收方接受和缓存报文的能力、网络中的拥塞程度或两者情况来进行设置 Attention之间的假设是发送方发送的分组的相对顺序是不变的，实际上，多条物理链接传输的过程中，分组是可能被重新排序的。对于分组重新排序，信道可被看成基本上是在缓存分组，并将在任意时刻自然的释放这些分组，由于序号会被循环使用，必须注意不能出现冗余分组的情况，实际中采用的方法是确保一个序号不被重新使用，直到发送方确信任何先前发送的分组都不在信道中为止。具体的做法是假定一个分组在网络中“存活”的时间不会超过某个设置的最大时间量来做到这一点。超过这个时间点，基本可以确认信道网络中已经不存在该分组了，所以该分组的序号可以被重新使用了。在高速网络的TCP扩展中，最长的分组寿命被假定为约3分钟。 3.5 面向连接的运输：TCP依赖了：差错检测、重传、累计确认、定时器以及用于序号和确认号的首部字段。 3.5.1 TCP连接握手：连接中间交换某些预备报文段，确保对象是预备态的。 TCP连接提供全双工的服务（full-duplex service），TCP连接是点对点的，即单个连接方和单个连接方之间连接。 TCP可从缓存中取出并放入报文段中的数据数量受限于最大报文段长度（Maximun Segment Size，MSS）。 MSS通常根据最初确定的由本机发送主机发送的最大链路层帧长度（即所谓的最大传输单元（Maximum Transmission Unit，MTU））来设置。 MSS=MTU（通常1500）-TCP/IP首部长度（通过40）=1460 MSS是指在报文段里应用层数据的最大长度，而不是指包括TCP首部的TCP报文段的最大长度。 3.5.2 TCP报文段结构当TCP发送一个发文件时，通常将改文件划分成长度为MSS的若干块。 首部报文段结构如图： 源端口和目的端口：各16bit，用于多路分解和复用。 序号（sequence）和确认号（acknowledgment）字段：各32bit，实现可靠数据传输服务。 接收窗口字段：16bit，指示接受方愿意接受的字节数量。 首度长度字段：4bit，指示了首部字段的长度，由于选项字段是可选的，通常为空。因此典型的TCP首部长度为20（4*5）。 检验和：16bit，和UDP一样，用于数据检验。 选项字段：可选或变长的。用来协议MSS和加时间戳，一般为空。 标志字段：6bit，包括：ACK、RST、SYN、FIN、URG、PSH ACK：确认字段中的值是否有效 RST、SYN、FIN：用于连接的建立和拆除 PSH：立即向上层交付数据。 URG：紧急。 可以参考：http://blog.csdn.net/ningxuezhu/article/details/39892091/http://www.cnblogs.com/xinyuyuanm/archive/2013/04/17/3026279.html 1、序号和确认号 TCP把数据看成无结构的、有序的字节流。 报文段的序号是该报文段手字节的字节流编号，TCP隐式的为每个传输的字节编号。 如序号字段为：1000。表示首字节编号为1000。 确认号：主机A发送给主机B的确认号是主机A期望从主机B接受到的下一字节的序号。TCP只确认该流中至第一个丢失的字节为止，所以TCP被称为累计确认（cumulative acknowledgment）。失序到达的报文字段在TCP中有两个选择：丢弃或者保留，实践中一般选择后者。 Telnet协议中，TCP报文段的数据字段一般为1字节，所以TCP报文段为21字节。当连接上Telnet后，屏幕上敲一个字符，这个字符显示到显示器上已经在网络中传输了一个来回了。 3.5.4 可靠传输协议确认号表示期望收到的下一字节的序号，表示该号之前的所有序号都正确收到。 2、超时间隔加倍超时重传时将定时器的时间设为之前的两倍，因此超时可能是因为网络拥塞造成，如果持续重传，将使拥塞更加严重。然而，当定时器在另两个事件（即收到上层应用的数据和收到ACK）中的任意启动时，定时器由EstimatedRTT（估计往返时间，指数加权移动平均数）值与DevRTT（方差或者偏差）值推算出。 3、快速重传冗余ACK的概念：当出现分组丢失时，发送方发送丢失分组之后的分组，接受方则不断的返回丢失的序号，相同的ACK成为冗余ACK。 当发送方收到相同的ACK三次时，即可确认改序号分组发生了丢失，在定时器到期之前进行重传的行为称为快速重传。 4、是回退N步还是选择重传TCP和GBN一些显著的区别：一些TCP实现实现所谓的选择确认（select acknowledgment）而不是累计确认，它允许TCP接受方有选择的确认失序报文段，而不是累计地确认最后一个正确接受的有序报文段。TCP的差错恢复机制最好被分类为GBN和SR协议的混合混合体。 3.5.5 流量控制一条TCP连接每一侧主机都为该连接设置了接收缓存，当接收到正确、按序的字节后，放入缓存等待应用进程读取，并不是一到达就读取，应用进程也许忙于其他业务，该机制缓解了应用层读取数据的压力。 当应用层读取数据的速度小于传输到接受缓存速率的时间，可能出现缓存溢出的问题。为了解决缓存溢出的问题，需要控制发送发的发送，TCP首部字段中的接受窗口的作用就是用于表示接受方愿意接受的字节数量，其根据缓存容量的剩余大小来确定。以上机制称为流量控制服务（flow-control service）。 而拥塞控制是为了解决IP网络的拥塞而限制TCP发送方的机制。 值得一提的是，UDP协议中不提供流量控制服务。 3.5.6 TCP连接管理1、三次握手： 第一步：SYN被置为1，数据字段为空，此特殊报文段称为SYN报文段，序号设置为初始序号（client_isn（随机））。封装进一个IP数据报中。{SYN=1，seq=client_isn} 第二步：收到连接请求，服务器提取SYN报文段，为该连接分配TCP缓存和变量，并返回{SYN=1，seq=server_isn，ack=client_isn+1}，该允许连接的报文段有时被称为SYNACK报文段。（SYNACK segment） 第三步：在收到SYNACK报文段后，客户也要为该连接分配缓存和变量，客户主机则向服务器发送另外一个报文段，该报文段允许封装应用数据。因为连接已经建立，SYN被置位0。{SYN = 0，seq=client_isn+1，ack = server_isn+1} 2、关闭连接发送FIN=1的报文段，服务器返回确认报文段，并发送自己的终止报文段FIN=1，客户端对发送过来的终止报文段进行确认，此时，在两台主机之间用于该连接的所有资源都被释放了。 3、SYN洪范攻击当客户端不进行第三次握手时，半开的连接会断开，服务器才会释放为该连接分配的资源（通常是1min）。这就为SYN洪范攻击提供了入口，攻击方通过发送大量的连接请求，创建半开的连接从而消耗服务器的资源。 解决的办法是：当服务器首次接收到SYN报文时，不分配资源，只有第二次接收到ACK时，与之前的SYN发送方进行比对（通过cookie），如果发送方合法，则创建全开的连接并分配资源。否则，不予处理。 4、目的端口和服务器套接字不匹配的情况：TCP分组：服务器向源发送一个特殊重置报文段，将RST标志位置位：1。 UDP分组：发送一个特殊的ICMP数据报。 3.7 TCP拥塞控制TCP协议使用端对端拥塞控制而不是使用网络辅助的拥塞控制，因为IP层不向端系统提供任何显式的网络拥塞反馈。 TCP通过感知拥塞程度限制其发送流量的速率。 rwnd：（receive window，接受窗口），接受方中存储的变量，用于流量控制。cwnd：（congestion window，拥塞窗口），发送方中存储从变量，对TCP发送方能够向网络发送流量额速率进行了限制。 窗口大小（未被确认的数据量）不能超过min{rwnd,cwnd}。 TCP连接的每一端都由一个接收缓存、发送缓存和几个变量组成。 通过调整cwnd值，发送方可以调整它向连接发送数据的速率。cwnd/RTT 字节/秒。 问题1：发送方如何感知拥塞？丢包事件：要么出现超时，要么接收到来自发送方的3个冗余ACK。出现拥塞，路由器缓存溢出，引起一个数据报的丢失，出现丢包事件。发送方认为出现了拥塞。 在无拥塞的情况下，发送端通过接受到的ACK扩大其拥塞窗口的长度，当ACK以高速率到达时，长度增加也快，传输速率增长也快，反之，如果因为高时延或包含一段低带宽链路，则拥塞窗口以相当慢的速率增加。因为TCP使用确认来触发（或计时）增大它的拥塞窗口长度，因此TCP被说成是自计时（self-clocking）的。 问题2：如何确定适当的发送速率？既不会造成拥塞，也不会过于低效。 利用丢包事件降低速率。 利用正确的ACK增加速率。 带宽探测：ACK和丢包事件充当隐式信号，并且每个TCP发送方根据异步于其他TCP发送方的本地信息而行动。 TCP拥塞控制算法广受赞誉的TCP拥塞控制算法（TCP congestion control algorithm）包括：慢启动、拥塞避免、快速恢复 慢启动和拥塞避免是TCP的强制部分，快速恢复是推荐部分，并非必须的。 1、慢启动当TCP连接开始，cwnd的值通常为一个MSS（1460），此时传输速率很小。cwnd的增加对每个确认报文增加一个MSS，因此增加的数量是：1,2,4,8,16个MSS。如果cwnd为16MSS，说明在一个RTT可以发送16个报文段。 何时结束这种指数增长呢？方式一：涉及到一个新的变量，ssthresh（慢启动阈值）。当出现一个丢包事件（即拥塞），TCP将cwnd设置为1并重新开始慢启动，将ssthresh设置为cwnd/2。 方式二：当拥塞窗口再次达到ssthresh时，结束慢启动，进入到拥塞避免模式。 方式三：接收到3个冗余ACK时，执行一种快速重传并进入快速恢复状态。 2、拥塞避免模式进入拥塞避免模式时，cwnd = ssthresh。增长cwnd的方式是对每个RTT，增加一个MSS（而不是每个ACK），因此是线性增的。 何时结束这种增长？方式一：出现超时时，cwnd设置为1，ssthresh设置为cwnd/2。方式二：如果接收到3个冗余ACK，反应没有超时那么剧烈，cwnd设置为当前的一半，ssthresh设置为cwnd/2，并进入到快速恢复状态。 可以总结为，出现丢包事件即修改阈值为当前cwnd的一半。 3、快速恢复对每个冗余ACK，增加一个MSS。直到丢失ACK出现，降低cwnd之后进入拥塞避免状态。当丢包事件再次出现时，cwnd的值被设置为一个MSS，ssthresh设置为cwnd的一半，进入慢启动状态。 4、 TCP拥塞控制回顾TCP初始连接时，采用慢启动方式，当出现冗余ACK时，TCP的拥塞控制是：每个RTT内cwnd线性增加1MSS，出现冗余ACK时cwnd减半。因此，TCP拥塞控制常常被称为加性增、乘性减。 因此是锯齿形的网络图。 对于TCP拥塞控制具有很多算法，如TCP Tahoe、TCP Reno（Linux支持）、TCP Vegas（Linux支持）、TCP CUBIC（默认支持）、TCP AIMD算法。 5、对TCP吞吐量的宏观描述当前窗口长度为w字节，且当前往返时间是RTT秒时，则TCP的发送速率大约为w/RTT 字节/秒。 由锯齿状推出，高度简化的模型：平均吞吐量 = 0.75*(W/RTT) （W：拥塞窗口的阈值，即超过此值要丢包，因此降为W/2，再线性增加。） TCP和UDP中公平性的讨论见P188 3.8 小结 UDP仅提供多路复用/分解、数据检验的服务。 TCP更可靠，提供可靠交付、时延保证和带宽保证。然而运输层协议能够提供的服务经常受下面网络层协议服务模型的限制，如果网络层协议不能提供时延保证和带宽保证，运输层协议也就不能向进程间发送的报文提供时延或带宽保证。 可靠数据传输在链路层、网络层、运输层或者应用层协议中都可实现，即使用确认、定时器、重传、序号等技术。但很多都已经被淘汰。 新的运输层协议也在应运而生，数据报拥塞控制协议（Datagram Congestion Control Protocol，DCCP）提供了一种低开销、面向报文、类似于UDP的不可靠服务，但是具有应用程序可选择的拥塞控制机制，该机制与TCP兼容。用于创建可靠或半可靠的连接。 流控制传输协议（Stream Control Transmission Protocol，SCTP）是一种可靠的、面向报文的协议，该协议允许几个不同的应用层次的“流”复用一个SCTP连接。 TCP友好速率控制（Tcp-Friendly Rate Control，TFRC）协议是一种拥有拥塞控制机制但不全面的运输层协议。其目标是平滑在TCP拥塞控制中的“锯齿”行为。同时还维护一种长期的发送速率，改速率合理地接近TCP速率。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络（2） 应用层]]></title>
    <url>%2F2019%2F02%2F14%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%882%EF%BC%89%20%E5%BA%94%E7%94%A8%E5%B1%82%2F</url>
    <content type="text"><![CDATA[计算机网络（2） 应用层 2.1.1应用程序体系结构现代网络应用程序两种主流体系结构：客户-服务器结构和对等（P2P）体系结构。 客户-服务器体系结构：有一个总是打开的主称为服务器。客户之间不直接进行通信。服务器具有固定的、周知的地址。具有客户-服务器体系结构的非常著名的应用程序包括：Web、FTP、Telnet和电子邮件。 数据中心：配备了大量主机，用以创建强大的虚拟服务器。比如：Google在全球有50个数据中心，每个有上10万台主机。 P2P体系结构：对主机对位于数据中心的专用服务器有最小依赖（或者没有），应用程序在间断连接的主机之间进行直接通信，这些主机称为对等方。这种对等方通信不必经过专门的服务器，该体系被称为对等方到对等方的。个人理解，比如：uTorrent下载中，如果没人做种，下载速度将为零，用户的下载速度的和是其对等方上传速度的和。 某些应用具有混合的体系结构，结合了客户-服务器和P2P的元素，例如：对于很多即时讯息应用，服务器被用于跟踪用户的IP地址，但用户到用户的报文在用户主机之间直接发送，无需通过中间服务器。 P2P体系 结构最优的特性是其自扩展性，比如：用户在下载资源的同时也在上传资源，这就为系统增加了服务能力。P2P应用面临的挑战： ISP友好：大多数ISP（包括DSL和电缆ISP）已经受制于“非对称”带宽应用，即下载比上传多得多。未来P2P应用需要设计针对ISP友好的模式。 安全性：由于其高度分布和开放特性带来的风险。 激励：说服用户提供上载、存储资源，即鼓励用户做种。 2.1.2 进程通信在操作系统的概念中，进行通信的实际上是进程而不是程序，一个程序可以被认为是运行在端系统上的一个程序。同一个端系统中的进程之间的通信机制由操作系统决定。不同端系统之间的进程通信通过跨越计算机网络交换报文。 1、客户和服务器进程 在给定的一对进程之间的通信会话场景中，发起通信的进程被称为客户，等待联系的进程是服务器。 2、进程与计算机网络之间的接口从一个进程发送的报文必须通过下面的网络，进程通过一个称为套接字（socket）的软件接口向网络发送报文和从网络接受报文。 套接字是同一台主机内应用层和运输层之间的接口，也可称为应用程序和网络之间的应用程序编程接口（Application Programming Interface，API）。即可理解为：socket是应用程序和网络之间的应用程序编程接口。 应用程序开发者可以控制套接字在应用层端的一切，但是对运输层端的套接字接口几乎没有控制权。开发者对运输层的控制仅限于：1、选择运输层协议。2、设定几个运输层参数：如最大缓存和最大报文段长度。 3、进程寻址接受报文的进程需要具备：1、主机地址。IP地址。2、主机中的进程标识符。端口号。IP地址：定位主机。端口号：定位进程（更具体的说，是接受套接字）。 2.1.3 可供应用程序使用的运输服务运输层协议有多种，决定了对调用它的应用程序提供不同了服务。可从以下四个方面对应用程序要求进行分类： 1、可靠数据传输确保应用程序端发送的数据正确、完全的交付给该应用程序的另一端。成为可靠数据传输（reliable data transfer）。 不可靠数据传输时，数据被容忍丢失的应用（loss-tolerant application）所接受。多媒体应用：如交谈式音频/视频，是这样的，能够承受一定量的数据丢失。 2、吞吐量确保最低吞吐量的服务，具有吞吐量要求的应用程序称为带宽敏感的应用（bandwidth-sensitive application）. 弹性应用（elastic application）能够根据情况或多或少的使用可供使用的吞吐量。如：电子邮件、文件传输以及Web传送。 3、定时针对于对时间有严格要求的应用提供的定式服务，即由发送方套接字到接收方套接字的时间不低于定时时间ms。 4、安全性运输协议能够为应用程序提供一种或多种安全性服务。如：加密/解密、数据完整性和端点鉴别。详见第八章。 2.1.4 因特网提供的运输服务选UDP还是TCP？根据引用程序的服务要求来定。某些应用程序的服务要求： 应用 数据丢失 带宽 时间敏感 文件传输 不能丢失 弹性 不 电子邮件 不能丢失 弹性 不 Web文档 不能丢失 弹性 不 视频/电话会议 容忍丢失 音频（几kb）/视频（10kb-5mb） 是，100ms 存储音频/视频 容忍丢失 同上 是，几秒 交互式游戏 容忍丢失 几kb-10kb 是，100ms 即使讯息 不能丢失 弹性 是 1、TCP服务面向连接和可靠数据传输服务。握手连接，全双工。没有字节的丢失和冗余。 拥塞控制服务抑制发送进程从而防止拥塞 ，对整个互联网的通畅有好处。并且可能限制多个TCP连接达到公平分享网络带宽的目的。 单独的TCP和UDP并不安全，SSL作为TCP的加强，能够提供进程到进程之间的安全性服务。包括：加密、数据完整性和端点鉴别。 2、UDP服务轻量级的运输协议，提供最小服务。面向无连接的，没有握手机制。不可靠数据传送。，没有拥塞控制机制，发送端可以以任何速率向其下层注入数据。 2.1.5 应用层协议应用层协议解决的问题： 交换的报文类型：如请求报文和响应报文 各种报文的语法，如字段语法。 字段的语义：字段包含的信息。 进程何时发送报文，对报文进行响应的规则。 本书介绍了：HTTP、FTP、SMTP、DNS、P2P 2.2 Web和HTTPHTTP，超文本传输协议。 HTTP，无状态协议，服务器不保存关于客户的任何信息。 2.2.2 非持续连接和持续连接非持续连接：一个请求，一个连接。如果一个HTML中包含10的对象（1个HTML，9个jpg），需要连接10次。持续连接：HTTP/1.1开始默认，connection：close即结束连接。 往返时间（Round-Trip Time，RTT）：一个短分组从客户端到服务器再返回客户端所花费的时间。 计算一次请求需花费多少RTT： 建立连接，三次握手机制。前两次花费一个RTT。 第三次发送请求报文，服务器响应，花费一个RTT。 因此，总共花费2个RTT及响应传输时间。 HTTP默认带流水线的持续连接。即一条连接经过一定时间间隔仍未使用，就断开连接。 HTTP请求报文、响应报文就不再赘述了。 利用telnet查看响应报文 Xshell工具（cmd也可以，但是服务端是Linux系统，可能出现字符不兼容的情况） 键入telnet www.baidu.com 80连接到服务器 输入请求头，两次回车请求访问 获取响应头 1234567891011121314151617181920212223242526272829303132333435363738394041GET / HTTP/1.1Host:www.baidu.comHTTP/1.1 200 OKDate: Mon, 03 Apr 2017 04:11:25 GMTContent-Type: text/htmlContent-Length: 14613Last-Modified: Tue, 14 Mar 2017 07:30:00 GMTConnection: Keep-AliveVary: Accept-EncodingSet-Cookie: BAIDUID=C93C498512CB2AF9D8E5FDE7457A229C:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.comSet-Cookie: BIDUPSID=C93C498512CB2AF9D8E5FDE7457A229C; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.comSet-Cookie: PSTM=1491192685; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.comP3P: CP=&quot; OTI DSP COR IVA OUR IND COM &quot;Server: BWS/1.1X-UA-Compatible: IE=Edge,chrome=1Pragma: no-cacheCache-control: no-cacheAccept-Ranges: bytesdata...HEAD / HTTP/1.1Host:www.baidu.comHTTP/1.1 200 OKServer: bfe/1.0.8.18Date: Mon, 03 Apr 2017 04:10:02 GMTContent-Type: text/htmlContent-Length: 277Last-Modified: Mon, 13 Jun 2016 02:50:03 GMTConnection: Keep-AliveETag: &quot;575e1f5b-115&quot;Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transformPragma: no-cacheAccept-Ranges: bytes 2.2.4 关于Cookiecookie技术的四个组件： 响应报文中的Cookie首部。 请求报文中的Cookie首部。 用户端保留一个Cookie文件，并有用户进行管理。 服务端的后端数据库，保存用户的cookie和状态。 2.2.5 Web缓存也称代理服务器。作用：1、大大减少对客户请求的响应时间。2、减少通信量（增加同一资源的复用性）。3、减小源服务端的负荷。 流量强度：传输比特数传输速率（bit/s）的比。L/R。接近将导致时延很大。 缓存服务器命中率，即10次请求有几次可以直接从缓存服务器返回。0-1之间。 通过使用内容分发网络（Content DistributionNetwork，CDN），缓存服务器正在发挥越来越重要的作用。CDN公司在因特网公司安装了很多地理上分散的缓存器，因而使大量流量本地化。（如Google的数据中心） 2.2.6 条件GET方法If-Modified-Since:首部行，缓存器发送给源服务器。如果修改日期晚于指定日期，则从源服务器获取更新的资源，并更新缓存。值得注意的是：指定时间应该和缓存中的Last-Modified相同，即判断当前缓存是否是最新的。如果没更新，源服务器发送304 NotModified报文。 2.3 文件传输协议：FTPFTP使用两个并行的TCP连接来传输文件，一个是控制连接，一个是数据连接。 控制连接端口21，用于传输控制信息，如用户名、密码、改变远程目录以及存放（put）和获取（get）文件的命令。 数据连接端口20，实际数据的发送。 称FTP的控制信息是带外传送（out-of-band），HTTP则是带内传送。也是相对于数据传输的连接而言的。 对FTP传输而言，控制连接贯穿整个用户会话期间，但是对会话中的每一次文件传输都需要建立一个新的数据连接（即数据连接时非持续的）。 FTP服务器必须在整个会话期间保留用户的状态，对每个用户会话的状态信息进行追踪，大大限制了同时维持的会话总数。而HTTP是无状态的，即它不必对用户状态进行追踪。 FTP常见命令和回答：常见命令 USER username：用于向服务器发送用户名 PASS password：发送口令 LIST：请求远程目录列表，改列表经一个新建的且非持续性连接的数据连接发送的，不是在控制连接上传送。 RETR filename：获取一个文件，将会开启数据连接，并发送。 STOR filename：在当前目录存放文件 每个命令对应一个回答。常见回答 331 Username OK，Password required 125 Data connection already open;transfer starting（数据连接已经打开，开始传送） 425 Can’t open data connection（无法打开数据连接） 452 Error writing file（写文件差错） 2.4 因特网中的电子邮件关键组件：用户代理（客户端）、邮件服务器、SMTP（简单邮件传输协议） 几个概念： 邮箱：存在于邮件服务器中 报文队列：发送的邮件队列。 2.4.1 SMTPSMTP一般不使用中间邮件服务器发送邮件，即两个邮件服务器直接相连。 步骤： SMTP客户在端口25建立到服务器SMTP的TCP连接。（三次握手） 连接建立，SMTP也要握手，执行的是某些应用层的握手，握手阶段，指向发送方和接收方的地址。 握手结束，开始利用已经建立的TCP连接传输。 SMTP用的持续连接，多个报文可以通过一个TCP连接。QUIT指令用于结束当前TCP连接。 HELO、MAIL FROM、RCPT TO、DATA、QUIT（.表示一份邮件内容的结束。）这些都是SMTP握手协议的一部分。 2.4.2 与HTTP的对比区别一：HTTP：拉协议（pull protocol）SMTP：推协议（push protocol）区别二SMTP要求每个报文使用7比特的ASCII码格式。区别三如何处理即包含文本和图片的文档？HTTP，每个对象封装成一个响应报文。SMTP，所有报文对象封装进一个报文中。 2.4.3 邮件报文格式和MIME典型报文格式 1234567From:op134972@163.comTo:op134972@126.comSubject:I want to play a game.content . 2.4.4 邮件访问协议流行的邮件访问协议，包括：第三版的邮局协议（Post Office Protocol-Version 3,POP3）、因特网邮件访问协议（Internet Mail Access Protocol，IMAP）telnet pop3.163.com 110 基于Web的电子邮件用户代理（浏览器）到邮件服务器的传送用的HTTP协议而非（POP3、SMTP），而邮件服务器之间的传送依然用的是SMTP协议。 2.5 DNS：因特网的目录服务进行主机名到IP地址的目录转换服务。DNS（Domain Name System，DNS） DNS：1、一个由分层的DNS服务器实现的分布式数据库2、一个是的主机能够查询分布式数据库的应用层协议。 DNS服务器通常是运行BIND软件的UNIX机器。DNS协议运行在UDP之上，使用53号端口。 DNS为应用程序提供一种核心功能，将主机名转换为IP地址。并不直接与用户打交道。 DNS通常由其他应用层协议所使用，如HTTP、SMTP、FTP等。 工作原理： 同一台主机运行着DNS应用的客户端。 浏览器从URL提取域名，交给DNS客户端。 DNS客户端利用UDP协议传送给DNS服务器，要求解析域名并返回。 浏览器接受IP地址，访问指定IP指定端口的，建立一个TCP连接。 DNS提供其余的重要服务： 主机别名：即规范主机名和主机别名的转换。 邮件服务器别名：邮件服务器别名和规范邮件服务器名的转换。 负载分配：当一个繁忙域名有多个IP地址。一个IP地址集合与同一个规范主机名想联系。DNS数据库中存储着这些IP地址集合。当客户向DNS发送一个DNS请求时，整合IP地址集合对其响应，但在每次回答中循环这些地址次序，因为客户通常总是优先访问考前的IP，所以DNS就为这些冗余的Web服务器之间进行了循环分配负载。DNS的循环同样运用与邮件服务器，因此多个邮件服务器可以使用相同的别名。 2.5.2 DNS工作机理概述DNS的实际实现是相当复杂的！单一DNS服务器在当今没有可行性，运行集中式数据库完全没有可扩展能力。 DNS服务器采取分布式的方案。 1、分布式、层次数据库 3种类型的DNS服务器：根DNS服务器、顶级域（Top-Level Domain，TLD）DNS服务器和权威DNS服务器。有点面向对象的意思。 根服务器：全球13个，冗余服务器的网络，总共200多个服务器。 顶级域服务器：com、org、net、edu、gov，国家顶级域名uk、fr、ca、jp。由不同的机构负责维护该服务器。 权威DNS服务器：权威服务器维护着映射。域名对应的公司或机构可以维护自己的权威DNS服务器，或者支付费用将其映射存储在某个服务提供商的权威DNS服务器中。 本地DNS服务器 接入ISP（Internet Service Provider，因特网服务提供商）时，ISP提供一台本地DNS服务器，这台服务器的作用相当于代理，将DNS请求转发到DNS服务器层次结构中。可以在IPV4协议属性中查看DNS本地服务器地址。 过程： 发送DNS请求，本地DNS服务器接受。 本地DNS发送DNS请求报文到根DNS服务器。 根分析域名，返回顶级DNS服务器IP集。 本地DNS向TLD服务器之一发送查询报文。TLD响应返回权威DNS服务器。 本地DNS服务器向权威DNS服务器之一发送请求报文，权威DNS服务器响应IP地址。 本地DNS接受到IP地址，返回给客户。 该过程很繁琐，要经过4次请求和4次回答。DNS缓存应运而生。 迭代查询：多次查询时，请求者是同一人，深度不变。递归查询：多次查询时，请求者依次跟进，越来越深。 实践中，通常采用的是主机到本地DNS服务器采取查询（由本地DNS去查询），其余的查询是迭代（还是由本地DNS去查询）。 2、DNS缓存接受到回答报文的DNS服务器将回答的信息缓存到本地储存器中。下次被请求，即使本身不是权威DNS服务器，也能直接返回回答报文。缓存期一般设置为两天。这也许就是为什么访问热门网站网速很快的原因之一。DNS缓存能有效减少报文次数和时延。 2.5.3 DNS记录和报文共同实现DNS分布式数据库的所有DNS服务器存储了资源记录（Resource Record，RR），RR提供了主机名到IP地址的映射，每个回答报文包含了一条或多条资源记录。 资源记录格式：（Name，Value，Type，TTL） TTL：过期时间。Type：决定了Name和Value Type = A：Name = 主机名 ，Value = 对应IP地址。（www.baidu.com，192.162.22.10，A） Type = NS：Name = 域，Value = 权威DNS服务器的主机名，用于沿着查询链查询。 Type = CNAME：Value = 别名为Name的规范主机名。向查询的主机提供一条查询主机名对应的规范的主机名。 Type = MX：Value = 别名为Name的邮件服务器的规范主机名。MX记录允许邮件服务器主机名具有简单的别名。通过使用MX记录，一个公司的邮件服务器和其他服务器可以使用相同的别名，因为有MX对其进行区分了。 从浏览器访问www.baidu.com的工作过程：（理解可能有偏差） 浏览器向本地DNS服务器发送请求。 本地DNS向根服务器发送请求，根服务器解析域名并返回TLD的IP地址。 本地DNS向TLD发送请求，返回NS资源记录（包含权威服务器规范名）和A资源记录（包含权威服务器的IP） 根据权威服务器的IP访问权威服务器，查询www.baidu.com的IP并返回。 本地DNS返回IP给浏览器，浏览器根据IP地址建立TCP连接，进行访问。 DNS的脆弱性其实并不脆弱。攻击方式：分布式拒绝服务（DDoS）带宽洪范攻击。 针对根服务器 针对顶级DNS服务器 其余的攻击方式 2.6 P2P应用每个对等方能够帮助服务器分发资源，强大其服务，即自扩展性很好。 2、BitTorrent块（chunk）：典型的块长度为256kb。用户上传和下载的最小单位。 流行P2P协议。参与一个特定文件分发的所有对等方的集合被称为一个洪流（torrent），每个洪流有一个基础设施节点，称为追踪器（tracker）。当一个对等方加入洪流时，它向追踪器注册自己，并周期性的通知追踪器自己仍在洪流中。追踪器从洪流中选取子集用户相互连接，一个用户会与多个对等方建立TCP连接。下载资源的同时上传资源。其过程比较复杂。更详细的过程描述参见P101-P106。 2.7 TCP套接字编程在Java中，不同的通信规则需要定义不同的socket。UDP：DatagramSocket 、 DatagramPacketTCP：ServerSocket 、Socket 2.7.1 UDP套接字编程UDPServer 12345678910111213141516171819202122232425262728293031323334353637383940/* * 服务器端，实现基于UDP的用户登陆 */public class UDPServer &#123; public static void main(String[] args) throws IOException &#123; /* * 接收客户端发送的数据 */ // 1.创建服务器端DatagramSocket，指定端口 DatagramSocket socket = new DatagramSocket(8888);//如果主机只有一个IP 地址, 那么默认情况下, 服务器程序就与该IP 地址绑定,或者InetAddress.getByName("192.126.10.14")绑定ip地址 // 2.创建数据报，用于接收客户端发送的数据 byte[] data = new byte[1024];// 创建字节数组，指定接收的数据包的大小 DatagramPacket packet = new DatagramPacket(data, data.length); // 3.接收客户端发送的数据 System.out.println("****服务器端已经启动，等待客户端发送数据"); int i = 0; while (i&lt;1) &#123;//链接一次就关闭 i++; socket.receive(packet);// 此方法在接收到数据报之前会一直阻塞 // 4.读取数据 String info = new String(data, 0, packet.getLength()); System.out.println("我是服务器，客户端说：" + info); /* * 向客户端响应数据 */ // 1.定义客户端的地址、端口号、数据 InetAddress address = packet.getAddress(); int port = packet.getPort(); byte[] data2 = "欢迎您!".getBytes(); // 2.创建数据报，包含响应的数据信息 DatagramPacket packet2 = new DatagramPacket(data2, data2.length, address, port); // 3.响应客户端 socket.send(packet2); &#125; // 4.关闭资源 socket.close(); //System.out.println("服务器已关闭"); &#125;&#125; UDPClient 12345678910111213141516171819202122232425262728293031323334353637/* * 客户端 */public class UDPClient &#123; public static void main(String[] args) throws IOException &#123; /* * 向服务器端发送数据 */ // 1.定义服务器的地址、端口号、数据 byte[] ip = &#123;127,0,0,1&#125;;//也可getByName(localhost) InetAddress address = InetAddress.getByAddress(ip); System.out.println(address.getHostAddress()); System.out.println(address.getHostName()); int port = 8888; byte[] data = "用户名：admin;密码：123".getBytes(); // 2.创建数据报，包含发送的数据信息 DatagramPacket packet = new DatagramPacket(data, data.length, address, port); // 3.创建DatagramSocket对象 DatagramSocket socket = new DatagramSocket(); // 4.向服务器端发送数据报 socket.send(packet); /* * 接收服务器端响应的数据 */ // 1.创建数据报，用于接收服务器端响应的数据 byte[] data2 = new byte[1024]; DatagramPacket packet2 = new DatagramPacket(data2, data2.length); // 2.接收服务器响应的数据 socket.receive(packet2); // 3.读取数据 String reply = new String(data2, 0, packet2.getLength()); //System.out.println("我是客户端，服务器说：" + reply); // 4.关闭资源 socket.close(); &#125;&#125; 2.7.2 TCP套接字编程可以参考：http://blog.csdn.net/qq_23473123/article/details/51461894 12345678910111213141516171819202122232425262728293031323334/** * TCP客户端 * @author Wch * @Time 2017-4-3 下午8:34:42 * */public class TCPClient &#123; public static void main(String[] args)&#123; try &#123; //1、创建客户端Socket，指定服务器和端口 Socket socket = new Socket("localhost", 5887); //2、获取输出流，向服务端发送信息 OutputStream os = socket.getOutputStream(); os.write("用户名：admin；密码123".getBytes()); os.flush(); socket.shutdownOutput();//关闭输出流 //3、获取输入流，读取响应信息 InputStream is = socket.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(is)); String msg = null; while((msg = br.readLine())!=null)&#123; System.out.println("客户端返回："+msg); &#125; //4、关闭资源 br.close(); is.close(); os.close(); socket.close(); &#125; catch (UnknownHostException e) &#123; &#125; catch (IOException e) &#123; &#125; &#125;&#125; 12345678910111213141516171819202122232425/** * 客户端 * @author Wch * @Time 2017-4-3 下午8:35:11 * */public class TCPServer &#123; public static void main(String[] args) throws Exception &#123; ServerSocket serverSocket = new ServerSocket(5887); Socket socket = null; System.out.println("***服务器即将启动，等待客户端的连接***"); int i = 0; while(i&lt;5)&#123; socket = serverSocket.accept(); //开启线程 TCPServerThread tst = new TCPServerThread(socket); Thread thread = new Thread(tst); //启动线程 thread.start(); i++; System.out.println("第"+i+"位访客"); &#125; System.out.println("服务端关闭了"); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 服务器线程处理类 * @author Wch * @Time 2017-4-3 下午8:33:10 * */public class TCPServerThread implements Runnable&#123; Socket socket = null; public TCPServerThread(Socket socket) &#123; super(); this.socket = socket; &#125; @Override public void run() &#123; InputStream is = null; OutputStream os = null; OutputStreamWriter osw = null; try &#123; //1、获取客户端输入 is = socket.getInputStream(); System.out.println("客户端说："+new BufferedReader(new InputStreamReader(is)).readLine()); System.out.println("收到来自"+socket.getInetAddress().getHostName()+"的连接"); System.out.println("IP地址是"+socket.getInetAddress().getHostAddress()); socket.shutdownInput();//关闭socket输入流 //2、获取输出流，写出响应 os = socket.getOutputStream(); osw = new OutputStreamWriter(os); osw.write("欢迎访问本站"); osw.flush(); socket.shutdownOutput();//关闭socket输出流 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally&#123; try &#123; osw.close(); os.close(); is.close(); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; THE END]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络（1） 计算机网络和因特网]]></title>
    <url>%2F2019%2F02%2F14%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%881%EF%BC%89%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91%2F</url>
    <content type="text"><![CDATA[计算机网络（1） 计算机网络和因特网 端系统也称为主机，通过通信链路（communication link）和分组交换机（packet switch）连接到一起。 发送数据时，端系统将数据分组（packet），通过通信链路发送。 分组交换机包括路由器和链路层交换机等。 端系统通过因特网服务提供商（Internet Service Provider，ISP）介入因特网、 端系统、分组交换机、和其他因特网部件都要运行一系列协议，这些协议控制信息的接受和发送。TCP（Transmission Control Protocol，传输控制协议）IP（Internet Protocol，网际协议）：定义了路由器和端系统之间发送和接受的分组格式。 因特网的主要协议统称为TCP/IP。 RFC（Request For Comment，请求评论）：IETE（Internet Engineering Task Force，因特网工程任务组）的标准文档。 RFC定义了TCP、IP、HTTP、SMTP等协议。 1.1.3 什么是协议 网络协议一个协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及报文发送和/或接受一条报文或其他时间所采取的动作。 1.2.1 接入网接入网：将端系统连接到其边缘路由器（edge router）的物理链路。端系统到互联网的第一台路由器。 1.2.2 物理媒体分导引型媒体（guided media）和非导引型媒体。导引型：光缆、电缆等。非导引型：电波。 1.3 网络核心1.3.1 分组交换为了从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块，称为分组。每个分组都通过通信链路和分组交换机传送。分组以等于该链路最大传输速率的速度传输通过通信链路。因此，如果某源端系统或分组交换机经过一条发送一个L比特的分组，链路的传输速率是R，则需要L/R秒。 1、存储转发传输存储转发传输机制是指交换机在能够开始向输出链路传输该分组的第一个比特之前，必须接受到整个分组。（即发送是以组为最小单位的，而不是比特） 计算时延：3个分组，1个路由器（2条路径）：接受需要4L/R的时间。（3+1）1个分组，N条路径（N-1个路由）：NL/RP个分组，N条路径：(P+1)NL/R 2、排队时延和分组丢失每个分组交换机有多条链路与之相连。对于每一条链路，该分组交换机有一个输出缓存（output buffer），用于储存分组。如果到达分组发现之前有分组正在传输，需要等待。因此，除了储存转发时延之外，分组还要承受输出缓存的排队时延（queue delay）。排队时延取决于当前的拥塞程度。 当一个到达分组到达时发现该缓存已经被其他等待传输的分组完全充满时，此时将出现分组丢失（丢包）（packet lost），到达的分组或已经排队的分组之一将被丢弃。 3、转发表和路由选择时延转发表（forwarding table），决定了路由器的出链路径。由源主机发送指向的IP地址解析（根据路由选择协议第四章叙述）而成。 1.4 分组交换网中的时延、丢包和吞吐量1.4.1 时延概述结点总时延（total nodal delay）=结点处理时延+排队时延+传输时延+传播时延 处理时延检查分组首部和决定该分组导向何处所需时间。 排队时延队列中，分组在缓存中等待传输的时间。 传输时延分组先到先服务，传输时延是指将所有分组的比特推向链路所需要的时间。 传播时延在链路中传播的时间成为传播时延。速度接近光速。 传输时延和传播时延的区别一个是路由器将分组退出所需要的时间，另一个是将分组从一个路由器传输到另一个路由器所需要的时间。 1.4.2 排队时延和丢包见上2. 1.4.3 端到端时延处理时延+排队时延+传输时延+传播时延 1.4.4计算机网络中的吞吐量理解：吞吐量=网速。吞吐量=min{R1,R2,R3,R4…Rn}，即瓶颈链路（bottleneck link）的传输速率。由于服务器和核心链路的传输速率都很大，因此对吞吐量的限制因素通常是接入网。然而当共享链路传输速率过小时，瓶颈将可能不再是接入网，举个例子：2m带宽的用户在高峰期的下载速度达不到理论值，原因可能就是共享链路传输速率过小，导致平均分配给每个用户的吞吐量低于了理论值。 1.5 协议层次及其服务模型1.5.1 分层的体系结构分层的好处，模块化使更新系统组件变得更容易。 因特网的协议栈有5个层次组成：物理层，链路层，网络层，运输层和应用层。自顶向下首先处理应用层。 （1）应用层保存网络应用程序和他们的应用层协议。应用层协议分布在多个端系统中，一个端系统的应用程序使用协议与另一个端系统中的应用程序交换信息的分组，我们把这种位于应用层的信息分组称为报文。 （2）运输层TCP和UDP两个协议。TCP：面向连接的服务，可靠的、有流量控制的、并提供用塞控制。UDP：无连接服务，不提供不必要服务，没有可靠性，没有流量控制，没有拥塞控制。 运输层分组称为报文段。 （3）网络层负责将数据报的网络层分组由一台主机发送到另一台主机。 网络层包括著名的IP协议，该协议定义了在数据报中的各个字段以及端系统和路由器如何作用于这些字段。其次还包括决定路由的路由选择协议。 （4）链路层网络层必须依靠链路层的服务。 链路层负责将整个帧从一个网络元素移动到相邻的网络元素。由链路层提供的服务取决于应用于该链路层的特定链路层协议（以太网、WiFi…）。 链路层分组称为帧。 （5）物理层负责移动一个一个的比特。改层中的协议仍是链路相关的。 OSI模型多了表示层和会话层表示层：使通信的应用程序能够解释交换数据的含义。会话层： 提供数据交换定界和同步功能。 1.5.2 封装数据从发送端系统的协议栈向下，向上和向下经过了中间的链路层交换机和路由器的协议栈。其并没有实现协议栈中的所有层次。链路层交换机：物理层和链路层。路由器：物理层，链路层，网络层。 主机实现了所有的五个层次，这与因特网体系结构将他的复杂性放在网络边的观点一致。 封装的结果：每一层的报文具有两个类型的字段：首部字段和有效载荷字段（payload field）。有效载荷字段来自上一层的分组。 1.6 面对攻击的网络病毒：需传播。蠕虫：无明显用户交互。拒绝服务攻击（Denial-of-Service attack）DoS：攻击服务器和基础网络设施。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统精髓与设计原理]]></title>
    <url>%2F2019%2F02%2F14%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[操作系统精髓与设计原理操作系统精髓与设计原理（第七版） 存储器地址寄存器（Memory Address Register，MAR）存储器缓存寄存器（Memory Buffer Register，MBR）输入输出地址寄存器（I/O Address Register，I/O AR或IO地址寄存器）输入输出缓冲寄存器（I/O Buffer Register，I/O BR或I/O缓冲寄存器） 程序计数器（Program Counter，PC）指令寄存器（Instruction Register，IR） 中断（interrupt），提高处理器效率的一种手段。 存储器的层次结构（memmory hierarchy）命中率(hit ratio)二级存储器（secondary memory）或者辅助存储器（auxiliary memory） 局部性原理（principle of locality） 块（blocks）存储槽（slots） 映射函数（mapping function）置换算法（raplacement algorithm）写策略（write policy） chapter 3 进程把进程视为由一组元素组成的实体，进程的两个基本元素是程序代码（program code，可能被执行相同程序的其他进程共享）和代码相关的数据集（set of data）。假设处理器开始执行这个进程，在进程执行时，任意给定一个时刻，进程都可以唯一的表征为以下元素： 标识符：进程的唯一标识符。 状态：运行态、阻塞态等。 优先级： 程序计数器：程序中将被执行的下一条指令的地址。 内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享内存块的指针。 上下文数据：进程执行时处理器的寄存器中的数据。 I/O状态信息：包括显式的I/O请求、分配给进程的I/O设备和被进程使用的文件列表等。 记账信息：可能包括处理器时间总和、使用的时钟数总和、时间限制、记账号。 进程控制块包含了以上的信息，使得进程之间可以进行切换。因此可以说，进程是由程序代码和相关数据还有进程控制块组成。 进程的轨迹（trace）分派器（dispatcher）进程派生（process spawning）父进程、子进程 交换（swapping）：一个I/O操作、挂起队列（suspend queue） 调度（schedule）分派（dispatch） 内存表（memory table）I/O表（I/O table）文件表（file table）进程表（process table） 进程映像（process image）：程序、数据、栈和进程控制块中定义的属性的集合。进程控制块（process control block，PCB） 进程标识符（process identification）处理器状态信息（processor state information） 用户态（user mode）系统态（system mode）、控制态（control mode）、内核态（kernel mode） 上下文切换（context switch）：也称环境切换或者进程切换。需要改变并且保存进程控制块，是的来回切换时能迅速定位到进程。 进程切换的具体步骤： 保存处理器上下文环境，包括程序计数器和其他寄存器。 更新当前运行态进程的进程控制块，包括将进程的状态改变到另一状态，还必须更新其他相关域。 将进程的进程控制块移到相应的队列。 选择另一个进程执行。 更新所选择的进程的进程控制块，包括将进程的状态改为运行态。 更新内存管理的数据结构（后续将会讲到） 恢复处理器在被选择的进程最近一次切换出运行状态的上下文环境，这可以通过载入程序计数器和其他寄存器以前的值来实线。 chapter 4 线程进程：拥有资源所有权，可被操作系统调度和分派的实体。 分派的最小单位成为线程或轻量级进程（Light Weight Process，LWP），而拥有资源所有权的单位通常仍称为进程或任务（task）。 进程涉及资源的所有权，线程涉及程序的运行。在多线程系统中，可以在一个进程内定义多个并发线程。这可以通过使用用户级线程或内核级线程来完成。用户级线程对操作系统是未知的，他们由一个在进程的用户空间中运行的线程库创建并管理。用户级线程是非常高效的，因为切换线程不需要状态转换，但是一个进程中一次只有一个用户级线程可以运行，如果线程发生阻塞，整个进程都会被阻塞。内核级线程由内核维护，同一个进程中的多个线程可以在多个处理器上并行执行，一个线程的阻塞不会阻塞整个进程，但当从一个线程切换到另一个线程时需要模式转换。 chapter 5 并发性：互斥和同步临界资源（critical resource）：只允许一个进程访问的资源。临界区（critical section）死锁（deadlock）饥饿（starvation） entercriticalexitcritical 互斥的要求： 必须强制实施互斥 一个在非临界区停止的进程不能干涉其他的进程。 决不允许出现需要访问临界区的进程被无限延迟的情况，即不会出现死锁和饥饿、 当没有进程在临界区时，任何需要进入临界区的进程必须能够进入。 对相关进程的执行速度和处理器的数目没有任何的要求和限制。 一个进程驻留在临界区中的时间必须是有限的。 互斥：硬件的支持 禁用中断：对单处理系统管用，多处理系统不管用。 专用机器指令： 比较和交换指令 互斥机器指令：比较和交换指令(compare and swap instruction)或（compare and exchange instruction）原子操作，不接受中断。 5.3 信号量（semaphore）信号量是1965荷兰Dijkstra为了解决并发进程问题而提出的一个重要操作系统的思想。进程间进行通信的一种媒介之一。 其基本思想： 两个或多个进程可以通过简单的信号进行合作，一个进程可以被迫在某个位置停止，直到它接收到一个特定的信号。任何复杂的合作需求都可以通过适当的信号结构得到满足。为了发信号，需要使用一个称为信号量的特殊变量。为通过信号量s发送信号，进程可执行原语semSignal（s），即V操作；为了通过信号量s接收信号，进程可执行原语semWait（s），即P操作；如果相应的信号还没有发送，则进程将被挂起，直至发送为止。 信号量可被看做死一个具有整数型的变量，有三个操作： 一个信号量可以初始化成非负数，一般资源数就是信号量的初始值 semWait操作，即P操作，使得信号量减1，如果值变成负数（s &lt;0) 则执行semWait的进程被阻塞，否则进程继续执行 semSignal操作，即V操作，使得信号量加1，如果值小于或等于零，则被semWait操作阻塞的进程被解除阻塞 12345678910111213141516171819202122using namespace std; struct semaphore&#123; int count; queueType queque; &#125; void semWait(semaphore s)&#123;//P操作 s.count--; if(s.count&lt;0)&#123; place this process in s.queue; block this process; &#125; &#125; void semSignal(semaphore s)&#123;//V操作 s.count++; if(s.count&lt;=0)&#123; remove a process P from s.queque; place process P on ready list; &#125; &#125; 开始时，信号量的值为零或正数，如果该值为正数，则该值等于发出semWait操作之后还能继续执行的进程数，如果该值为零，则发生semWait操作后的下一个进程就将会被阻塞。此时该信号量的值变为负。此后每一个semSignal操作都会为处于阻塞状态的一个进程解除阻塞。 二元信号量（binary semaphore）一个二元信号量可以初始化成0或1。 非二元信号量被称为计数信号量或一般信号量。 互斥量为互斥量加锁（设置为1）的进程和为互斥量解锁（设置0）的进程必须是同一个，相比之下，二元信号量没有限制是同一个进程。 强信号量（strong semaphore）：阻塞最久最先释放弱信号量（weak semaphore）：不是队列移除 5.4 管程管程是一个程序设计语言结构，它提供了与信号量同样的功能，但更易于控制。 管程是由一个或多个过程、一个初始化序列和局部数据组成的软件模块。主要特点： 局部数据变量只能被管程的过程访问，任何外部过程都不能访问。 一个进程通过调用管程的一个过程进入管程。 在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用。 对于管程而言，它构造自己的互斥机制。但是同步还是需要程序员在程序上自己实现。而对于信号量，执行互斥和同步都需要程序员去实现。 管程优于信号量之处在于，所有的同步机制都被限制在管程内部，因此，不但易于验证同步的正确性，而且易于检测出错误。此外，如果一个管程被正确地编写，则所有进程对受保护资源的访问都是正确的；而对于信号量，只有当所有访问资源的进程都被正确地编写时，资源访问才是正确的。 5.5 消息传递send、receive 发送者和接受者都可以阻塞和不阻塞。特定的系统实现不同的组合： 阻塞send、阻塞receive： 无阻塞send、阻塞recieve：发送者尽快的发送，接受者必须接受到消息。 无阻塞send、无阻塞receive 寻址直接寻址和间接寻址 间接寻址：消息不是直接从发送者发送到接受者，而是发送一个共享数据结构，成为信箱（mailBox）。 一对一、多对一、一对多或多对多寻址。多对一的信箱又可称为端口（port）。 5.6 读者/写者问题 任意多的读进程可以同时读这个文件。 一次只有一个写进程可以写文件。 如果一个写进程正在写文件，那么禁止任何读进程读文件。 chapter 6 并发：死锁和饥饿死锁的条件：三个必要条件 互斥：一次只有一个进程可以访问一个资源。 占有且等待：当一个进程等待其他进程时，继续占有已经分配的资源。 不可抢占：不能强行抢占进程已占有的资源。 充分条件： 循环等待：存在一个封闭的进程链，使得每个进程至少占有下个进程所需要的一个资源。 6.2 死锁的预防prevention。从4个充要条件下手。P190 6.3 死锁的避免允许三个必要条件，通过明智的选择，确保永远不会到达死锁点，因此死锁避免（deadlock avoidance）比死锁预防允许更多的并发。 两种避免死锁的方法： 如果一个进程的请求会导致死锁，则不会启动此进程。 如果一个进程增加的资源请求会导致死锁，则不允许此分配。 进程启动拒绝只有所有当前进程的最大请求量家还是那个新的进程请求可以满足时，才会启动该进程。 资源分配拒绝资源分配拒绝策略又称银行家算法 新概念：安全状态：至少有一个资源分配序列不会导致死锁。即剩余的资源至少可以满足一个进程的资源需求。具体见P192 6.4 死锁的检测6.6 哲学家就餐 哲学家就餐问题可以这样表述，假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每两个哲学家之间有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。哲学家就餐问题有时也用米饭和筷子而不是意大利面和餐叉来描述，因为很明显，吃米饭必须用两根筷子。哲学家从来不交谈，这就很危险，可能产生死锁，每个哲学家都拿着左手的餐叉，永远都在等右边的餐叉（或者相反）。即使没有死锁，也有可能发生资源耗尽。例如，假设规定当哲学家等待另一只餐叉超过五分钟后就放下自己手里的那一只餐叉，并且再等五分钟后进行下一次尝试。这个策略消除了死锁（系统总会进入到下一个状态），但仍然有可能发生“活锁”。如果五位哲学家在完全相同的时刻进入餐厅，并同时拿起左边的餐叉，那么这些哲学家就会等待五分钟，同时放下手中的餐叉，再等五分钟，又同时拿起这些餐叉。在实际的计算机问题中，缺乏餐叉可以类比为缺乏共享资源。一种常用的计算机技术是资源加锁，用来保证在某个时刻，资源只能被一个程序或一段代码访问。当一个程序想要使用的资源已经被另一个程序锁定，它就等待资源解锁。当多个程序涉及到加锁的资源时，在某些情况下就有可能发生死锁。例如，某个程序需要访问两个文件，当两个这样的程序各锁了一个文件，那它们都在等待对方解锁另一个文件，而这永远不会发生。 协调处理共享资源 6.6.1 基于信号量解决方案6.6.2 基于管程的解决方案6.7 UNIX的并发机制UNIX中进程之间的通信和同步机制： 管道 消息 共享内存 信号量 信号 管道、消息、共享内存提供进程之间传递数据的方法，信号量、信号用于出发其他进程的行为。 6.11 小结死锁指一组争用系统资源或相互通信的进程被阻塞的现象，这种阻塞是永久的，除非操作系统采取某些非常的行动，如杀死一个进程，或者强迫多个一个或者多个进程进行回滚。死锁可能涉及可重用资源部或可消耗资源。可重用资源是指不会因为使用而被耗尽或销毁的资源，如I/O通道或一块内存区域。可消耗资源是指当被一个进程获得时就销毁了的资源，这类资源的例子有消息和I/O缓冲区中的信息。处理死锁通常有三种方法：预防、检测和避免。死锁预防通过确保死锁的一个必要条件不会满足，保证不会发生死锁。如果操作系统总是同意资源请求，则需要进行死锁检测，操作系统必须周期性的检查死锁，并采取行动打破死锁。死锁避免设计分析新的资源请求，以确定他是否会导致死锁，并且只有当不可能发生死锁时才同意该请求。 chapter 7 内存管理 二级存储：计算机主存储器或内存之外的所有可访问数据存储器。外部存储以及辅助存储是其同义词。 7.1 内存管理的需求 重定位：挂起的进程重新进入到内存时需要重定位到内存的不同区域。 保护：防止本进程以外的其他进程中的程序未经允许访问该进程的内存单元。因此，在进程中必须检查进程所访问的所有内存地址，以确保它们只访问了分配给改进程的内存空间。由处理器处理违法内存访问比操作系统处理更加快速高效。 共享：保护机制必须具备一定的灵活性，以确保能够访问共享内存区域，而不会损害基本的保护。 逻辑组织：大多数程序在结构上被组织成模块，这种逻辑上的结构如何在内存中被处理衍生出了很多的技术。 物理组织：内存和外存之间信息流的组织和传递，存储管理的本质。 7.2 内存分区7.2.1 固定分区 大小相等的分区：大小有限；利用率低，会产生内部碎片（internal fragmentation）。 大小不等的分区：缓解以上的问题。也有别的问题存在。P222.目前很少有系统采取这种分区方式。 7.2.2 动态分区内存分配个进程的大小是按需分配，不多不少，在多次进行进程的挂起运行之后会在内存中出现很多“洞”。称为外部碎片（external fragmentation）：只在所有分区外的存储空间变成越来越多的碎片，这与前面内部碎片刚好相对应。 解决外部碎片 压缩：由处理器移动进程，腾出空余的连续的内存空间，缺点是浪费处理器资源，并且要支持动态重定位。 放置算法：当碎片累计到一定量时，需要将进程放入到碎片内存中来减少内存，放置的算法有：最佳适配、首次适配、下次适配。P224 置换算法：涉及到将内存中处于阻塞状态的进程置换出内存以给新进程或者就绪/挂起态进程腾出空间的操作，涉及到虚拟内存。 7.2.3 伙伴系统固定分区和动态分区都不好，这种方案是伙伴系统。 伙伴系统：需要分配空间时， 采用除以2的方式确定需要分配的空间大小，从同一空间分割出来的子空间称为伙伴空间，相同大小的伙伴空间之间具有合并的趋势。（即不存在两个都为空的伙伴空间） 在现代系统中，基于分页和分段机制的虚拟内存方案更加先进，因此上述的三种方案在现在已经很少用到了。 7.2.4 重定位当进程在内存中移动时，指令和数据单元的位置会发生改变，需要区分几种地址类型： 逻辑地址（logic address）：指与物理地址无关的访问地址，在执行对内存的访问之前必须将其转换成物理地址。 相对地址（relative address）：是逻辑地址的一个特例，相对于某个已知地质点的存储单元。 物理地址（physical address）：内存中的实际位置。 基址寄存器，保存着程序的起始地址，界限寄存器指明程序的终止位置。负责将相对地址安全地转换为物理地址，因此处理器负责转化成物理地址。 7.3 分页将内存分为页框或者帧（frame）的内存块，将进程分为页（page）的块。 每个进程中维护了一个页表（page table），维护了每一个页对应的页框的位置。 程序中，逻辑地址是一个页号和在该页中的偏移量。处理器使用页表产生物理地址。采用分页技术的分区相当小，一个程序可以占据多个分区，并且这些分区不需要是连续的。 采用简单分页技术，内存被分成许多大小相等且很小的页框，每个进程被划分成同样大小的页；较小的进程需要较少的页，较大的进程需要较多的页；当一个进程被装入时，它的所有页都被装入到可用页框中，并且建立一个页表，用于处理器由逻辑地址索引到物理地址。这种技术解决了分区技术中存在的很多问题。 7.4 分段把程序和其相关的数据划分到几个段（segment）中。 分段技术逻辑地址：段号和偏移量。 采用简单分段技术，进程被分为很多段，段的大小不需要相等；当一个进程被调入时，它的所有段都被装入内存的可用区域中，并建立一个段表。段表维护相应段号在内存中的起始位置，并指明了该段的长度。寄存器由逻辑地址提取段号和最大段长度，与段表中的段号索引，找到内存中的位置。 chapter 8 虚拟内存 你需要一艘更大的船。——《大白鲨》 8.1 硬件和控制结构突破口： 进程中的所有内存访问都是逻辑地址，这些逻辑地址在运行时动态的被转换成物理地址，这意味着一个进程可以被换入或换出内存，使得进程可以在执行过程中的不同时刻占据内存中的不同区域。 一个进程可以划分成许多块（页和段），在执行过程中，这些块不需要连续的位于内存中。动态运行时地址转换和页表或段表的使用使这一点成为可能。 常驻集（resident set）：进程执行中的任何时刻都在内存中的部分称为进程常驻集。将页或者段成为进程块。 当请求的逻辑地址不在内存中时，则产生一个中断，将中断的进程置为阻塞，并将包含引发访问故障的逻辑地址的进程读入内存，再讲该进程置为就绪态。 常驻集带来的好处： 在内存中保留更多的进程：对于每个进程仅仅保留了必要的部分（常驻集），因此有足够的空间保留更多的进程，保证在任何时刻都有处于就绪态的进程，使得处理器的效率更高。 进程可以比内存的全部空间还大：因为内存中只保存了进程的常驻集。 实存（real memory）、虚存（virtual memory） 系统抖动（thrashing）：当系统在读取一块时，移除了另一块B，若B块即将执行，即又不得不再读回来，这种现象称为系统抖动，处理器的大部分时间都用于交换块，而不是执行块。如果减少系统抖动出现了很多复杂且高效的算法。大多基于局部性理论（principle of locality）：局部性理论描述了一个进程中程序和数据的聚簇倾向。 8.1.2 分页当一个进程中的所有页都读入到内存时，在内存中针对每一页的维护一个页表项（Page Table Entry，PTE），存储页和页框（帧）的对应信息。 页表结构：每一个进程中有唯一的页表，用于维护每一页对应的相关信息。页表中保存有虚拟地址（逻辑地址）包括页号和偏移量，物理地址则有帧号和偏移量组成。根据虚拟地址的页号索引页表找到相应的帧号，再根据虚拟地址的偏移量结合帧号得出物理地址。 由于一个进程可能存在很多个页，因此页表中可能会出现多个页表项，保存在实存中将会占用巨大的空间，通常将页表保存在虚拟内存中。因此，页表和部分页都存储在虚拟内存中，即服从分页管理。当一个进程正在运行时，它的页表至少有一部分必须在内存中，这一部分包括正在运行的页的页表项。 根页表：用于映射页表用户页表：用于映射虚拟地址空间。 根页表—–&gt;用户页表——&gt;虚拟内存地址 两级结构能有效减少信息存储量。详见P247 针对32位虚拟地址，前10位用于检索根页表，得用户页表（假设不用中断），再10位检索得到的用户页表，得页表项，后12位用于寻址到内存（实存）。 倒排页表：使用散列技术将页号均匀分布给页框。 每个虚存访问可能引起两次物理内存访问：一次取对应的页表项，一个取需要的数据。因此，简单的虚拟内存方案会导致内存访问时间加倍。解决办法：为页表项使用一个特殊的高速缓存，通常称为转换检测缓冲区（Translation Lookaside Buffer，TLB），这个高速缓存的功能和高速缓冲存储器相似，包含了最近用过的页表项。当访问一个虚拟地址时，经过的步骤为： 给定一个虚拟地址，处理器首先检查TLB，如果需要的页表项在其中（TLB命中），则检索帧号并形成实地址。 否则，处理器用页号检索进程页表，如果存在，则处理检索出的帧号形成实地址。处理器同时更新TLB，使其包含新的页表项。 如果进程页表中不存在该页号，则产生一次内存访问故障，称为缺页（pagefault）中断。此时离开硬件作用的范围，调用操作系统，由操作系统负责装入所需要的页，并更新页表。 由于TLB表仅包含了整个页表中的部分表项，因此处理器中的硬件机制允许同时查询许多TLB页，以确定是否存在匹配的页号。 虚拟机制还与内存中的高速缓存（不是TLB）进行了交互。当获取到实地址时，会与高速缓存进行检索，查到该块直接交给CPU，否则再从内存中查找。 一次内存访问中涉及到CPU硬件的复杂性。虚拟地址被转换为实地址，这涉及访问页表项，而页表项可能在TLB中，也可能在内存中或磁盘中，被访问的块可能在高速缓存中、内存中或磁盘中。如果被访问的字只在磁盘中，则包含改字的页必须装入内存，并且它所在的块装入到高速缓存中。此外，包含改字的页对应的页表项必须被更新。 8.1.3 分段简单分段时：每个进程有自己的段表，当它的所有段都装入内存时，为该进程创建一个段表并装入内存。每个段表项包含相对应段在内存中的起始位置和段的长度。 虚拟内存分段：每个进程也有自己的唯一段表。段表项变得更复杂而已。 8.1.4 段页式分页对程序员是透明的，它消除了外部碎片，因而可以更有效的利用内存。分段对程序员是可见的，它具有处理不断增长的数据结构的能力以及支持共享和保护的能力。 段页式的系统中，用户的地址空间被程序员划分为许多段，每个段一次划分为许多固定大小的页，页的长度等于内存中的帧的大小。从程序员的角度看，逻辑地址仍然是由段号和段偏移量组成；从系统的角度看，段偏移量可视为指定段中的一个页号和页偏移量。 段页式的工作过程： 每个进程使用一个段表和一些页表，并且每个进程段中使用一个页表。当一个特定的进程运行时，使用一个寄存器记录该进程表的起始地址。对每一个虚拟地址，处理器使用段号部分来检索进程段表以寻找该段的页表，然后虚拟地址的页号部分用于检索页表中的帧号，再结合虚拟地址的偏移量来产生需要的实地址。 8.2 操作系统软件操作系统的内存管理设计取决于三个基本方面的选择： 是否使用了虚存技术 是使用分页还是使用分段，或者是两者的结合 为各种存储管理特征采用的算法 前两个是硬件相关，第三个是操作系统相关 8.2.1 读取策略 请求分页（demand paging）：当访问到某页中的一个单元时才将该页取入内存，当进程第一次启动时，讲出现大量的缺页中断。 预先分页（prepaging）：读取的页并不是缺页中断请求的页。读取连续的页或一定间隔的页。 8.2.3 置换策略基本算法： 最佳（Optimal，OPT）：置换下次访问距当前时间最长的那些项。 最近最少使用（Least Recently Used，LRU）：置换内存中上次使用距当前最远的页 先进先出（First In First Out，FIFO）：循环缓冲区，实现简单，但是性能低，将导致更多的缺页中断。 时钟（Clock）：以较小的开销接近LRU性能的一种算法。 驻留集的大小： 固定分配策略：固定大小 可变分配策略：可调的，动态变化的。 置换范围： 局部置换策略（local replacement policy）：产生这次缺页的同一进程的驻留页中选择。 全局置换策略（global replacement policy）：所有未锁定的页做为置换页的候选。 置换范围和驻留级的大小有一定的联系：固定驻留级意味着页框的大小不变，因此采取局部置换策略。可变分配策略采取全局置换策略。此外：可变分配+局部置换也是可行的。 8.2.5清除策略清除策略和读取策略相反，它用于何时将一个修改过的页写回辅存。 请求式清除：只有当一页被选择用于置换时才被写回辅存。 预约式清除：将这些被修改的多个页在需要用到他们所占据的页框之前成批的写回辅存。 8.6 小结使用虚拟内存技术的原因：为了有效地使用处理器和I/O设备，希望能在内存中保留尽可能多的进程。此外，还希望能解除程序开发时对程序所使用的内存大小的限制。 虚拟内存技术，所有的访问都是逻辑地址访问，在运行时转换为实地址。允许一个进程位于内存中的任何地址，并且可以随着时间而变化。 允许一个进程被划分成块，这些块在内存中不需要是连续的，并且在运行中，不需要进程所有的块都在内存中。 分页技术：每个进程划分成相对比较小且大小固定等于页框大小的页。分段技术：进程被划分为大小可变的块。 分页和分段技术可以组合到同一个内存管理方案中。 与操作系统对内存管理的支持相关的设计问题有： 读取策略： 放置策略： 置换策略： 驻留集策略： 清除策略： 加载控制：]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统精髓与设计原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[笔记整理（11）]]></title>
    <url>%2F2019%2F02%2F14%2F%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8811%EF%BC%89%2F</url>
    <content type="text"><![CDATA[笔记整理（11）整理了从开始学习Java以来在纸质本上做的一些笔记，如有错误，恳请批评指正。 Gzip压缩技术Servlet中实现压缩传送 12345678910111213141516171819public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html;charset=utf-8"); PrintWriter out = response.getWriter(); ServletOutputStream outputStream = response.getOutputStream(); GZIPOutputStream gzip = new GZIPOutputStream(outputStream); PrintWriter pw = new PrintWriter(gzip); //查看浏览器是否支持gzip boolean isGzip = request.getHeader("accept-encoding")=="gzip"; //设置响应头 response.setHeader("content-encoding", "gzip"); pw.write("需要压缩的内容"); &#125; 文件上传入门使用file组件完成 表单post提交 &lt;input type=&quot;file&quot; name=&quot;XXX&quot;&gt; &lt;enctype=&quot;multipart/form-data&quot;&gt;提交的数据不再是key-value，而是字节数据。 MIME协议：（Multipurpose Internet Mail Extensions，多用途互联网邮扩展），允许邮件处理文本、图片、视频等多个不同类型的数据。 步骤： 导包commons-fileupload-1.2.2.jar 核心包commons-io-2.1.jar 辅助包含FileUtils类 核心API– DiskFileItemFactory：用来设置缓存大小和缓存目录。– ServletFileUpload：用于解析上传的文件。List&lt;FileItems&gt; ServletFileUpload.parseRequest(request);item.getName(),getSize(),getContentType(); FIleUtils工具：存在于io包中– copyInputStreamToFile（inputstream，File）；– item.delete();//删除缓存 解决文件名乱码：upload.setHeaderEncoding(&quot;utf-8&quot;); 123456789101112131415161718192021222324252627282930public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html;charset=utf-8"); PrintWriter out = response.getWriter(); //设置缓存大小 单位：字节 和目录地址 DiskFileItemFactory factory = new DiskFileItemFactory(1000,new File("F:/cache")); //解析者对象 ServletFileUpload upload = new ServletFileUpload(factory); //解决文件名乱码问题 upload.setHeaderEncoding("utf-8"); try &#123; //解析 List&lt;FileItem&gt; parseRequest = upload.parseRequest(request); for (FileItem fileItem : parseRequest) &#123; String name = fileItem.getName(); long size = fileItem.getSize(); String contentType = fileItem.getContentType(); //存储文件 FileUtils.copyInputStreamToFile(fileItem.getInputStream(), new File("F:/upload/name1.txt")); //删除缓存 fileItem.delete(); &#125; &#125; catch (FileUploadException e) &#123; e.printStackTrace(); &#125; &#125; 文件上传细节限制文件类型1234contentType匹配&#123; throw new FileTypeErrorException(&quot;msg&quot;);&#125; 限制上传类型大小– setFileSizeMax();单个文件大小– setSizeMax();总容量抛出：– FileSizeLimitExceededException:单个文件超容异常– SizeLimitExceededException:所有文件 查看文件上传进度ServletFileUpload.setProgressListener(new ProgressListener)；实现ProgressListener接口，重写update方法 文件名重名问题解决方案UUID 随机目录存储 Name.hashcode 自定义方案 获取普通文本控件内容普通文本控件：text\password\checkbox\select\textareafile空间：file isFormField(): true：普通类型 false：file类型，进行上传 文件下载基本流程：Servlet读取–&gt;写出到浏览器 设置响应头：content-disposition：告诉浏览器以下载的方式打开 IE：attachment;filename = test.txt; 非IE：attachment;filename*=test.txt; 12345678910111213141516171819202122232425262728293031public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/plain;charset=utf-8"); File file = new File("F:/test.log"); String fileName = URLEncoder.encode(file.getName(),"utf-8");//加密 System.out.println(fileName); FileInputStream fis = new FileInputStream(file); String userAgent = request.getHeader("user-agent"); String name = null; if(userAgent.contains("Trident"))//IE name = "attachment;filename="+fileName; else//非IE name = "attachment;filename*="+fileName; response.setHeader("content-disposition", name); ServletOutputStream outputStream = response.getOutputStream(); byte[] buf = new byte[1024]; int len = 0; while((len = fis.read(buf))!=-1) outputStream.write(buf,0,len); outputStream.close(); fis.close(); &#125; 反射泛型通过反射获取参数化类型中的泛型的具体类型，type以列表[]返回。 1234567891011Class clazz = Class.forName("ssssss.Implements");//1. 得到当前对象的父接口或者父类Type[] types = clazz.getGenericInterfaces();//2. 强转为实现类（ParameterizedType）ParameterizedType param = (ParameterizedType) types[0];//3. 取出实际的泛型类型，因可能有多个，用数组类Type[] typess = param.getActualTypeArguments();System.out.println(typess[0]);System.out.println(typess[1]); Java的类加载机制详见：http://www.cnblogs.com/ITtangtang/p/3978102.html Web的servlet加载顺序： WebappClassLoader（自定义）加载：web/WEB-INF/lib/*.jar、web/WEB-INF/classes/类 StandardClassLoader（自定义）加载：加载Tomcat/lib/*.jar用于加载所有web项目应用到的jar包 AppClassLoarder：CLASSPATH的jar包和class文件。 ExtClassLoader：jre/lib/ext/*.jar BootStrop:jar/lib/rt.jar – 设计的目的为了分离服务器中的web应用，使每个web应用互不干扰。– webappclassloader：打破了委托机制，保证优先加载web应用的所有资源。 Javamail组件发送邮件SMTP：Simple Mail Transfer Protocol，发送邮件协议 手动步骤 Xshell通过telnet协议连接126的发邮件服务器，端口25 –helo sb（打招呼） –auth login输入用户名和密码（需通过base64加密） 按照smtp协议的格式填写发件人和收件人mail from:&lt;testaccount@126.com&gt;此项必须和登录账户一致，否则会出现Mail from must equal authorized user提示rcpt to:&lt;testaccount@163.com&gt;data from:&lt;ericxu_12345@126.com&gt; -指定发件人，可任意填写（伪造发件人）to:&lt;ericxu_12345@163.com&gt;subject:xxxx –主题 正文内容 –正文 . –用点表示邮件结束，发送 ####代码实现 导包 mail.jar和activation.jar 创建Session类：用于创建一个和邮件服务器的连接和验证登录。 在本次连接session上，创建一个邮件对象。MimeMEssage类：邮件对象（收件人，发件人，主题，正文） 设置邮件内容 发送邮件Tansport.send(mail); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.Properties;import javax.mail.Authenticator;import javax.mail.Message.RecipientType;import javax.mail.MessagingException;import javax.mail.PasswordAuthentication;import javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.AddressException;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;public class Demo2 &#123; public static void main(String[] args) &#123; Properties props = new Properties(); //1.1连接的发邮件的服务器地址 props.setProperty("mail.host", "smtp.126.com"); //1.2 指定进行验证登录 props.setProperty("mail.smtp.auth", "true"); //1) Session session = Session.getDefaultInstance(props, new Authenticator() &#123; @Override //返回base64加密的对象 protected PasswordAuthentication getPasswordAuthentication() &#123; return new PasswordAuthentication("op134972@126.com","password"); &#125; &#125;); //打开调用 session.setDebug(true); //2)在本次连接上， 创建一封邮件 MimeMessage mail = new MimeMessage(session); try &#123; //3）设置邮件内容 ///3.1 设置发件人 mail.setFrom(new InternetAddress("op134972@126.com")); //3.2 设置收件人 /** * 参数一： 发送方法 * 发送： TO A-&gt;B * 抄送： CC A-&gt;B C * 密送： BCC A-&gt;B C * 参数二： 发送的地址 */ mail.setRecipient(RecipientType.TO, new InternetAddress("op134972@163.com")); //3.3 设置主题 mail.setSubject("这是一封javamail的测试邮件"); //3.4 设置内容 /** * 参数二： 邮件的内容格式。如 普通文本，html方式 */ mail.setContent("这是邮件的正文内容", "text/plain;charset=utf-8"); //4)发送邮件 Transport.send(mail); &#125; catch (AddressException e) &#123; e.printStackTrace(); &#125; catch (MessagingException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>笔记整理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>文件上传和下载</tag>
        <tag>JavaMail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记整理（10）]]></title>
    <url>%2F2019%2F02%2F14%2F%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8810%EF%BC%89%2F</url>
    <content type="text"><![CDATA[笔记整理（10）整理了从开始学习Java以来在纸质本上做的一些笔记，如有错误，恳请批评指正。 操作JavaBean标签 构造JavaBean对象&lt;jsp:useBean id=&quot;s&quot; class=&quot;cn.ustb.Demo1&quot;&gt;&lt;/jsp:useBean&gt;id:对象名 class：包名+类名 scope：制定实例对象存储的域区域，paga、request、session、application默认page。 给JavaBean对象赋值&lt;jsp:setProperty name=&quot;&quot; property=&quot;&quot; value=&quot;&quot;/&gt;name：赋值的对象名称 property：给对象的哪个属性赋值 value：值 获取JavaBean的属性&lt;jsp:getProperty name=&quot;&quot; property=&quot;&quot;/&gt;name：对象名 property：属性名 MVC模型MVC开发模型：Jsp+servlet+Javabean - Model：Javabean，封装业务数据。 - view：jsp，显示数据。 - Controller：servlet，控制模型和视图的关系。 项目的三层结构 DAO层：集中编写对实体对象的CRUD方法，面向接口编程。 SERVICE层：集中编写系统中的业务逻辑方法。 WEB层：处理用户的请求和视图跳转（servlet+jsp） MySql数据库 查看所有数据库：show databases; 创建数据库：create database XXX default character set utf8; 删除数据库：drop database XXX; 修改：alter database XXX default character set gbk; 管理表 切换数据库：use XXX; 查询所有表：show tables; 创建表：create table TTT( id int, name varchar(20); age int ); 查看表结构： show create table TTT;(以sql格式返回) desc TTT(以表格方式) 删除表:drop table TTT; 修改表： 添加字段：alter table TTT add column COLUMNNAME TYPE(LENGTH);多个操作，多个add，逗号隔开alter table TTT add column a int(10), add b int(20); 修改字段类型：alter table TTT modify column COLUMNNAME varchar(100); 修改字符名称：alter table TTT change column COLUMNNAME NEWNAME 类型； 删除字段：alter table TTT drop column COLUMNNAME,drop column COLUMNNAME2; 修改表名：alter table TTT rename to NEWNAME; 管理数据 查看所有数据：select * from TTT; 插入数据：insert into TTT values();插入部分和值的顺序和数量要保持一致。insert into person(id,name,gender) values(3,&#39;&#39;mike,&#39;male&#39;); 修改数据： 修改所有：update TTT set COLUMN=’new value’; 修改某一个数据：update TTT set COLUMN=’’ where COLUMN2 = ‘’; 修改某一条多列：update TTT set COLUMN1=’’,set COLUMN2=’’ where id = 2; 删除数据： 全表删除：delete from TTT; 条件删除：delete from TTT where …; truncate删除：truncate table TTT; truncate只能全标删除，不能按条件删除； delete from删除可以回滚，truncate不能回滚。 truncate会把自增长约束（auto increment）重置，前者不会。 查询语句 查询去除重复数据：select distinct COLUMN from TTT;(取出column中的重复数据) 判空条件查询：=””; isnull; &lt;&gt;””; is not null 模糊条件：like + %:任意多个字符 _:表示一个字符 聚合查询：SUM/AVG/MAX/MIN/COUNT：count(id) better than count(*) 分页查询：limit 起始行数，查询的行数；select * from TTT limit 10,5; 查询后排序：order by // desc:降序 asc:升序 select * from TTT order by COLUMN desc,COLUMN2 asc; 分组查询：group by //select * from TTT group by COLUMN; 分组后筛选：group by + having (条件)//select * from TTT group by COLUMN having ...; 数据约束 外键约束：约束两张表的数据(foreign key)在副表中定义以下语句：constraint employ_dept_fk(外键名称) foreign key (deptId外键字段) references dept主表(id参考字段); 级联技术（外键的基础上）：修改或者删除主表的数据，同时能影响到副表的数据。 添加级联修改：on update cascade; 添加级联删除：on delete cascade;constraint employee_dept_fk foreign key (deptId) references dept(id) on update cascade on delete cascade; 多表查询 交叉连接查询（笛卡尔积），产生笛卡尔积的原因是没有足够的连接条件。多表查询的步骤：a、查询哪些表。b、查询哪些字段。3、确定哪些条件。 内连接查询（只有满足链接条件的数据才会显示出来）select a.id,b.deptId from table1 a,table2 b where a.id = b.deptId;select a.id,b.deptId from table1 a inner join table2 b on a.id = b.deptId; 左连接查询（左表完全显示，右表只有满足条件才会显示，否则显示null）select a.id,b.deptId from table1 a left outer join table2 b on a.id = b. deptId; 右连接查询select a.id,b.deptId from table1 a right outer join table2 b on a.id = b.deptId; 自连接查询：同一表中各字段查询。select a.id,b.deptId from table1 a left outer join table2 b on a.id = b.deptId; 存储过程暂未复习 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151什么是存储过程 存储过程，带有逻辑的sql语句 之前的sql没有条件判断，没有循环 存储过程带上流程控制语句（if while） 存储过程特点 1）执行效率非常快！存储过程是在数据库的服务器端执行的！！！ 2）移植性很差！不同数据库的存储过程是不能移植。 存储过程语法-- 创建存储过程DELIMITER $ -- 声明存储过程的结束符CREATE PROCEDURE pro_test() --存储过程名称(参数列表)BEGIN -- 开始 -- 可以写多个sql语句; -- sql语句+流程控制 SELECT * FROM employee;END $ -- 结束 结束符-- 执行存储过程CALL pro_test(); -- CALL 存储过程名称(参数);参数：IN： 表示输入参数，可以携带数据带存储过程中OUT： 表示输出参数，可以从存储过程中返回结果INOUT： 表示输入输出参数，既可以输入功能，也可以输出功能 -- **************三、存储过程*******************--- 声明结束符-- 创建存储过程DELIMITER $CREATE PROCEDURE pro_test()BEGIN -- 可以写多个sql语句; SELECT * FROM employee;END $-- 执行存储过程CALL pro_test();-- 3.1 带有输入参数的存储过程-- 需求：传入一个员工的id，查询员工信息DELIMITER $CREATE PROCEDURE pro_findById(IN eid INT) -- IN: 输入参数BEGIN SELECT * FROM employee WHERE id=eid;END $ -- 调用CALL pro_findById(4);-- 3.2 带有输出参数的存储过程DELIMITER $CREATE PROCEDURE pro_testOut(OUT str VARCHAR(20)) -- OUT：输出参数BEGIN -- 给参数赋值 SET str='helljava';END $-- 删除存储过程DROP PROCEDURE pro_testOut;-- 调用-- 如何接受返回参数的值？？-- ***mysql的变量******-- 全局变量（内置变量）：mysql数据库内置的变量 （所有连接都起作用） -- 查看所有全局变量： show variables -- 查看某个全局变量： select @@变量名 -- 修改全局变量： set 变量名=新值 -- character_set_client: mysql服务器的接收数据的编码 -- character_set_results：mysql服务器输出数据的编码 -- 会话变量： 只存在于当前客户端与数据库服务器端的一次连接当中。如果连接断开，那么会话变量全部丢失！ -- 定义会话变量: set @变量=值 -- 查看会话变量： select @变量 -- 局部变量： 在存储过程中使用的变量就叫局部变量。只要存储过程执行完毕，局部变量就丢失！！-- 1)定义一个会话变量name, 2)使用name会话变量接收存储过程的返回值CALL pro_testOut(@NAME);-- 查看变量值SELECT @NAME;-- 3.3 带有输入输出参数的存储过程DELIMITER $CREATE PROCEDURE pro_testInOut(INOUT n INT) -- INOUT： 输入输出参数BEGIN -- 查看变量 SELECT n; SET n =500;END $-- 调用SET @n=10;CALL pro_testInOut(@n);SELECT @n;-- 3.4 带有条件判断的存储过程-- 需求：输入一个整数，如果1，则返回“星期一”,如果2，返回“星期二”,如果3，返回“星期三”。其他数字，返回“错误输入”;DELIMITER $CREATE PROCEDURE pro_testIf(IN num INT,OUT str VARCHAR(20))BEGIN IF num=1 THEN SET str='星期一'; ELSEIF num=2 THEN SET str='星期二'; ELSEIF num=3 THEN SET str='星期三'; ELSE SET str='输入错误'; END IF;END $CALL pro_testIf(4,@str); SELECT @str;-- 3.5 带有循环功能的存储过程-- 需求： 输入一个整数，求和。例如，输入100，统计1-100的和DELIMITER $CREATE PROCEDURE pro_testWhile(IN num INT,OUT result INT)BEGIN -- 定义一个局部变量 DECLARE i INT DEFAULT 1; DECLARE vsum INT DEFAULT 0; WHILE i&lt;=num DO SET vsum = vsum+i; SET i=i+1; END WHILE; SET result=vsum;END $DROP PROCEDURE pro_testWhile;CALL pro_testWhile(100,@result);SELECT @result;USE day16;-- 3.6 使用查询的结果赋值给变量（INTO）DELIMITER $CREATE PROCEDURE pro_findById2(IN eid INT,OUT vname VARCHAR(20) )BEGIN SELECT empName INTO vname FROM employee WHERE id=eid;END $CALL pro_findById2(1,@NAME);SELECT @NAME; 触发器触发器作用当操作了某张表时，希望同时触发一些动作/行为，可以使用触发器完成！！ 创建触发器(添加)CREATE TRIGGER tri_empAdd AFTER INSERT ON employee FOR EACH ROW – 当往员工表插入一条记录时 INSERT INTO test_log(content) VALUES(‘员工表插入了一条记录’); 创建触发器(修改)CREATE TRIGGER tri_empUpd AFTER UPDATE ON employee FOR EACH ROW – 当往员工表修改一条记录时 INSERT INTO test_log(content) VALUES(‘员工表修改了一条记录’); 创建触发器(删除)CREATE TRIGGER tri_empDel AFTER DELETE ON employee FOR EACH ROW – 当往员工表删除一条记录时 INSERT INTO test_log(content) VALUES(‘员工表删除了一条记录’); 删除触发器DROP TRIGGER trigger_name; 分别修改表和字段编码 修改表的编码方式：ALTER TABLE test DEFAULT CHARACTER SET utf8;该命令用于将表test的编码方式改为utf8； 修改字段的编码方式：ALTER TABLE test CHANGE name name VARCHAR(36) CHARACTER SET utf8 NOT NULL; 该命令用于将表test中name字段的编码方式改为utf8 mysql权限问题 mysql数据库权限问题：root ：拥有所有权限（可以干任何事情）– 权限账户，只拥有部分权限（CURD）例如，只能操作某个数据库的某张表– 如何修改mysql的用户密码？– password: md5加密函数(单向加密)SELECT PASSWORD(‘root’); – *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B mysql数据库，用户配置 : user表USE mysql; SELECT * FROM USER; 修改密码UPDATE USER SET PASSWORD=PASSWORD(‘123456’) WHERE USER=’root’; 分配权限账户GRANT SELECT ON day14.table1 TO ‘user1‘@’localhost’ IDENTIFIED BY ‘123456’;GRANT DELETE ON day14.table1 TO ‘user1‘@’localhost’ IDENTIFIED BY ‘123456’; 如何创建用户？create user userName identified by ‘password’; 如何切换用户？先退出当前用户。mysql -u username -p database回车输入密码 快速构建表结构相同的表？create table table2 like table1; JdbcJdbc是Oracle—sun公司设计的专门用于Java程序操作数据库的一套接口。 Jdbc的核心API导入驱动包 mysql-connector-java-5….-bin.jar1234567891011121314151617181920212223|-Driver接口： 数据库驱动程序的接口，所有具体数据库厂商需要的驱动程序需要实现此接口。 Connection connect(String url, Properties info) 用于获取数据库连接 |-Connection接口：与具体的数据库的连接对象。 Statement createStatement() 创建一个静态sql语句对象 PreparedStatement prepareStatement(String sql) 创建预编译的sql语句对象 CallableStatement prepareCall(String sql) 创建存储过程的sql语句对象 |-Statement接口：用于执行静态 SQL 语句 int executeUpdate(String sql) 执行更新操作的sql语句（create/alter/drop/insert/update/delete） ResultSet executeQuery(String sql) 执行查询操作的sql语句 (select) |- PreparedStatement接口：用于执行预编译的 SQL 语句（是Statement的子接口） int executeUpdate() 执行更新操作的sql语句 ResultSet executeQuery() 执行查询操作的sql语句 |- CallableStatement接口：用于执行 SQL 存储过程的接口（是PreparedStatement的子接口） ResultSet executeQuery() 执行存储过程的sql语句 |- ResultSet接口：结果集对象。 存储所有数据库查询的结果，用该对象进行数据遍历。 boolean next() ： 把光标移动到下一行。如果下一行有数据，返回true，如果没有下一行数据，返回false。 getXXX（列索引|列字段名称）： 获取字段的数据 Jdbc操作步骤 注册驱动程序 Class.forName(&quot;com.mysql.Jdbc.Driver&quot;); 获取连接对象 方式1：直接使用驱动程序链接：driver.connet(url,properties);通过url识别需要连接的数据库。 方式2：使用驱动管理类DriverManager链接数据库。DriverManager.getConnection(url,properties); 创建statement对象conn.createStatement(); 执行sql语句 DDL+DML：executeUpdate(sql); DQL：executeQuery(sql); 返回结果 executeQuery()反馈ResultSet URL详解Jdbc协议+数据库协议+主机地址+端口+链接的数据库 关于注册驱动Class.forName(“com.mysql.Jdbc.Driver”);在Driver类中的静态代码块在类加载的时候执行了注册。我们不需要new 对象注册。详解：https://zhidao.baidu.com/question/495508609917097644.html 关于DDL、DML、DQLDDL（data define language）:create\alter\dropDML（data manipulation language）：insert\update\delete\truncateDQL（data query language）：select\show 关于ResultSet next()返回下个是否存在，控制指针下移一位。 getObject() getInt(); getString();参数可以是index也可以是字段名。index从1开始。 一行的列数：set.getMetaDate().getColumnCount();元数据封装了返回的ResultSet信息。 statement与preparestatement 的区别：1、语法不同。静态与动态，？占位符的区别。2、安全性不同。statement可能会被注入！！3、在Oracle中，由于存在sql缓存区，PreparedStatement相同的语句不会重复创建，因此效率更高。 prepared赋值索引从1开始，没有参数不需赋值。?没有引号。 使用类路径的方式加载db.properties文件 获取类对象Class clazz = 类名.class; 使用类路径读取方法去读取文件clazz.getResourceAsStream(“/db.properties”); 关于相对路径在Web中.代表相对路径：代表当前目录，本质是Java命令运行的目录。java项目中：相对路径代表项目的根目录。web项目中：相对路径指的是tomcat的bin目录。因此：web项目中不能使用相对路径，即不能使用.在web项目中一般使用：ServletContext.getRealPath()+”/“获取路径。但这种方Java项目中不通用。 因此使用类路径的方式获取配置文件。 “/”代表当前项目的类路径的根目录： 在Java项目下：类路径的根目录指向项目的bin目录。不是src目录哟，但是src下的配置文件也会拷贝到bin目录下。 在Web项目下：类路径的根目录指向项目的WEB-INF/classes目录。而当把配置文件放置在src的根目录下时，这些文件会自动拷贝到项目的类路径根目录下，即WEB-INF/classes目录，因此通过“/”的方式，是可以找到web项目下的properties文件的。 Jdbc处理大容量数据 mysql：字符串： varchar char 16位 65535=2^16-1&lt;字符&gt; 大文本数据：tinytext，longtext，text字节：bit&lt;字节&gt;大字节文件：tinyblob(255byte)，blob(64kb)，MEDIUMBLOB(约16M)，longBlob(4GB) oracle字符串： varcharz char 16位 65535=2^16-1&lt;字符&gt; 大文本数据：clob字节：bit&lt;字节&gt;大字节文件：blob 针对mysql text类型，prepareStatement.setCharacterStream(Reader); blob类型，prepareStatement.setBlob(InputStream); 读取 ResultSet:getString,getClob,getBlob,getBinaryStream 123456789101112131415161718public class Connect3 &#123; public static void main(String[] args) &#123; try &#123; Connection conn = DriverManager.getConnection("Jdbc:mysql:///day14?useUnicode=true&amp;characterEncoding=utf8","root","root"); PreparedStatement ps = conn.prepareStatement("insert into table5(title,content,video) values(?,?,?)"); ps.setString(1, "中文"); Reader reader = new FileReader(new File("H:/Java核心技术（卷一）（第六章 接口与内部类）.md")); ps.setCharacterStream(2, reader); InputStream is = new FileInputStream(new File("f:/CloudMusic/Imagine Dragons - Radioactive (Acoustic).mp3")); ps.setBlob(3, is); ps.execute(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注：mysql数据库默认情况下，只能存储不超过1m的文件，由于max_allowed_packet变量的限制。可以修改： %mysql%/my.ini文件, 修改或添加max_allowed_packet变量，然后重启mysql即可。 数据库事务多条sql语句一起执行，一起成功一起失败。 mysql事务操作命令set autocommit =0 / 1; 设置是否自动提交事务 – 1： 表示自动提交事务，每执行一条sql语句，自动提交事务。 – 0： 表示关闭自动提交事务。start transaction; 开启事务commit; 提交事务，一旦提交事务不能回滚rollback; 回滚事务。回滚到事务的起始点。 Jdbc事务操作Connection.setAutoCommit(false) 开启事务Connection.commit(); 成功执行，最后提交事务Connection.rollback(); 一旦遇到错误，回滚事务 事务4大特性原子性： 要么一起成功过，要么一起失败一致性： 数据库应该从一个一致性的状态到另一个一致性的状态，保持不变隔离性： 多个并发事务直接应该可以相互隔离 脏读：一个事务读到另一个事务未提交的数据。 不可重复读：一个事务中读到另一事务已提交的数据，即同一事务中读到的同一字段信息不一样。 幻读：一个事务中读到另一事务已提交的新插入的数据。 1234567891011121314不可重复读的重点是修改:同样的条件, 你读取过的数据, 再次读取出来发现值不一样了幻读的重点在于新增或者删除同样的条件, 第1次和第2次读出来的记录数不一样 脏读 不可重复读 幻读 read uncommitted: 否 否 否 read committed : 是 否 否 repeatable read: 是 是 否 serializable： 是 是 是 结论： 隔离性越高，数据库的性能越差。 持久性： 事务一旦提交，应该永久保持下来。 连接池作用 提高Connection对象的利用率，提高执行sql的效率。 控制Java程序使用连接数据库的最大连接数，防止数据库崩溃。 连接池工具DBCP连接池DBCP: DataBase Connection Pool特点： 1. Apache旗下的软件，开源连接池 2. Tomcat的服务器的连接池默认实现 使用步骤： 1. 导入dbcp的jar包 commons-dbcp-1.4.jar 核心包 commons-pool-1.5.6.jar 辅助包 2. 创建连接池对象BasicDataSource对象 3. 设置连接参数（url，user，password，dirverClass） 4. 设置连接池参数（初始连接数，最大连接数，最大等待时间） 5. 获取连接对象（getConnection() 方法） 123456789101112131415161718192021222324252627282930public void test1()&#123; try &#123; //1.创建连接池对象 BasicDataSource ds = new BasicDataSource(); //2.设置连接参数 ds.setUrl("Jdbc:mysql://localhost:3306/day14"); ds.setUsername("root"); ds.setPassword("root"); ds.setDriverClassName("com.mysql.Jdbc.Driver"); //3.设置连接池参数 ds.setInitialSize(5);//初始连接数 ds.setMaxActive(8);//最大连接数 ds.setMaxWait(3000);//超过最大连接数时，最大等待时间 ds.setMaxIdle(3000);//最大空闲时间 //4.获取连接 for(int i=1;i&lt;=9;i++)&#123; Connection conn = ds.getConnection(); System.out.println(conn.hashCode()); if(i==5)&#123; //释放连接(不是真正的关闭连接对象，而是把连接对象放回连接池) conn.close(); &#125; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; 使用配置文件加载BasicDataSource ds = (BasicDataSource)BasicDataSourceFactory.createDataSource(prop); C3P0连接池特点： 1）开源连接池 2）Hibernate框架，默认推荐使用C3P0作为连接池实现 使用步骤： 1）导入c3p0的jar包 c3p0-0.9.1.2.jar 核心包 2）创建连接池对象ComboPooledDataSource对象 3）设置连接参数（url，user，password，dirverClass） 4）设置连接池参数（初始连接数，最大连接数，最大等待时间） 5）获取连接对象（getConnection() 方法） 1234567891011121314try &#123; //1.创建连接池对象 ComboPooledDataSource ds = new ComboPooledDataSource(); //2.设置连接参数 ds.setDriverClass("com.mysql.Jdbc.Driver"); ds.setJdbcUrl("Jdbc:mysql://localhost:3306/day19"); ds.setUser("root"); ds.setPassword("root"); //3.设置连接池参数 ds.setInitialPoolSize(5);// 初始化连接数 ds.setMaxPoolSize(8);//最大连接数 ds.setCheckoutTimeout(3000);//最大等待时间&#125; 使用配置方式读取参数信息注意： c3p0会默认查询类路径的c3p0-config.xml文件，文件名不能错&lt;default-config&gt;&lt;named-config&gt;调用有参构造方法时需配置1234567try &#123; //1.创建连接池对象（方式一： 使用默认配置（default-config）） //ComboPooledDataSource ds = new ComboPooledDataSource(); //2.创建连接池对象（方式二： 使用命名配置（named-config：mysql_day18）） ComboPooledDataSource ds = new ComboPooledDataSource("mysql_day18");&#125; BeanUtils工具BeanUtils工具的作用BeanUtils工具可以方便开发者对象javabean进行操作 JavaBean规范： 1）必须有无参的构造方法 2）把属性进行私有化 3）提供公开的getter和setter方法 使用步骤： 1）导入beanutills的jar包 commons-beanutils-1.8.3.jar 核心包 commons-logging-1.1.3.jar 辅助包 JavaBean操作1）对JavaBean的属性进行赋值BeanUtils.copyProperty(bena,name,value); 基本类型自己转换，引用类型需注册转换器ConvertUtils.register(new Converter(),Class); 若需拷贝的是数组类型，则只拷贝数组的第一个元素。 2）对JavaBean的对象赋值123456789101112131415161718192021222324/** * 拷贝整个javabean的对象（所有属性一次性拷贝） * @throws Exception */ @Test public void test2() throws Exception&#123; Student student = new Student(); student.setId(1); student.setName("eric"); student.setGender(true); student.setScore(79.43); student.setBirth(new Date()); //1.使用反射构造对象 Object student2 = Class.forName("cn.ustb.d_beanutils.Student").newInstance(); //2.把student的属性拷贝到student2中 /** * 参数一： 目标的javabean * 参数二： 拷贝的源javabean */ BeanUtils.copyProperties(student2, student); System.out.println(student2); &#125; 3）把Map数据赋值给JavaBean对象 1234567891011121314151617181920/** * 把map集合的数据拷贝到javabean中 * @throws Exception */ @Test public void test3() throws Exception&#123; Map map = new HashMap(); map.put("id", 2); map.put("name", "rose"); map.put("gender", true); map.put("score", 90.32); map.put("birth", new Date()); //1.使用反射构造对象 Object student2 = Class.forName("cn.ustb.d_beanutils.Student").newInstance(); //2.把map数据拷贝到student2中 BeanUtils.copyProperties(student2, map); System.out.println(student2); &#125; 元数据的使用什么是元数据？希望知道以下： 一、数据库相关的信息：（封装到数据库元对象： DataBaseMetaData）Connection.getMetaData(); 数据库的版本 驱动程序的版本 二、参数相关的信息：(封装到参数元对象：ParameterMetaData)Statement.getParameterMetaData(); 参数数量 参数类型 三、结果相关的信息：(封装到结果集元对象： ResultSetMetaData)ResultSet.gerMetaData(); 列数量 列名称 使用元数据可以写出更通用的Jdbc代码。 DBUtils工具DBUtils是Apache的工具，是一个对Jdbc的简单封装的工具。提供了一些通用的Jdbc操作方法。 使用步骤1)导入jar包 commons-dbutils-1.2.jar 2)QueryRunner qr = new QueryRunner(DataSource ds);DataSource是Jdbc的接口。统一了所有的第三方连接池工具获取链接的方法。子类有ComboPooledDataSource，BasicDataSource等。所以，用DBUtils还是离不开C3P0或者DBCPDBUtils只是对Jdbc操作的封装。 3）使用的APIQueryRunner类： 通过此类可以执行更新操作或者查询操作。 update(…..): 用于更新操作（DDL、DML） query(…..): 用于查询操作（DQL） query(String sql,ResultHandler rsh,Object[] params); ResultSetHandler接口：用于封装查询之后的结果。 Object handle(ResultSet rs) ： 用于封装数据 1234567891011常用的实现类： ArrayHandler： 把结果集的第一行的数据封装成对象数组。 ArrayListHandler：把结果集的每一行数据封装对象数组，把这个对象数组放入List中 BeanHandler： 把结果集的第一行数据封装成javabean BeanListHandler: 把结果集的每一行数据封装成javabean，把这个javabean放入List中 ScalarHandler： 把结果集的第一行第一列取出。通常用于聚合函数查询。例如count()/max()） qr.query(&quot;select * from student where id = ?&quot;, new ArrayHandler(), new Object[]&#123;1&#125;); qr.query(&quot;select * from student&quot;, new ArrayListHandler()); qr.query(&quot;select * from student where id = ?&quot;, new BeanHandler(Student.class), new Object[]&#123;1&#125;); qr.query(&quot;select * from student&quot;, new BeanListHandler(Student.class)); 如果表的字段名称和javabean的属性名称不一致时，需要自定义ResultSetHandler的实现类 自定义ResultSetHandler 1234567891011121314151617class MyStudentHandler implements ResultSetHandler&#123; @Override public Object handle(ResultSet rs) throws SQLException &#123; List&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); while(rs.next())&#123; Student s = new Student(); s.setId(rs.getInt("sid")); s.setName(rs.getString("sname")); s.setAge(rs.getInt("sage")); s.setAddress(rs.getString("saddress")); list.add(s); &#125; return list; &#125; &#125; ing(“saddress”)); list.add(s); } return list; } }`]]></content>
      <categories>
        <category>学习笔记</category>
        <category>笔记整理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>mysql</tag>
        <tag>Jdbc</tag>
        <tag>连接池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记整理（9）]]></title>
    <url>%2F2019%2F02%2F14%2F%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%889%EF%BC%89%2F</url>
    <content type="text"><![CDATA[笔记整理（9）整理了从开始学习Java以来在纸质本上做的一些笔记，如有错误，恳请批评指正。 Jsp基础简介Jsp，全称Java Server Page。Java服务页面，能提供Java服务的页面。Jsp的主要作用是用java语言来开发动态资源的技术。 Jsp VS html 既可以写html代码，也可以写Java代码。 Jsp页面需要交给tomcat服务器运行。 Jsp运行的目录tomcat的work目录，这个目录下存放jsp页面运行过程中产生的临时文件。 jsp文件中的html代码和java代码是如何被执行的？html代码： 通过out.write(“内容”); 方法输出到浏览器java代码： 原封不动拷贝到java源文件中被执行 Jsp页面如何被tomcat服务器运行第一次访问jsp： 1）tomcat服务器把jsp页面翻译成java源文件。（01.hello.jsp -》 _01_hello_jsp.java） 2）tomcat服务器把java源文件编译成class文件。_01_hello_jsp.java -&gt; _01_hello_jsp.class 3）读取class文件，创建类对象。_01_hello_jsp 4）执行类中的方法。_01_hello_jsp类的方法 第n次访问jsp：直接走第4个步骤 4）执行类中的方法。_01_hello_jsp类的方法 注意： 修改了jsp页面时，重新走翻译和编译的过程。 问题：运行的class类是什么类？ 123public final class _01_hello_jsp extends org.apache.jasper.runtime.HttpJspBasepublic abstract class org.apache.jasper.runtime.HttpJspBase extends javax.servlet.http.HttpServlet implements javax.servlet.jsp.HttpJspPage &#123;&#125; 我们的jsp的源文件是一个servlet！ 结论： jsp就是一个servlet！！！！ servlet的技术可以用在jsp上。 servlet的生命周期： 构造方法： init方法： service方法 destory方法 jsp的生命周期 翻译（java文件） 编译（class文件） 构造方法 _jspInit方法 _jspService方法 _jspDestroy方法 Jsp表达式语法： &lt;%=变量或表达式%&gt; 作用： 向浏览器输出变量的值或表达式技术的结构 注意： 1）原理是使用out.print()方法向浏览器输出内容 2） Jsp脚本语法：&lt;% java语句 %&gt; 作用： 执行java语句 原理： 脚本就是原封不动地翻译到java文件的_jspServcice方法中执行。 Jsp声明语法：&lt;%! 变量或方法 %&gt; 作用：用于声明变量或方法 原理： 声明的变量是成员变量，声明的方法是成员方法 注意： 1）不要声明和翻译后的java文件相同的方法名 2）jsp脚本不能声明方法 Jsp注释语法： &lt;%-- jsp注释 --%&gt; 作用： 注释jsp页面内容 注意： html的注释会被翻译和执行，而jsp的注释不会被翻译和执行。 Jsp表达式的作用：向浏览器输出变量或者表达式的内容，2）结尾不能使用分号 Jsp脚本的作用：是执行Java代码，其原理是把代码加入到JspService方法中 Jsp声明的作用：是声明成员变量和成员方法，方法不能在脚本中定义，只能在Jsp声明中定义；不能声明和翻译之后相同名称的方法 Jsp脚本和jsp表达式都会被翻译至_JspService方法中,Jsp声明声明的是成员变量和方法，不会被翻译至_jspService方法中，所以：Jsp脚本和Jsp表达式中都可以用Jsp的内置对象，而Jsp声明中不可以。 Jsp三大指令语法： &lt;%@ 指令 %&gt; taglib指令taglib指令主要是用于导入jsp的标签库。 include指令作用：用于包含其他页面 12&lt;%--包含头部页面 --%&gt; &lt;%@ include file=&quot;/common/header.jsp&quot;%&gt; 原理： 1. 直接把包含与被包含页面的内容先合并在一起，然后翻译成一个java源文件，最后编译执行。（**先合并再翻译**） （源码包含，也叫做**静态包含**） 2. 被包含的页面不要使用**全局**的html标签。（html/head/title/body） page指令作用：告诉浏览器如何翻译jsp文件 123456789101112131415161718192021222324252627282930&lt;%@ page language="java" --告诉服务器以什么语言来翻译jsp文件 import="java.util.*" --导包。多个包用逗号分隔 java.util.Date,java.text.SimleDateFromat jsp编码相关的 pageEncoding="utf-8" --jsp翻译成java文件时使用的编码 contentType="text/html; charset=utf-8" --服务器返回给浏览器的数据类型和编码 jsp中涉及中文编码问题： 1）保存jsp文件时的编码（另存为） 2）jsp翻译成java文件时的编码（pageEncoding） 3）服务器输出到浏览器的数据编码（contentType） 注意： 1）contentType属性如果不写，会参考pageEncoding的编码 2）在ecplise中开发jsp，保存文件时的编码会参考pageEncoding编码 结论： 在ecplise中开发jsp文件，只需要在page指令中设置pageEncoding的属性即可解决中文乱码问题！！ 错误页面相关的 errorPage="error.jsp" --指定错误页面 isErrorPage="false" --指定当前页面是否为错误页面。如果是true，那么就可以是exception内置对象，如果false，则不能使用exception内置对象。exception用于得到错误信息。 buffer="8kb" --jsp页面的缓存区大小 session="true" --是否打开session功能。是否可以使用session内置对象 isELIgnored="false" --是否忽略EL表达式。false，不忽略，可以使用EL；true，不 能EL%&gt; 全局错误页面配置： 在web.xml文件中设置 通常配置两种错误： 404 50012345678910 在web.xml文件中配置：&lt;!-- 配置全局的错误处理页面 --&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/common/404.html&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/common/500.jsp&lt;/location&gt; &lt;/error-page&gt; Jsp的最佳实践servlet技术： 使用java语言开发动态网页。功能：写java代码，输出html代码 jsp技术： 使用java语言开发动态网页。功能：写java代码，输出html代码 分工问题： servlet技术： 写java代码（写普通java类） jsp技术： 输出html代码（类似于html页面） 项目中涉及的功能： 1）接收参数信息 （servlet做） 2）执行业务逻辑（CURD） ( servlet做 ) 3）返回结果，输出结果 （jsp做） 4）跳转页面 （servlet做） Jsp的9大内置对象什么是Jsp的内置对象？在Jsp的开发过程中，开发者会频繁地使用到一些对象，例如Request，Session对象，ServletConfig，ServletContext，如果每次要使用这些对象都要去创建或者调用方法去得到就比较麻烦。Sun公司为了更加方便开发者在jsp文件中直接得到这些对象，直接就帮我们创建或得到好了这些对象，开发者直接使用这些对象即可，这些直接可以使用的对象就叫内置对象！！！！ 12345678910&lt;%//使用请求对象HttpServletRequestrequest.getContentPath();//使用HttpSession对象HttpSession session = requesst.getSession(); --之前的servlet做法session.setAttribute(name,object);%&gt; 9个内置对象对象名 对应的类型 备注 request HttpServletRequest 请求对象，封装请求信息 response HttpServletResponse 响应对象，封装响应信息 config ServletConfig servlet配置对象，封装servlet配置信息 application ServletContext servlet的上下文对象，代表整个web应用环境 session HttpSession 会话对象。用于保存会话数据 exception Throwable 异常对象，用于封装异常信息 （需声明@ page isErrorpage=&quot;true&quot;） page Object 代表当前jsp翻译成java类对象 out JspWriter jsp页面缓存对象，相当于带缓存功能的PrintWriter pageContext PageContext jsp的上下文件对象，代表当前jsp的环境 out对象 out对象，类型JspWriter out.wirter(&quot;内容&quot;) 1）PrintWrite类： 直接往浏览器写出内容 out.write（“内容”）; 2）JspWriter类： 相当于带缓存的PrintWriter out.write(&quot;内容&quot;)： 把内容写入缓存区 response.getWriter()返回的是PrintWriter，其write()方法是直接写出。 注意： 当JspWriter缓存区满足以下条件，缓存区内容会写入到PrintWriter中。 1）缓冲区满了。 2）刷新缓冲区（JspWriet.flush()） 3）关闭缓冲区 （&lt;%@page buffer=&quot;0kb&quot;%&gt; buffer属性用于设置Jsp&apos;Writer缓存区大小，默认8KB） 4）执行完Jsp页面 得到当前缓冲区大小： out.getBufferSize() 得到当前缓冲区剩余大小： out.getRemaining() pageContext对象pageContext对象，类型PageContext类。 包含了其他8个内置对象的引用Jsp文件翻译的java类 123456789101112131415161718192021222324252627282930313233343536public class _02_out_jsp&#123; public void _jspService(HttpServletRequest rquest, HttpServetResponse response)&#123; HttpSession session; ServletConfig config; ...... //Sun设计了一个PageContext对象，用于存放其他8个内置对象 PageContext pageContext; //调用method1 method1(pageContext) &#125; public void method1(PageContext pageContext)&#123; //要使用8个内置对象 pageContext.getSession(); pageContext.getRequest(); pageContext.getResponse(); ...... &#125;&#125;&lt;% session.setAttribute(&quot;name&quot;, &quot;jason&quot;); out.write(&quot;相等吗？&quot;+(pageContext.getRequest() == request)+&quot;&lt;br/&gt;&quot;); out.write(&quot;相等吗？&quot;+(pageContext.getResponse() == response)+&quot;&lt;br/&gt;&quot;); out.write(&quot;相等吗？&quot;+(pageContext.getSession() == session)+&quot;&lt;br/&gt;&quot;); out.write(&quot;相等吗？&quot;+(pageContext.getServletContext() == application)+&quot;&lt;br/&gt;&quot;); out.write(&quot;相等吗？&quot;+(pageContext.getPage() == page)+&quot;&lt;br/&gt;&quot;); out.write(&quot;相等吗？&quot;+(pageContext.getException() == exception)+&quot;&lt;br/&gt;&quot;); out.write(&quot;相等吗？&quot;+(pageContext.getServletConfig() == config)+&quot;&lt;br/&gt;&quot;); out.write(&quot;相等吗？&quot;+(pageContext.getOut() == out)+&quot;&lt;br/&gt;&quot;); %&gt; 以上情况，在自定义标签中频繁使用到！！！ PageContext作为域对象 作用： **保存**数据和**获取**数据，**清除**数据 方法： getAttribute() setAttribute() removeAttribute(); 保存数据： 默认情况保存到page域中 pageContext.setAttribute(name,object); 可以指定域保存 pageContext.setAttribute(name,object, **int 域范围**) 域范围：PAGE_SCOPE, REQUEST_SCOPE, SESSION_SCOPE , APPLICATION_SCOPE 取出数据： 默认情况，从page域取出 pageContext.getAttribute(name); 可以指定域取出 pageContext.getAttribute(name, int 域范围) 域范围：PAGE_SCOPE, REQUET_SCOPE, SESSION_SCOPE , APPLICATION_SCOPE从四个域中搜索： pageContext.findAttribute(name); 搜索顺序： page域-&gt; request域 -&gt; session域-&gt; application域 Jsp的四个域对象域对象的作用：用于保存数据，获取数据，在不同资源之间共享数据 域对象的方法：setAttribute(name,object) ; 保存数据方法getAttribute(name) 获取数据romoveAttribute(name) 清除数据 域对象作用范围page域： 对应域对象request域：处于同一个请求中数据共享是有效的！！（使用转发）session域：处于同一个会话中数据共享是有效的！！（同一个session对象）application域：处于同一个web应用中数据共享是有效的！！ 域对象名 对应类 范围 page PageContext 页面 request HttpServletRequest 请求 session HttpSession 会话 application ServletContext 整个项目 Jsp的最佳实战Jsp就是一个servlet！其被翻译之后就是Servlet，继承了HttpServlet，所以可以用Servlet的功能。而Servlet是一个特殊的Java类，Jsp和Servlet都用于开发动态的资源。 Servlet的作用：使用java代码开发动态资源。可以写java代码，输出html代码Jsp的作用： 使用java代码开发动作资源。可以写java代码，也可以输出html代码。 项目中可以会涉及的工作： 1）接收参数 2）处理业务逻辑 3）跳转其他资源 4）显示数据 Servlet：擅长写java代码Jsp：擅长显示数据 最佳实践： 利用servlet来处理java相关的逻辑事务，把需要显示的数据发送给jsp，然后在jsp中显示数据。 EL表达式在jsp显示数据，可以使用jsp表达式向浏览器输出数据。可以使用java脚本来执行业务逻辑。但是在Jsp页面中要尽量减少Java代码的使用量，甚至不用Java代码。 EL表达式用于替代jsp页面中的jsp表达式。Jsp标签用于替代jsp页面中的jsp脚本。 EL表达式的作用向浏览器输出域对象中的变量和表达式的计算结果。（EL表达式必须要求数据放在域对象中！） 基本语法${变量或者表达式} EL语法 获取数据四个域中获取：${变量}域范围：pageScope--&gt;requestScope--&gt;sessionScope--&gt;applicationScope指定域中获取：${域范围.变量} EL获取普通对象数据${student.name}表示调用getName()方法。 EL获取集合数据（List和Map集合）${map[‘key’].name}注意：map[key] 表示调用map对象的get(key)方法获取map的值对象 EL可以使用表达式 算术表达式 ：`${a+b}` 比较表达式: `${a&gt;b}` 逻辑表达式 : `${true &amp;&amp; true}` 判空表达式: `${empty name}` 表示判断name为null或者空字符 EL隐含对象EL表达式语言中定义了11个隐含对象，使用这些隐含对象可以很方便地获取web开发中的一些常见对象，并读取这些对象的数据。详见：http://blog.csdn.net/kyi_zhu123/article/details/54381221 隐含对象名称 描 述 pageContext 对应于JSP页面中的pageContext对象（注意：取的是pageContext对象。） pageScope 代表page域中用于保存属性的Map对象 requestScope 代表request域中用于保存属性的Map对象 sessionScope 代表session域中用于保存属性的Map对象 applicationScope 代表application域中用于保存属性的Map对象 param 表示一个保存了所有请求参数的Map对象 paramValues 表示一个保存了所有请求参数的Map对象，它对于某个请求参数，返回的是一个string[] header 表示一个保存了所有http请求头字段的Map对象 headerValues 同上，返回string[]数组。注意：如果头里面有“-” ，例Accept-Encoding，则要headerValues[“Accept-Encoding”] cookie 表示一个保存了所有cookie的Map对象 initParam 表示一个保存了所有web应用初始化参数的map对象 Jsp标签Jsp标签主要在jsp页面执行java代码，用于替换jsp脚本 EL表达式局限： 1）不能保存数据，只能获取数据 2）没有条件判断逻辑 3）没有数据遍历功能 Jsp标签分类 Jsp内置标签（动作标签）： 不需要导入标签库 JSTL标签库： 需要导入标签库 自定义标签： 需要导入标签库 Jsp内置标签&lt;jsp:forward/&gt; 转发标签：用于转发&lt;jsp:param/&gt; 参数标签&lt;jsp:incude/&gt; 包含标签：用于包含其他页面 注意：1）其原理是包含与被包含的页面先各自翻译成独立的java源文件，然后再运行时合并再一起。（先翻译再合并），这叫动态包含 ==== 静态包含 vs 动态包含==== 1）原理不一样 a）静态包含（先合并再翻译） b）动态包含（先翻译再合并） 2）语法不一样 a）静态包含（ includ指令： &lt;%@include%&gt; ） b）动态包含 （include标签： &lt;jsp:include /&gt;） 3）参数传递不同 a）静态包含不能传递参数 b）动态包含可以向被包含页面传递参数 &lt;jsp:include page=&quot;./index.jsp&quot;&gt;&lt;/jsp:include&gt;//动态包含 静态包含：先合并再翻译，被包含的页面不能有全局页面。翻译后生成一个Servlet。动态包含：先翻译再合并，如果包含的是Jsp，会生成两个Servlet页面。通过response和request进行通信。具体解析：http://blog.csdn.net/hackerain/article/details/6766206 JSTL标签jstl ， Java Starardard Tag Libarary Java标准标签库 以前： jsp2.0以前jstl不属于java规范。属于第三方的工具。需要导入jar包现在： jsp2.0 jstl纳入javaee规范。不需要导入jar包。 JSTL标签库分类： 1）核心标签库 （core/c ） 使用最频繁的 2）国际化互标签库（fmt） 3）EL函数库 （fn） 4）数据库标签库（sql） 5）Xml标签库（x） JSTL使用步骤1）确保jstl的支持jar包已经导入到项目中2）在jsp页面的顶部导入标签库 &lt;%@taglib uri=”tld文件的路径” prefix=”标签库缩写”%&gt;&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;tld文件： 标签库的声明文件（每套标签都有一个tld文件）3）使用标签库中的标签&lt;c:set&gt;&lt;/c:set&gt; JSTL核心标签库保存数据： &lt;c:set&gt;&lt;/c:set&gt; var:数据名称 value：数据值 scope：域对象&lt;page、request、session、application&gt; 获取数据 &lt;c:out value=&quot;&quot;&gt;&lt;/c:out&gt; value:代表获取域中某个名称的内容，若在域对象中，则必须使用EL标签获取。 default:当前获取为null时的替换值。 escapeXml:默认情况下为true，out标签会把输出的内容进行转义，若不需要转义，为false即可。 单条件判断： &lt;c:if test=&quot;&quot;&gt;&lt;/c:if&gt; 多条件判断 &lt;c:choose&gt;&lt;/c:choose&gt; &lt;c:when test=&quot;&quot;&gt;&lt;/c:when&gt; &lt;c:otherwise&gt;&lt;/c:otherwise&gt; 数据遍历 &lt;c:forEach&gt;&lt;/c:forEach&gt; items:需要遍历的数据，如果是获取域对象数据，必须用EL表达式获取。 &lt;c:forTokens items=&quot;&quot; delims=&quot;&quot;&gt;&lt;/c:forTokens&gt;遍历特殊字符串 items:需要遍历的字符串 delims:分隔符号 var:每个内容的名称 重定向标签 &lt;c:refirect/&gt; url:定位符 EL函数库EL函数库： 主要是用于在jsp页面中操作字符串 &lt;% String str = &quot;java-net-php&quot;; str.split(&quot;-&quot;); str.substring(0,1); %&gt; 自定义标签步骤： 开发标签处理程序，普通Java类，继承SimpleTagSupport类，覆盖doTag方法。 在项目的WEB-INF目录下建立一个tld文件，即约束，里面配置了标签名和相应的处理方法。 在Jsp顶部导入自定义标签库。 使用标签。 自定义标签执行步骤：]]></content>
      <categories>
        <category>学习笔记</category>
        <category>笔记整理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JSP</tag>
        <tag>EL标签</tag>
        <tag>Jsp标签</tag>
        <tag>JSTL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记整理（8）]]></title>
    <url>%2F2019%2F02%2F14%2F%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%888%EF%BC%89%2F</url>
    <content type="text"><![CDATA[笔记整理（8）整理了从开始学习Java以来在纸质本上做的一些笔记，如有错误，恳请批评指正。 Servlet编程servlet对象是单例的，一个项目里面有且仅有一个。 servlet直接传递数据 方式1：response.sendRedirect(“/servlet2?name=jack”);12345678910111213&lt;?xml version=”1.0” encoding=”utf-8”?&gt;&lt;web-app&gt;xml约束&lt;/web-app&gt;servlet的配置：&lt;servlet&gt; &lt;servlet-name&gt;name&lt;/servlet-name&gt; servlet内部名称，可以自定义 &lt;servlet-class&gt;包名+类名&lt;/servlet-class&gt;&lt;/servlet&gt;servlet的映射配置：&lt;servlet-mapping&gt; &lt;servlet-name&gt;与配置name保持一致&lt;/servlet-name&gt; &lt;url-pattern&gt;/+(访问名)&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; servlet接口——–GenericServlet实现（实现了init，service等方法）——–HttpServlet继承——–MyServlet继承！（init方法在GenericServlet类中实现，它是HttpServlet类的超类！！，service方法在HttpServlet中实现！） Servlet的执行过程servlet其实是一个实现了HttpServlet接口的Java类。交给tomcat服务器运行。 编写servlet类，实现HttpServlet接口。 将servlet的class字节码放入到tomcat的对应项目的WEB-INF/classes目录下。 在web.xml中配置servlet，tomcat会在启动的时候将每个项目的web.xml文件加载进内存。 通过URL访问这个servlet。 tomcat对URL的解析：如：http://localhost:8080/myproject/hello 截取URL的字符串，得到需要访问的资源的名称。/hello 在myproject项目文件的web.xml文件中搜索匹配url-pattern。 获取到servlet-class的内容。即web.xml中的配置：cn.ustb.servlet.HelloServlet 创建HelloServlet对象（单例），然后调用HelloServlet类中的方法。（通过反射创建对象） 把内容返回给浏览器用户。 web.xml中的url-pattern配置 通配符/*或者*.action不能共用。即/ustb/*.action是非法的。 要么以斜杠开头，要么号开头 非法的url-pattern: /ustb/.html 当多个url-pattern同时被匹配的情况下 2.1 精确匹配优先（长的最像的那个优先被匹配） 2.2 以后缀名结尾的url-pattern的优先级最低的 缺省路径&lt;url-pattern&gt;/&lt;/url-pattern&gt;,在tomcat内部被一个缺省Servlet(DefaultServlet)匹配，用于处理所有项目中的静态网页。原则：先动态，再静态如：localhost:8080/myproject/hello.html1）搜索myproject下面的web.xml文件信息。搜索是否存在匹配的&lt;url-pattern&gt;2）匹配到对应的url-pattern,执行对应的Servlet程序。3）如果没有匹配的url-pattern，就把这个请求交给tomcat服务器的DefaultServlet处理。4）DefaultServlet会在myproject的根目录下搜索是否存在一个名称叫hello.html的文件。5）如果找到次文件， 那么DefaultServlet读取该文件内容返回给用户。6）如果找不到次文件， 那么就给用户返回一个404状态码+404错误页面。 Servlet的生命周期servlet对象由服务器创建，第一次访问就会创建该对象（和单例不矛盾）。 Sevlet的四个重要的生命周期方法构造方法： 创建servlet对象时调用，只调用1次，证明了sevlet是单例的。init方法： 创建完对象之后调用。只调用1次。该方法用于初始化对象。service方法： 在每次请求时调用，调用n次。该方法入口方法，我们的逻辑代码在这里被调用。destory方法：在servlet对象销毁之后调用。只调用1次。重新部署网站或者停止服务器，servlet对象就会销毁了。 Servlet的线程并发问题引入servlet在tomcat服务器中，是单实例多线程的 开发线程安全的servlet建议 尽量不要使用成员变量，或者静态成员变量。 必须要使用成员变量，要么给使用了成员变量的代码块加同步锁，加锁的代码块的范围尽量缩小，因为有可能影响程序并发效率。 Servlet的自动加载机制（解决第一次访问创建servlet慢的问题）引入默认情况servlet对象是在第一次访问的时候创建。如果在这个servlet的构造方法或者init方法执行比较多的逻辑，那么第一次访问servlet的用户体验就不好！ 那么能不能改变创建servlet的机制？ 可以的，可以让servlet在服务器启动的时候自动加载。 自动加载的配置123456&lt;servlet&gt; &lt;servlet-name&gt;LifeDemo&lt;/servlet-name&gt; &lt;servlet-class&gt;gz.itcast.c_life.LifeDemo&lt;/servlet-class&gt; &lt;!-- 这个配置可以让servlet在tomcat服务器启动的时候自动创建servlet对象 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 注意：配置在servlet配置中而非servlet映射配置。load-on-startup中的整数值越大，创建的优先级越低！ Servlet的init方法两个init方法作用init(ServletConfig) 这个有参数的init方法的作用就是Servlet的其中一个重要的生命周期方法。这个方法一定会被tomcat服务器调用。 init(): 这个无参的init方法的作用就是为了提供给开发者方便去覆盖，覆盖这个方法，可以在此方法编写初始化的逻辑。这个方法才是真的给开发者做初始化逻辑的方法。 小结Servlet开发中涉及的对象： HttpservletRequest对象： 请求对象 HttpServletResponse对象： 响应对象 ServletConfig对象： servlet配置对象 ServletContext对象： servlet的上下文对象 ServletConfig对象 （一个网站一个项目有多个,与servlet对应）引入servletconfig是配置对象，主要把servlet的初始化参数封装到这个对象中。一个网站中可能会存在多个ServletConfig对象，一个ServletConfig对象就封装了一个servlet的配置信息。 配置初始化参数123456789&lt;servlet&gt; &lt;servlet-name&gt;ConfigDemo&lt;/servlet-name&gt; &lt;servlet-class&gt;gz.itcast.f_config.ConfigDemo&lt;/servlet-class&gt; &lt;!-- servlet的初始化参数 --&gt; &lt;init-param&gt; &lt;param-name&gt;path&lt;/param-name&gt; &lt;param-value&gt;e:/aaa.txt&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; 获取config对象： ServletConfig servletConfig = getServletConfig();在servlet中获取初始化参数： config.getInitParameter(“name”); 根据参数名称获取参数值 config.getInitParameterNames(); 获取所有参数名称 ServletContext对象（一个网站一个项目就一个，与project对应）引入ServletContext对象叫servlet上下文对象。 一个网站只会创建一个ServletContext对象。代表的是整个网站的环境信息。 获取ServletContext对象this.getServletConfig().getServletContext(); 通过ServletConfig对象来获取到ServletContext对象的！！ ServletContext对象：启动的时候创建ServletConfig对象：调用init方法之前创建的，在ServletContext对象创建之后 将context对象封装进config对象中，并提供对外获取的方法getServletContext()，以简化数据传输、简化方式：12345678910111213141516171819伪代码： public ServletCofig&#123; ServletContext context; public ServletConfig(context)&#123; this.context=context; &#125; public ServetContxt getServletContext()&#123; return context; &#125;&#125;ServletConfig config = new ServletConfig(context);public MyServlet extends HttpSevlet&#123; publlic init(ServletConfig config)&#123; SevletContext context= config. getServletContext(); &#125;&#125; ServletContext的5大作用 获取web应用的上下文路径。java.lang.String ----- ServletContext.getContextPath()简化版本：request.getContextPath(); 获取全局参数12java.lang.String getInitParameter(java.lang.String name) java.util.Enumeration getInitParameterNames() 设置全局参数12345678910111213141516171819&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt; &lt;!-- 配置web应用全局的参数 --&gt; &lt;context-param&gt; &lt;param-name&gt;AAA&lt;/param-name&gt; &lt;param-value&gt;AAA's value&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;BBB&lt;/param-name&gt; &lt;param-value&gt;BBB's value&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;CCC&lt;/param-name&gt; &lt;param-value&gt;CCC's value&lt;/param-value&gt; &lt;/context-param&gt; 注意：全局参数对当前web应用下的所有servlet都有效的！ 和域对象相关的 123void setAttribute(java.lang.String name, java.lang.Object object) java lang.Object getAttribute(java.lang.String name) void removeAttribute(java.lang.String name) 什么是域对象？域对象在不同的资源之间来共享数据。保存数据，获取数据。全局参数只能保存String类型数据，而域对象可以保存任何类型数据。域对象相当于一个容器，存储数据在不同的资源之间共享。 将数据封装到域对象中，在一个项目的不同资源中传递。利用set get remove attribute方法操作数据，其数据是唯一的。比起全局参数，其数据类型更广泛。 ServletContext就是我们学习的第一个域对象。 Servlet三个域对象： ServletContext HttpServletRequest HttpSession 请求转发的`RquestDispatcher getRequestDispatcher(java.lang.String path) ` 简化： `request.getRequestDispatcher(path);` 在servlet跳转页面： 请求重定向： 1）地址栏会发送改变，变成重定向到的地址。 2）可以跳转到项目内的资源，也可以跳转项目外的资源。（浏览器行为/代表从当前站点的根目录开始） 3）浏览器向服务器发出两次请求，那么就不能使用请求来作为域对象来共享数据。 请求转发： 1）地址栏不会改变。 2）只能跳转到项目内的资源，不能跳转到项目外的资源（服务器行为/代表从当前项目的根目标开始） 3）浏览器向服务器发出一次请求，那么可以使用请求作为域对象共享数据。 读取web项目的资源文件 123java.lang.String getRealPath(java.lang.String path) //获取资源文件的绝对路径java.io.InputStream getResourceAsStream(java.lang.String path) //获取资源，返回输入流java.net.URL getResource(java.lang.String path)//获取资源，返回URL对象 相对路径：当前路径相对于java命令运行的目录。123456789101112131415161718192021222324252627282930313233343536373839404142/** * 相对路径： * 当前路径相对于java命令运行的目录 * 结论： * 在web项目中，java命令运行的目录就是在tomcat的bin目录。在web项目，不能使用相对路径 */ /** FileInputStream in = new FileInputStream("./src/news.properties"); //1)使用Properteis对象 Properties prop = new Properties(); //2)使用load方法加载properties文件 prop.load(in); //3)通过getProperty（）获取内容 System.out.println(prop.getProperty("name")); System.out.println(prop.getProperty("password")); */ /** * 1)getRealPath() 获取资源文件的真实路径 */ /*String path = this.getServletContext().getRealPath("/WEB-INF/classes/news.properties"); System.out.println(path);*/ /** * 2)getResourceAsStream() 获取资源文件的输入流 */ InputStream in = this.getServletContext().getResourceAsStream("/WEB-INF/classes/news.properties"); /** * 3)getResource() 获取资源文件的URL */ //URL url = this.getServletContext().getResource("/WEB-INF/classes/news.properties"); //FileInputStream in = new FileInputStream(new File(path)); //1)使用Properteis对象 Properties prop = new Properties(); //2)使用load方法加载properties文件 prop.load(in); //3)通过getProperty（）获取内容 System.out.println(prop.getProperty("name")); System.out.println(prop.getProperty("password")); Servlet总结Servlet编程： 1）servlet编写 2）servlet的映射路径（精确匹配 模糊匹配 缺省路径？？？） 3）servlet的生命周期（构造方法，init方法，service方法，destroy方法） 4）多线程并发问题（单实例多线程，servlet使用成员变量，同步锁解决） 5）自动加载（load-on-startup） + 两个init方法的区别 6）ServletConfig对象：读取初始化参数 &lt;servlet&gt; &lt;init-param&gt; &lt;param-name&gt;&lt;/param-name&gt; &lt;param-value&gt;&lt;/param-value&gt; &lt;init-param&gt; &lt;servlet&gt; 7）ServetContext对象（重点） 5大作用： 1）读取web上下文路径（1） 2）读取全局参数（2） 3）作为域对象使用（3） 4）可以转发页面（1） 5）读取web资源文件（3） 会话管理会话管理技术Cookie技术：保存在浏览器端Session技术：保存在服务器端 Cookie技术Cookie技术的使用Cookie对象：import javax.servlet.http.Cookie; 1）创建Cookie对象，用于存储会话数据 new Cookie(java.lang.String name, java.lang.String value) 2）修改Cookie对象 void setPath(java.lang.String uri)//设置作用项目 void setMaxAge(int expiry) void setValue(java.lang.String newValue) 3）把cookie数据发送给浏览器保存 response.addCookie(cookie); 4）浏览器带着cookie访问服务器，服务器接收cookie信息 request.getCookies(); Cookie技术的原理1）服务器创建Cookie对象，保存会话数据，把Cookie数据发送给浏览器 response.addCookie(cookie); (响应头：set-cookie: name=jacky) 2)浏览器获取cookie数据，保存在浏览器缓存区，然后在下次访问服务器时携带cookie数据 (请求头： cookie: name=jacky) 3)服务器获取浏览器发送的cookie数据 request.getCookies(); Cookie细节1）cookie的数据类型一定是字符串，如果要发送中文，必须先对中文进行URL加密才可以发送。 2）setPath（path）： 修改cookie所在的有效路径。什么是有效路径？ 如果把该cookie设置到某个有效路径下，然后当浏览器访问这个有效路径的时候，才会携带cookie数据给服务器。 3） setMaxAge(整数) ： 设置cookie的有效时间 正整数： 表示超过了正整数的数值的时间，cookie就会丢失！！（cookie保存浏览器的缓存 目录）单位：秒 负整数： 表示如果浏览器关闭了，cookie就会丢失！（cookie保存浏览器内存） 0 ： 表示删除同名的cookie 4）cookie可以有多个，但是浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为4KB。 Session技术引入Cookie特点： 1）会话数据放在浏览器端 2）数据类型只能string，而且有大小限制的 3）相对数据存放不安全。 Session特点: 1）会话数据放在服务器端（服务器内存），占用服务器资源 2）数据类型任意类型，没有大小限制的。 3）相对安全 Session使用步骤HttpSession对象： 1）创建HttpSession对象，用于保存会话数据 session = request.getSession(); 创建或获取session对象 2）修改HttpSession对象 void setMaxInactiveInterval(int interval) 设置session对象的有效时间 void invalidate() 手动销毁session对象 3）保存会话数据(作为域对象) session.setAttribute(&quot;name&quot;,Object); 保存数据 session.getAttribute(&quot;name&quot;) 获取数据 session.removeAttribute(&quot;name&quot;) 删除数据 Session原理问题： 服务器怎么区分不同的浏览器会话？前提： 可以从session对象取出数据必须是存放数据的session对象！！！ 1）浏览器1-窗口1(001)： //1)创建HttpSession对象 HttpSession session = request.getSession(); 给session对象分配001 //2)保存会话数据 session.setAttribute(&quot;name&quot;, &quot;jacky&quot;); 2）浏览器1-窗口2(001)： //1)得到session对象 HttpSession session = request.getSession(); 搜索001的session对象 //2）获取会话数据 String name = (String)session.getAttribute(&quot;name&quot;); 可以得到！！ 3）浏览器2（没有标记或不是001） //1)得到session对象 HttpSession session = request.getSession(); //2）获取会话数据 String name = (String)session.getAttribute(&quot;name&quot;); 不可以得到！ 4）新的浏览器1（没有标记或不是001）关闭浏览器，JSESSIONID消失。 //1)得到session对象 HttpSession session = request.getSession(); //2）获取会话数据 String name = (String)session.getAttribute(&quot;name&quot;); 不可以得到！！ 1）服务器创建Session对象，服务器会给这个session对象分配一个唯一的标记JSESSIONID2）把JSESSIONID作为Cookie发送给浏览器（JSESSIONID的Cookie）3）浏览器得到JSESSIONID保存下来，在下次访问时携带这个JSESSIONID去访问服务器4）服务器得到JSESSIONID，在服务器内存中搜索是否存在指定JSSESSINOID的session对象，5）如果找到，则返回这个session对象6）如果找不到，可能直接返回null，或者再创建新的session对象。 HttpSession session = request.getSession(); 结论： 通过JSESSIONID在服务器中查询对应的session对象。 Session API123456789101112HttpSession接口 1）创建或得到Session对象 HttpSession getSession() HttpSession getSession(boolean create) 2）session对象操作会话数据（域对象） void setAttribute(java.lang.String name, java.lang.Object value) 保存数据 java.lang.Object getAttribute(java.lang.String name) 得到数据 void removeAttribute(java.lang.String name) 清除数据 3）设置session对象 Void setMaxInactiveInterval(int interval) 设置session有效时长，单位：s java.lang.String getId() 得到session对象编号 void invalidate() 销毁session对象 Session细节1234567891011121314151617181920212223241）setMaxInactiveInterval（秒数）: 设置session对象的有效时间 问题：session在什么销毁？ 注意：不是浏览器关闭，session对象就销毁！！！ 默认情况： 等待30分钟空闲时间，session对象才会销毁。&lt;!-- 设置全局的session对象的过期时间 （分钟）--&gt; &lt;session-config&gt; &lt;session-timeout&gt;1&lt;/session-timeout&gt; &lt;/session-config&gt; 2）可以让JSESSIONID不会随着浏览器关闭而丢失！！！！ /** * 设置JSESSIONID的时间，不会随着浏览器关闭而丢失！ */ Cookie c = new Cookie("JSESSIONID",session.getId()); c.setMaxAge(1*30*24*60*60);//1个月 response.addCookie(c);3）直接手动销毁sessino对象 invalidate（）； 4）创建或得到session对象 request.getSession() / request.getSession(true): 创建或得到session对象，查询session对象，如果没有session对象，则 创建新的session对象 request.getSession(false) 得到session对象。 查询session对象，如果session对象不存在，直接返回null]]></content>
      <categories>
        <category>学习笔记</category>
        <category>笔记整理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Session</tag>
        <tag>Cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记整理（7）]]></title>
    <url>%2F2019%2F02%2F14%2F%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%887%EF%BC%89%2F</url>
    <content type="text"><![CDATA[笔记整理（7）整理了从开始学习Java以来在纸质本上做的一些笔记，如有错误，恳请批评指正。 XMLHTML对比XML html不区分大小写，xml区分大小写 html标签固定，结构松散 html负责网页结构，xml更多的描述数据之间的关系 xml可作为配置文件和小型数据库。 xml文件需要使用xml解析器去解析，浏览器内置了xml解析器。 XML语法标签 标签要正确配对 标签名中间不能使用空格 标签名不能以数字开头 在一个xml文档中，有且仅有一个根标签。 属性属性名不能重复，属性值由单双引号引起，但不能混用。 注释1&lt;!-- 注释 --&gt; 文档声明1&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&gt; CDATA123&lt;![CDATA[ 原样输出字符]]&gt; XML解析DOM解析、SAX解析（原理不同）XML解析： DOM解析原理： JAXP JDOM Dom4j（三大框架中的运用的工具就是dom4j） SAX解析原理： Sax解析工具（oracle-sun公司官方） DOM解析什么是DOM解析？xml解析器一次性的把整个xml文档加载进内存，然后在内存中构建一颗Document的对象树，通过document对象，得到树上的节点对象，通过节点对象访问到xml文档中的内容。 Dom4j工具非官方，不在jdk中。 使用步骤： 1）导入dom4j的核心包。 dom4j-1.6.1.jar 2）编写Dom4j读取xml文件代码 12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) &#123; try &#123; //1.创建一个xml解析器对象 SAXReader reader = new SAXReader(); //2.读取xml文档，返回Document对象 Document doc = reader.read(new File("./src/contact.xml")); //节点 Iterator nodeIterator = doc.nodeIterator(); //标签 Element element = doc.getRootElement(); Element element2 = element.element("name"); Iterator elementIterator = element.elementIterator(); List elements = element.elements(); //属性 String attributeValue = element.attributeValue("attributeName"); Attribute attribute = element.attribute("name"); attribute.getName(); attribute.getValue(); Iterator attributeIterator = element.attributeIterator(); List attributes = element.attributes(); //文本 String text = element.getText(); String elementText = element.elementText("子标签的name"); &#125; catch (DocumentException e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; Domj4读取xml文件1234567891011121314151617181920//节点：Iterator Element.nodeIterator(); //获取当前标签节点下的所有子节点//标签：Element Document.getRootElement(); //获取xml文档的根标签 Element ELement.element("标签名") //指定名称的第一个子标签Iterator&lt;Element&gt; Element.elementIterator("标签名");// 指定名称的所有子标签List&lt;Element&gt; Element.elements(); //获取所有子标签 //属性：String Element.attributeValue("属性名") //获取指定名称的属性值Attribute Element.attribute("属性名")；//获取指定名称的属性对象 Attribute.getName() //获取属性名称 Attibute.getValue() //获取属性值List&lt;Attribute&gt; Element.attributes(); //获取所有属性对象Iterator&lt;Attribute&gt; Element.attibuteIterator(); //获取所有属性对象//文本：Element.getText(); //获取当前标签的文本Element.elementText("标签名") //获取当前标签的指定名称的子标签的文本内容 写出内容到XML文档12345678910111213141516171819public static void main(String[] args) throws DocumentException, IOException &#123; //创建紧凑的格式 OutputFormat compactFormat = OutputFormat.createCompactFormat(); //创建便于阅读的格式 OutputFormat prettyPrint = OutputFormat.createPrettyPrint(); OutputStream os = new FileOutputStream(new File("E:/a.xml")); //设置编码格式 compactFormat.setEncoding("UTF-8"); XMLWriter writer = new XMLWriter(os,prettyPrint); SAXReader saxReader = new SAXReader(); Document document = saxReader.read(new File("E:/hibernate.cfg.xml")); writer.write(document); writer.flush(); os.close(); &#125; 修改XML文档的API 1234567891011121314151617181920public static void main(String[] args) &#123; //自己创建一个文档对象 Document doc = DocumentHelper.createDocument(); //增加 Element element = doc.addElement("element"); Element element2 = element.addAttribute("name", "value"); //修改 Attribute attribute = element.attribute("name"); attribute.setValue("value"); Element addText = element.addText("text"); //删除 element.detach();//删除自己 attribute.detach();//删除属性 element.remove(attribute);//删除属性 element.remove(element.element("child"));//父标签删除子标签 &#125; xPATH技术问题：当使用dom4j查询比较深的层次结构的节点（标签，属性，文本），比较麻烦！！！xPath作用：主要是用于快速获取所需的节点对象。 在dom4j中如何使用xPath技术 导入xPath支持jar包 。 jaxen-1.1-beta-6.jar 使用xpath方法12List&lt;Node&gt; selectNodes(&quot;xpath表达式&quot;); 查询多个节点对象Node selectSingleNode(&quot;xpath表达式&quot;); 查询一个节点对象 XPATH语法http://www.w3school.com.cn/xpath/xpath_syntax.asp123456789/ 绝对路径 表示从xml的根位置开始或子元素（一个层次结构）// 相对路径 表示不分任何层次结构的选择元素。* 通配符 表示匹配所有元素[] 条件 表示选择什么条件下的元素@ 属性 表示选择属性节点 xpath = &quot;//contact[not(@id)]&quot;;//选择不包含id属性的contact标签节点xpath = &quot;//contact[@id=&apos;001&apos; and @name=&apos;eric&apos;]&quot;;//选择id属性值为001，且name属性为eric的contact标签and 关系 表示条件的与关系（等价于&amp;&amp;）text() 文本 表示选择文本内容 SAX解析SAX解析工具，sun公司提供，内置在jdk中，org.xml.sax.* 核心的API：SAXParser类： 用于读取和解析xml文件对象parse（File f, DefaultHandler dh）方法： 解析xml文件 参数一： File：表示 读取的xml文件。参数二： DefaultHandler： SAX事件处理程序。使用DefaultHandler的子类 1234//1.创建SAXParser对象 SAXParser parser = SAXParserFactory.newInstance().newSAXParser();//2.调用parse方法parser.parse(new File("./src/contact.xml"), new MyDefaultHandler()); DefaultHandler类的API:void startDocument() : 在读到文档开始时调用 void endDocument() ：在读到文档结束时调用 void startElement(String uri, String localName, String qName, Attributes attributes) ：读到开始标签时调用 void endElement(String uri, String localName, String qName) ：读到结束标签时调用 void characters(char[] ch, int start, int length) ： 读到文本内容时调用 SAX解析和DOM解析的对比DOM解析原理： 一次性加载xml文档，不适合大容量的文件读取DOM解析可以任意进行增删改成DOM解析任意读取任何位置的数据，甚至往回读DOM解析面向对象的编程方法（Node，Element，Attribute）,Java开发者编码比较简单。 SAX解析原理： 加载一点，读取一点，处理一点。适合大容量文件的读取SAX解析只能读取SAX解析只能从上往下，按顺序读取，不能往回读SAX解析基于事件的编程方法。java开发编码相对复杂。 Tomcat服务器web入门web服务软件 ， 也可以说成是web服务器 WebLogic： 是BEA公司的产品。支持JavaEE规范。收费的。 javaSE规范：支持 IO流，集合，网络编程，线程技术 javaEE规范： 支持13种技术。servlet、jsp、ejb、jdbc WebSphere： 是IBM公司的产品。支持JavaEE规范。收费的。解决方案 WebSphere -&gt; IBM操作系统（aix）- IBM服务器PC - IBM数据库（DB2） JBoss： 是Redhat公司的产品。支持JavaEE规范。linux。软件免费开源的。服务收费的。 Tomcat: 是 Apache开源组织的产品。支持servlet/jsp规范（不支持ejb）。开源免费的 tomcat用在中小应用。 web开发基础阶段重点使用tomcat服务器 Tomcat服务器目录结构123456789|-bin: 目录。存放tomcat操作命令。bat是window版本，sh是linux版本。 startup.bat ： 后台在调用catalina.bat start shutdown.bat : 后台在调用catalina.bat stop|-conf: 目录。存在tomcat服务器软件的配置文件。server.xml文件是核心配置文件。|-lib：目录。支撑tomcat软件运行的jar包。|-logs:目录。存在tomcat服务器运行过程中日志信息。|-temp: 目录。tomcat的临时目录，存在临时文件。|-webapps： 目录。存在web应用的目录|-work： 目录。tomcat运行目录。存放jsp页面运行过程中产生的临时文件。 web应用目录结构（规范）12345678910|- WebRoot： 根目录。一个web应用必须有一个根目录。 |- 静态资源： html+css+javascript+images+xml |-WEB-INF： 目录。名称是固定写法。 |-classes： (可选) 目录。名称是固定写法。存放class字节码 |-lib： （可选）目录。名称是固定写法。存放jar包。不能有子目录，全部jar包放在根目录下。 |-web.xml： 文件。web应用的配置文件。注意： 1）不做任何配置的情况下，WEB-INF目录下的文件不能直接通过浏览器访问。 2）在web.xml文件中进行配置，那么WEB-INF目录下的内容就可以被外部访问到！！！ web应用部署三种方法 直接把web应用拷贝到webapps目录下 在%tomcat%/conf/server.xml文件中修改： 123456789&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt; &lt;!--配置虚拟网站 docBase: web应用所在的绝对路径位置。 path: 访问web应用使用的名称。名称可以自定义 --&gt; &lt;Context docBase=&quot;C:\projects\myweb&quot; path=&quot;/ustb&quot;/&gt;&lt;/Host&gt; 添加配置文件方法配置虚拟网站（推荐使用） 在%tomcat%/conf/Catalina/localhost目录下，添加abc.xml文件 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!-- 配置虚拟网站 访问web应用名称就是xml的文件名abc--&gt;&lt;Context docBase=&quot;F:/a&quot;/&gt;访问url：http://localhost:8080/abc/+（F:/a目录下的文件名） ServletServlet技术：用java语言开发动态资源的技术。 Servlet技术特点： Servlet是普通的类，回程HttpServlet类，覆盖doGet方法。 Servlet程序必须由tomcat服务器运行。 开发servlet的步骤： 编写servlet程序，继承HttpServlet 把servlet交给tomcat服务器运行！！！ 把class字节码文件拷贝到web应用的WEB-INF/classes目录下 在web应用的web.xml文件配置servlet 浏览器访问servlet：http://localhost:8080/myweb/hello 1234567891011121314/** * 第一个servlet程序* */public class HelloServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //向浏览器输出内容 resp.getWriter().write("this is first servlet！！！"+new Date()); &#125; &#125; 123456789101112131415161718192021&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5"&gt; &lt;!--配置一个servlet --&gt; &lt;servlet&gt; &lt;!-- servet的内部名称。可以自定义--&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!--- servlet程序的全名：包名+简单类名 --&gt; &lt;servlet-class&gt;cn.ustb.b_servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- servlet的映射配置--&gt; &lt;servlet-mapping&gt; &lt;!--servet的内部名称，和上面内部名称保持一致！！！ --&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!-- servlet映射路径： 表示在浏览器上访问该servlet程序的名称。该名称可以自定义 --&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 使用IDE开发动态资源 创建一个web proejct 在WebRoot下编写静态资源文件（html+css+javascript） 在src目录下编写servlet动态资源使用servlet代码生成器： a）右键src- &gt; new -&gt; 点击”servlet“ b）servlet的包，类名，指定覆盖的方法（doGet） c）next-&gt; servlet内部名称（不用改）-&gt; url (访问servlet名称，可以改) -&gt; finished 点击finished之后，生成servlet的代码和web.xml的配置信息 关联tomcat服务器a）window-&gt; preferences- &gt; MyEcplise-&gt;servers-&gt; Tomcat6.X b）选择tomcat的根目录，然后enable。 部署项目 启动tomcat，访问测试 手动的步骤：12345678910111213141516171819202122232425261)编写一个普通的java类，继承HttpServlet类，覆盖doGet方法(注意： 到tomcat的lib目录下拷贝servlet-api.jar导入到你的项目中2)把servlet交给tomcat服务器运行！！！！！！2.1 把servlet对应的class文件拷贝到tomcat的某个项目（bbs）的WEB-INF/classes目录下2.2 在bbs项目的WEB-INF/web.xml文件配置servlet&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;version=&quot;2.5&quot;&gt;&lt;!--配置servlet --&gt;&lt;servlet&gt;&lt;!-- servlet名称，自定义--&gt;&lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;&lt;!-- servlet类的全名：包名+类名 --&gt;&lt;servlet-class&gt;gz.ustb.b_servlet.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;&lt;!-- servlet名称，和上面的名称保持一致 --&gt;&lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;&lt;!-- 公开给外部访问这个servlet的名称（路径） --&gt;&lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;/web-app&gt;3.通过URl访问这个servlethttp://localhost:8080/bbs/hello 工具步骤123456789101112131415161)创建一个bbs的web project2)在WebRoot下编写静态网页3)在src下编写动态网页 3.1 在src右键选择 “servlet” 3.2 写上servlet的包，名，选择覆盖doGet方法 -&gt; next 3.3 修改servlet的名称，修改访问servlet的url -&gt; finished 4)myecplise关联tomcat服务器 4.1 window-&gt; preferences -&gt; 搜索“tomcat” -&gt; 找到“tomcat6.x” 4.2 选择 tomcat的根目录 4.3 把disable -&gt; enable5)部署网站 5.1 点击发布图标 -&gt; 选择网站- &gt; 选择发布的tomcat服务器-&gt; ok6)访问： 静态文件： http://localhost:8080/bbs/index.html 动态文件： http://localhost:8080/bbs/hello HTTP协议http协议：对浏览器客户端 和 服务器端数据传输格式的规范。 Http协议内容详情12345678910111213141516浏览器-&gt;服务器（请求）GET /day09/first HTTP/1.1 Host: localhost:8080User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:34.0) Gecko/20100101 Firefox/34.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-cn,en-us;q=0.8,zh;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateConnection: keep-alive服务器-&gt;浏览器（响应）HTTP/1.1 200 OKServer: Apache-Coyote/1.1Content-Length: 51Date: Sun, 28 Dec 2014 01:51:16 GMTthis is first servlet!!Sun Dec 28 09:51:16 CST 2014 请求头123456789GET /day09/first HTTP/1.1 --请求行（必须有）Host: localhost:8080 --多个请求头（必须有）User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:34.0) Gecko/20100101 Firefox/34.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-cn,en-us;q=0.8,zh;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateConnection: keep-alive --一个空行name=eric&amp;password=123456 --请求实体内容（可选） 常见的请求头1234567891011Accept: text/html,image/* --浏览器接收的数据类型Accept-Charset: ISO-8859-1 --浏览器接收的编码格式Accept-Encoding: gzip,compress --浏览器接收的数据压缩格式Accept-Language: en-us,zh- --浏览器接收的语言Host: www.it315.org:80 --当前请求访问的主机和端口（可以是网址也可以是ip地址）If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT --浏览器最后更新的缓存时间Referer: http://www.it315.org/index.jsp --当前请求来自于哪里（从超链接过来的请求包含此头）（直接访问的此项为null）User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0) ---浏览器类型Cookie: name=eric ---浏览器保存的cookie信息Connection: close/Keep-Alive --浏览器和服务器连接状态。close：关闭连接。keep-alive:保持连接。Date: Tue, 11 Jul 2000 18:23:51 GMT --请求发出时间 HttpServletRequeset对象1）tomcat服务器把http请求信息封装到HttpServletRequest对象中。2）开发者通过HttpServletRequest对象得到http请求信息。 12345678910请求行： request.getMethod()； 请求方式 request.getRequestURI() 请求资源 request.getRequestURL() request.getProtocol() 协议版本（protocol：n.协议，草案；v.拟定）请求头： request.getHeader(&quot;name&quot;): 根据请求头获取请求值 request.getHeaderNames(): 获取所有请求头名称实体内容： request.getInputStream(); 请求参数的获取Get方式的参数跟在URI的后面（？开始 getQueryString()获取）Post方式的参数放在实体内容中123456789//获取参数方式： GET：request.getQueryString(); POST：request.getInputStream();//通用获取参数方式：（不分Post和Get） request.getParameter(name) ; 根据参数名获取参数值（获取一个参数值） request.getParameterValues(name); 根据参数名获取参数值(获取多个参数值) request.getParameterNames(); 获取所有参数名称 request.getParameterMap(); 获取所有参数 请求参数中问乱码问题 POST方式： request.setCharacetEncoding(“utf-8”) GET方式: 重新解码（推荐使用） 1234if(&quot;GET&quot;.equals(request.getMethod()))&#123; //重新解码 hobit = new String(parameter&apos;s value.getBytes(&quot;iso-8859-1&quot;),&quot;utf-8&quot;); &#125; 修改tomcat的server.xml文件 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;utf-8&quot;/&gt; 12345678/*** 设置参数解码时查询的码表* 注意：* 只对post提交的参数有效，对get提交的参数无效的！* 因为这个方法只能设置对请求实体内容的解码时查询的码表。post提交的参数时放在实体内容中，所以对post是有效的！* 但是get提交参数时放在URI后面的，这个方法无法影响URI后面的内容。*/ request.setCharacterEncoding(&quot;utf-8&quot;); 设置编码request.setCharacterEncoding()设置从request中取得的值或从数据库中取出的值response.setContentType(&quot;text/html;charset=utf-8&quot;)是设置页面中为中文编码前者是设置动态文字（参数，数据库），后者设置页面静态文字 response.setContentType指定 HTTP 响应的编码,同时指定了浏览器显示的编码.response.setCharacterEncoding设置HTTP 响应的编码,如果之前使用response.setContentType设置了编码格式,则使用response.setCharacterEncoding指定的编码格式覆盖之前的设置.与response.setContentType相同的是,调用此方法,必须在getWriter执行之前或者response被提交之前。 ####响应头 123456HTTP/1.1 200 OK --响应行Server: Apache-Coyote/1.1 --多个响应头Content-Length: 51Date: Sun, 28 Dec 2014 01:51:16 GMT --一个空行this is first servlet!!Sun Dec 28 09:51:16 CST 2014 --实体内容（用户直接看到的内容） 响应行HTTP/1.1 200 OK HTTP：协议版本 状态码： 200：ok 302：表示请求需要进一步细化，通常该状态码和location响应头结合使用。 404：客户端错误，找不到资源 500：服务器错误。 多个响应头12345678910111213141516Location: http://www.it315.org/index.jsp --重定向地址。通常和302状态码配合使用，完成请求重定向效果Server:apache tomcat --服务器类型Content-Encoding: gzip --服务器发送给浏览器的数据压缩格式Content-Length: 80 --服务器发送给浏览器数据长度Content-Language: zh-cn --服务器发送给浏览器数据语言Content-Type: text/html; charset=GB2312 --服务器发送给浏览器数据类型Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT --服务器资源最后修改时间Refresh: 1;url=http://www.it315.org --定时刷新或每隔n秒跳转页面Content-Disposition（内容的处置方式）: attachment; filename=aaa.zip --告诉浏览器以下载方式打开资源Transfer-Encoding: chunkedSet-Cookie:SS=Q0=5Lb_nQ; path=/search --服务器发送给浏览器的cookie信息 Expires: -1 --建议浏览器不使用缓存Cache-Control: no-cachePragma: no-cacheConnection: close/Keep-Alive --服务器和浏览器连接状态。close：关闭连接。keep-alive:保持连接。Date: Tue, 11 Jul 2000 18:23:51 GMT --响应发送的时间 HttpServletResponse对象HttpServletResponse对象用于设置响应信息。 12345678910常用方法： 响应行： response.setStatus(); 设置状态码 响应头： response.setHeader(name,value); 设置响应头 实体内容 response.getWriter().writer(); 以字符格式发送实体内容 response.getOutputStream().writer(); 以字节格式发送实体内容]]></content>
      <categories>
        <category>学习笔记</category>
        <category>笔记整理</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>XML</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记整理（6）]]></title>
    <url>%2F2019%2F02%2F14%2F%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%886%EF%BC%89%2F</url>
    <content type="text"><![CDATA[笔记整理（6）整理了从开始学习Java以来在纸质本上做的一些笔记，如有错误，恳请批评指正。 HTMLHTML常用标签：&lt;h1&gt;~&lt;h6&gt;：表示一个标题 &lt;p&gt;：段落标签&lt;pre&gt;：原样标签，保留空格或换行符 &lt;span&gt;：行内标签，便于样式格式化 &lt;hr/&gt;：水平线标签&lt;br/&gt;：换行标签&lt;sub&gt;：下标&lt;sup&gt;：上标 &lt;ol&gt;&lt;li&gt;：有序列表标签有序列表标签 &lt;ul&gt;&lt;li&gt;：无序列表标签无序列表标签 &lt;dt&gt;&lt;dt&gt;：项目列表标签项目列表标签项目列表标签 &lt;dd&gt;：列表标签，缩进几行 &lt;div&gt;：块标签，内容会独占一行块标签，内容会独占一行 实体字符空格：&nbsp;&nbsp;&amp;nbsp;小于号：&lt;&amp;lt;大于号：&gt;&amp;gt;和：&amp;&amp;amp;引号：&quot;&amp;quot;撇号：&apos;&amp;apos;人民币：&yen;&amp;yen;版权：&copy;&amp;copy;商标：&reg;&amp;reg; 媒体标签&lt;embed src=&quot;&quot;&gt;&lt;/embed&gt;属性：hidden：是否隐藏 src：指定音乐路径 超链接标签&lt;a&gt;&lt;/a&gt;常见属性：href:用来指定链接的资源。target：设置打开新资源的目标窗口 –Blank：新窗口 –Self：原窗口href中默认file协议，此协议搜索本地机器的资源文件。格式：file:\\\f:\... 飘动标签&lt;marquee&gt;&lt;/marquee&gt;属性：direction：方向，scrollamount：速度，loop：次数。test… a标签的原理 若href以http开头，则会启动http解释器解释该网址，首先在本地机器去找一个hosts文件，若hosts上无相应的主机，则会去对应的DNS服务器寻找该域名对应的主机号进行访问。 若无http开头，默认file协议。 若以其他开头，则会在本机上寻找是否有处理这种协议的应用程序并启动。例如：邮件的协议：mailTo 迅雷：thunder:// 超链接标签的作用 可以用于链接资源 锚点定位 首先编写一个锚点，锚点的格式：&lt;a name=&quot;name&quot;&gt;数据&lt;/a&gt; 使用a标签的href属性链接到锚点处。href=“#锚点名字”top 图片标签&lt;img/&gt;没有结束标签。常用属性： src：规定显示图像的URL alt：规定图像的替换文件 width： height： 表格标签 标题 标题 标题 单元格 单元格 单元格 123456789101112&lt;table&gt; &lt;tr&gt; &lt;th&gt;标题&lt;/th&gt; &lt;th&gt;标题&lt;/th&gt; &lt;th&gt;标题&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 常见属性： border：边框 width height colspan：所占列数 rowspan：所占行数 框架标签http://www.w3school.com.cn/tags/tag_frameset.asp 表单标签用于提交数据给服务器 USER PWD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12345678910111213&lt;table border=&quot;2&quot;&gt;&lt;form action=&quot;用于提交数据的地址&quot; method=&quot;post/get&quot; enctype=&quot;&quot; name=&quot;form1&quot;&gt; &lt;tr&gt; &lt;td&gt;USER&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;userName&quot;/&gt;&lt;/td&gt;&lt;br/&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;PWD&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;/td&gt;&lt;br/&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;Login&quot;/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;input type=&quot;reset&quot; value=&quot;reset&quot;/&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/form&gt;&lt;/table&gt; 注意：表单项的数据若需要提交到服务器上，表单项必须要有name属性。 常见的表单域 文本：text 密码：password 单选按钮：radio，单选按钮必须分组，同名即同组 多选按钮：checkbox，多选必须同名 文件选择框：type=”file” 下拉列表： 文本输入区域：textarea 按钮：button Volvo Saab Opel Audi 123456&lt;select&gt; &lt;option value =&quot;volvo&quot;&gt;Volvo&lt;/option&gt; &lt;option value =&quot;saab&quot;&gt;Saab&lt;/option&gt; &lt;option value=&quot;opel&quot;&gt;Opel&lt;/option&gt; &lt;option value=&quot;audi&quot;&gt;Audi&lt;/option&gt;&lt;/select&gt; CSSCascading Style Sheets 层叠样式表html:负责页面的结构css：负责数据的样式 编写css代码的方式： 方式一：在style标签中编写css代码，只能用于本页面中，复用性不强。 123456789101112131415&lt;!--&lt;html&gt;&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;h1 &#123;color:red&#125;p &#123;color:blue&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Header 1&lt;/h1&gt;&lt;p&gt;A paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;--&gt; 方式二：引入外部的css文件（推荐） 使用link标签12&lt;link href=&quot;css文件的路径&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;rel:定义文档与被链接的文档之间的关系 使用&lt;style&gt;引入123&lt;style type=&quot;text/css&quot;&gt; @import url(&quot;css的路径&quot;);&lt;/style&gt; 方式三：直接html标签中使用style属性编写，只能用于本标签，复用性差，但是很方便。 1&lt;a style=&quot;color:red;text-decoration:none&quot; href=&quot;#&quot;&gt;test link&lt;/a&gt; test link 选择器选择器的作用是找到合适的标签进行样式化 标签选择器 1234&lt;!--div&#123;color:#000;&#125;a&#123;font-size:24px;&#125;--&gt; 类选择器首先要给html标签指定对应的class属性值注意：1、class属性值不能以数字开头。2、类选择器优先于标签选择器。 12345&lt;!--.classname&#123;&#125;.twoclassname&#123;&#125;&lt;a class=&quot;classname&quot;&gt;&lt;/a&gt;--&gt; ID选择器：使用ID选择器首先要给html标签添加一个ID属性值。1、优先级最高。2、属性值不能以数字开头。3、属性值唯一 1234&lt;!--#id&#123;style1；style2；&#125;&lt;a id=&quot;id&quot;&gt;&lt;/a&gt;--&gt; 交集选择器：即对选择器1中的选择器2里的数据进行样式化 12345&lt;!--.two span&#123;color:#000;&#125;&lt;span class=&quot;one&quot;&gt;&lt;/span&gt;&lt;span class=&quot;two&quot;&gt;&lt;/span&gt;--&gt; 并集选择器 123&lt;!--span,a&#123;color:#000;&#125;--&gt; 通用选择器 123&lt;!--*&#123;color:#000;&#125;--&gt; 伪类选择器对元素处于某种状态下进行样式的修改。 1234锚伪类：a:link&#123;color:#FFFFF;&#125; 未访问的链接 a:visited&#123;&#125; 访问后 a:hover&#123;&#125; 移动到 a:active&#123;&#125; 选定 注意：伪类选择器与类选择器也可配合使用 1a.class:visited&#123;&#125; 常见的CSS样式操作背景的样式： background-color：#FFF； background-image：url（“1.jpg”）； background-repeat：no-repeat； background-position：300px 200px；（左上角点的位置） 操作文本的样式： color： text-align： font-size： text-decoration：none；（修饰） line-height： text-transform：uppercase； letter-spacing：字间距 操作表格的样式： border-collapse：collapse；合并边框 border-spacing：20px；设置单元格边框与表格边框的距离 table-layout：fix；表格布局：固定值、自动值 empty-cells：是否显示空单元格 操作边框的样式：http://www.w3school.com.cn/cssref/pr_border-style.asp div默认无、border-style:solid width height border-style aaa 1&lt;div style=&quot;border-style:solid;border-bottom-color:red;border-top-width:1px&quot;&gt;aaa&lt;/div&gt; 盒子模型把html的边框比作成一个盒子的边框，用于操作数据与边框之间的距离或者边框与边框之间的距离。内边距：padding、外边距：margintop、left、bottom、right ie:{padding-left} aaa1&lt;div style=&quot;padding-left:100px;margin-top:20px;&quot;&gt;aaa&lt;/div&gt; CSS的定位相对定位：相对于元素之前的位置 position：relative； top：20px； left：20px； 绝对定位：绝对定位相对于整个页面而言 position：absolute top：300px left：300px 固定定位：相对于整个浏览器 position：fixed top：300px； left：300px； 123&lt;!--&lt;a style=&quot;position:relative;top:20px;left:30px&quot;&gt;aaa&lt;/a&gt;--&gt; JavaScript负责与用户进行交互，具有以下特点：1、跨平台2、安全性，不能直接访问硬盘3、解释性语言，无需编译。弱类型语言，无需确定类型 编写方式一：内部编写 123456&lt;!--&lt;script type=&quot;text/javascript&quot;&gt; code;&lt;/script&gt;--&gt; 方式二：引入外部js文件 123&lt;!--&lt;script src=&quot;1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;--&gt; 注意：1、&lt;script&gt;有开始标签和结束标签。2、若一个标签已经引入了js文件，该标签不能再写js代码。 常用函数 alert(“显示的内容”)：弹出框 document.write(“数据”)：向页面输出数据 变量声明1var name = value; 注意：1、var声明后，可储存任意类型的数据。2、变量类型由存储的值决定，可以随时改变。3、同名变量会覆盖。4、var可省略，但不建议。 typeof name：查看变量的类型。 javascript的数据类型 number：小数或者整数 string：字符串，js没有字符的概念，只有字符串，可以在单引号中。 boolean：布尔型 undefined：代表该变量未定义 字符串转数字 parseInt() 若接受的字符串含有非数字字符，则从首字符查找，直到非数字字符停止。若首字符就是非数字，返回NaN。 首位是0，则去0。 0x开头，则16进制转10进制。 parseFloat()：若一字符串是整数，转换后仍是整数。 isNaN()：判断是否是非数字。isNaN(“123”) return false; 运算符 +（加法，正数，连接符）： true:1,false:0 -（除法）：不能整除结果为小数 比较运算符：字符串会自动转为数字与数字进行比较。 逻辑运算符：&amp;&amp;、|| 三目运算符：boolean? value1:value2；字符串之间的比较规则： 能找到对应位置不同的字符，比较不同字符的先后或大小。 不能找到对应位置，则比较字符串长度。如：bcd&gt;bc，bcd&gt;acde 控制流程语句 if语句：和Java中一样，特殊之处：条件中可接受任何类型 number：非0为true，0为false。 string；非空为true，空位false。 undefined：false。 NaN：false。 switch语句：特殊之处：case后可跟常量异或变量或表达式。 for-in语句：123for(var items in target)&#123; code; &#125; 作用：1. 用于遍历数组的元素，注意：数组遍历的是下标。2、用于遍历对象的所有属性数据。注意：对象遍历的是属性名。 with语句：用with语句，在调用对象或者调用方法时可以不用重复指定对象。 123with(对象)&#123; code;&#125; 函数定义格式： 123function 函数名(形参列表)&#123; function code; &#125; 注意的细节： 形参列表的形参不需要用var定义，否则会报错。 没有返回值类型，返回根据需要直接return即可。 没有函数重载的概念，后定义的函数直接覆盖前者。 函数内部都隐式的维护了一个arguments（数组） 对象，给函数传递数据时，先传递至arguments对象中，再由其分配数据给形参。 字符串string创建方式：方式一：var char = new String(&quot;内容&quot;);方式二：var str = &quot;内容&quot;; 所有字符串文字共享公用的全局字符串对象，若为字符串对象添加属性，则其它对象也具备该属性。而用new String定义的有自己的属性组，并不共享。 常用方法： anchor():生产锚点，在对象的指定文本两端放置一个NAME属性的HTML锚点。 blink():为元素添加blink标签。 charAt():返回指定索引处的字符。 charCodeAt():指定索引处的字符Unicode编码。 fontcolor():把带有color属性的HTML&lt;font&gt;标签放置string对象的文本两端。 indexOf():lastIndexOf():首次，最后一次出现指定字符的索引位置。 italics():把HTML&lt;I&gt;标记放置在stirng对象的两端。 link():把带有HRef属性的HTML锚点放置在String对象的两端。 replace(rgExp,replaceText):返回根据正则表达式进行文字替换后的字符串的复制。 split():切割。 substr():子串。 toUpperCase():转大写。 toLowerCase():转小写。 日期对象Date var date = new Date(); toLocalString(): getFullYear(): getMonth(); getDate(): getHours(): getMinutes(): getSeconds(): 定时方法：window.setInternal(&quot;function name&quot;,milliseconds); 数字对象Number var num = 5; var num = new Number(number);常用方法： toString():把数字转为指定进制形式的字符串。 toFixed():指定保留小数位，自带四舍五入功能。 数学对象Math ceil() 调用方法Math.ceil() 向上取整 floor() 向下取整 random() 0~1的伪随机数 round() 四舍五入 Array数组对象 方式一：var name = new Array(); 方式二：var name = new Array(length); 方式三：var name = new Array(“ele1”,”ele2”…”eleN”); 方式四：var name = [“ele1”,”ele2”…”eleN”]; 常用方法： concat():a.concat(b,c)返回a,b,c数组 join():使用指定的字符串（分隔符）将数组拼装成一个字符串返回。 pop():移除最后一个元素并返回。 push():添加一新元素，并返回新长度值。若参数之一为数组，将作为单个元素添加，若要合并多个，用concat()方法。 shift():移除第一个元素并返回。 unshift():插入指定元素至开始位置。 reverse():返回倒序后的数组。 slice():返回数组的一段，指定开始和结束点（包头不包尾） sort():sort(sortFunction()) 排序，参数可选。若省略将按元素ASCII的升序排列。定义方法时需要返回：负：参数1&lt;参数2；0：相等；正：参数1&gt;参数2 splice():从一个数组中移除1个或者多个元素，如果必要，插入新的元素，返回移除的元素。 JS中自定义对象在JavaScript中没有类的概念，只要有函数即可创建对象。 方式一：使用无参的函数创建对象。 123function Person()&#123;&#125;var p = new Person();p.id = 100;p.name = "jason"; 方式二：使用带参的函数创建对象 1234567function Person(id,name)&#123; this.id = id; this.name = name; this.say = function()&#123; alert("say something"); &#125;&#125; 方式三：使用Object创建对象 12var p = new Object();p.id = 110;p.name = "jason"; 方式四：使用字面量的方式创建 1234var p = &#123;id:110,name:"jason",say:function()&#123; alert("say something"); &#125; &#125;; BOM编程（Browser Object Model）浏览器对象模型把浏览器中的各个部分都用了一个对象进行描述，若要操作浏览器的一些属性，就可通过浏览器对象模型的对象进行操作。 window：代表一个新开的窗口 location：代表了地址栏对象 screen：代表了整个屏幕对象 window对象常用的方法 open()：打开一个新的窗口（URL，Name，features，replace）1：地址、2：名、3：特征、4：是否取代，即多次点击，多次弹出。 resizeTo()：将窗口的大小更改为制定宽高。 moveBy()：相对于原窗口移动指定的xy值 moveTo()：移动到xy点，相对于屏幕 setInterval()：设置执行间隔 clearInterval()：根据一个任务的ID取消定时任务。 setTimeOut()：指定毫秒数后执行指定代码一次注：使用window对象的任何属性和方法都可以省略window对象不写。 事件 方式一：直接在html元素上注册 1234&lt;body onload = "ready()"&gt;function ready()&#123; ready code;&#125; 方式二：可在JS代码中先找到对应的对象再注册（推荐，因为JS与HTML分开便于后期维护） 1234var bodenode = document.getElementById("body");bodyNode.onload = function()&#123; alert("body的元素加载完毕");&#125; 常用的事件 onclick ondblclick：双击 onmousedown：选取 onmouseup：释放 onmouseout：移出 onmousemove：划过 onblur：失去输入焦点 onfocus：获取输入焦点 onchange：内容发生改变时 onload：浏览器加载完毕后触发 onsubmit：表单提交时出发 location对象 href：设置或获取URL字符串 reload：重新载入页面 screen对象 availHeight：系统屏幕的工作区域高度，排除任务栏 availWidth：系统屏幕的工作区域宽度，排除任务栏 height：垂直分辨率 width：获取屏幕的水平分辨率 DOM编程（Document Object Model）文档对象模型，当一个html页面被浏览器加载时，浏览器就会对整个html页面上的所有标签创建一个对应的对象进行描述，浏览器上显示的信息即对象的属性信息，找到对应的对象操作对应的属性，则可改变显示的内容。 通过html元素的标签属性找节点 document.getElementById(“id”)：获取id节点 document.getElementsByTagName(“name”)：获取name的标签集 document.getElementsByName：获取name的元素集 通过关系（父子关系、兄弟关系）找标签 parentNode：获取当前元素的父节点 childNodes：获取当前元素的所有下一级子元素 firstChild：获取当前节点的第一个子节点 lastChild：获取当前节点的最后一个子节点 nextSibling：获取当前节点的下一节点 previousSibling：当前节点的上一个子节点 创建节点、插入节点、设置节点的属性 document.createElement(“标签名”)：创建新元素节点 element.setAttribute(“name”，”value”)：设置属性 element.appendchild(e)：添加元素到element中的最后的位置 插入目标元素的位置： element.insertBefore(newNode,oldNode) 添加元素到指定位置注：element必须是oldNode的直接父节点。 element.emoveChild(child) 删除指定的子节点注：element也必须是child的直接父节点。 正则表达式的创建方式方式1：/正则表达式/模式；方式2：new RegExp(“正则”,”模式”);常用的方法： test()：使用正则表达式去匹配字符串，匹配成功返回true，否则返回false。 exec()：根据正则表达式去查找字符串符合规则的内容。 模式： g：全文查找出现的所有的pattern i：忽略大小写 m：多行查找 浏览器提交数据给服务器默认的编码格式是iso-8859-1，而contentType(“text/html;charset=UTF-8”)确定的是浏览器的解析码表和服务器的编码码表。 HTML教程：http://www.w3school.com.cn/html/index.asp]]></content>
      <categories>
        <category>学习笔记</category>
        <category>笔记整理</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记整理（5）]]></title>
    <url>%2F2019%2F02%2F14%2F%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%885%EF%BC%89%2F</url>
    <content type="text"><![CDATA[笔记整理（5）整理了从开始学习Java以来在纸质本上做的一些笔记，如有错误，恳请批评指正。 警告–不要编写返回引用可变对象的get方法核心技术卷一P113：不要编写返回引用可变对象的get方法，这样坐会破坏封装性！！！如果需要返回一个可变对象的引用，应首先对它进行克隆，对象克隆指存放在另一内存位置上的对象副本。 1234567891011121314151617181920public class Demo2 &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Comp c = new Comp(); c.setEmp(new Emp("origin",110)); Emp emp = c.getEmp(); emp.setName("changed"); System.out.println(c.getEmp().getName());//origin or changed??? 答案是 changed。问题就出在Comp中的getEmp方法,直接返回了 //引用成员变量的引用，修改会受到牵连。 /* * the correct way is to return emp'cloned Object.at this time, * Emp need to implement Cloneable interface and change the Modifier * of method clone to Public. */ Comp2 c2 = new Comp2(); c2.setEmp(new Emp("origin",110)); Emp emp2 = c2.getEmp(); emp2.setName("changed"); System.out.println(c2.getEmp().getName());//origin or changed???it's origin &#125;&#125; 值传递和引用调用的最后一点小问题牢记一点，Java中采用的是值传递。而在方法参数的调用上面，有以下几种情况需要特别的注意： 一个方法不能修改一个基本数据类型的参数（即数值型和布尔型） 一个方法可以改变一个引用对象的状态（即修改它的域变量） 但是一个方法不能改变一个引用对象的指向，即不能让对象参数指向一个新的对象。 12345678910111213141516171819202122/** * 为了说明Java的参数传递中，可以修改引用对象的状态，但是不可以修改指向。 * @author Wch * */public class Demo1 &#123; public static void main(String[] args) &#123; Emp emp = new Emp("原来的对象1", 110); changeEmp(emp); System.out.println(emp.getName());//输出 原来的对象1 Emp emp2 = new Emp("原来的对象2", 110); changeEmpState(emp2); System.out.println(emp2.getName());//输出 改了新名字 &#125; public static void changeEmp(Emp emp)&#123; emp = new Emp("指向了新对象",250); &#125; public static void changeEmpState(Emp emp)&#123; emp.setName("改了新名字"); &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>笔记整理</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记整理（4）]]></title>
    <url>%2F2019%2F02%2F14%2F%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%884%EF%BC%89%2F</url>
    <content type="text"><![CDATA[笔记整理（4）整理了从开始学习Java以来在纸质本上做的一些笔记，如有错误，恳请批评指正。 Java中的同步机制 同步代码块123synchronized(锁对象)&#123; 需被同步的代码； &#125; 需注意的细节： 锁对象可以是任意的对象。 锁对象必须是多线程共享的资源，否则锁不住。 没有线程安全问题的时候不要使用锁，否则会导致效率低下。 调用sleep方法并不会释放锁对象，但是会调用wait方法。 同步函数123修饰符+synchronized+返回值类型+函数名()&#123; ...;&#125; 需注意的细节： 同步函数的锁对象是不能任意的，非静态同步函数的锁对象是this对象，静态函数的锁对象是当前字节码对象。 同步函数的锁对象不能人为指定，而应该是固定的。 单例设计模式的线程安全问题解决办法12345678910111213public class Singleton &#123; private static Singleton instance; private Singleton()&#123;&#125;; public static Singleton getInstance()&#123; if(instance == null)&#123; synchronized(Singleton.class)&#123;//枷锁，细粒度的对new语句进行同步 instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 深克隆即利用对象的输入输出流对象先把对象写到文件上，然后再读取对象的信息到克隆的对象上。ObjectInputStreamObjectOutputStream 内存泄漏不再使用的对象，应不要在让变量指向，让其成为垃圾对象，好让垃圾回收器回收。例：在堆栈存储时，弹栈时因清空数据，使变量不再指向对象。 反射当一个字节码文件加载到内存的时候，JVM会对该字节码（class）进行解剖，然后创建一个Class类的对象，把字节码文件的信息全部储存到该Class对象中，只需获得该Class对象就可以使用字节码对象设置对象的属性或调用对象的方法等操作。 BeanUtils类Apache开发的一套简单的易用的API操作Bean的属性。可以将对象的属性数据封装到对象中。优点： BeanUtils设置属性时，若属性时基本数据类型，BeanUtils会自动数据类型转换。 底层也依赖于get、set方法，若无则无法设置该属性。 若属性是其他的引用类型，这是需注册一个类型转换器。Converter 导包：commons-logging.jar commons-beanutils-1.8.0.jarBeanUtils类方法：setProperty（对象，“属性名”，“值”）注册转换器：ConvertUtils.register(new DateConverter(),Date.class) \ConvertUtils.register(new BooleanConverter(),Boolean.class)或者匿名内部类重写converter方法自定义转换规则。 补码、原码 对负数而言、原码–&gt;补码、补码–&gt;原码：除符号位外，求反再加1，正数则不变。 n位补码能表示的范围：-2^(n-1)~2^(n-1)-1 ———8位的范围为：-128~127 n位原码表示的方位：-(2^(n-1)-1)~2^(n-1)-1 ———8位的范围为：-127~127 原码中00000000和10000000都是表示0 补码中10000000当做-2^7即真值为-128，-128没有原码，不能用求反加1。 运算符逻辑运算符： ^ 异或，不同则为True 位运算符： &amp; 与 | 或 ^ 异或 ~ 取反 移位运算符： &lt;&lt; 左移 相当于乘2^位数 &gt;&gt; 右移 若是负数，高位补1，正数乘，负数除 &gt;&gt;&gt; 无符号右移，无正负之分，全补0 取反运算过程： 12345678public class Demo1 &#123; public static void main(String[] args) &#123; int a = 4; System.out.println(~a);//-5 int c = -5; System.out.println(~c);//4 &#125;&#125; 4为例： int为4字节32位，在此省略前24位。 原码：00000100 补码：00000100 求反：11111011 原码：10000101 值为-5 -5为例： 原码：10000101 补码：11111011 求反：00000100 原码：00000100 值为4 switch支持String了之前，switch支持的类型只有byte、short、char、int、integer、enum枚举类型，在JDK7后，支持string类型。 12345678910111213String str = "xyz"; switch(str)&#123; case "abc": System.out.println("abc"); return; case "cbd": System.out.println("cbd"); case "xyz": System.out.println("xyz"); default: System.out.println("default"); &#125;//匹配上了，遇到return或者break则会停止，否则一直往下执行 Final关键字 final修饰一个引用类型变量时，该变量不能重新指向新的变量。 final修饰一个函数时，该函数不能被重写。 final修饰一个类时，不能被继承。 多态的细节 多态下，若子父类存在同名的成员时，除了非静态函数访问子类时，其余成员全部访问父类的成员。 多态下，不能访问父类特有的成员。 若需访问子类特有的成员，需强制类型装换。 实现关系下的多态，永远调用的是实现类中的方法，因为接口中的方法都是非静态的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Demo2 &#123; public static void main(String[] args) &#123; Father f = new Son(); f.action();//多态下，非静态方法调用子类 f.eat();//静态方法调用父类 &#125; static class Father&#123; String name; static int id; public String getName() &#123; return name; &#125; public static int getId() &#123; return id; &#125; public Father(String name) &#123; super(); this.name = name; &#125; public Father() &#123; super(); &#125; public void action()&#123; System.out.println("father's action"); &#125; public static void eat()&#123; System.out.println("father eat"); &#125; &#125; static class Son extends Father&#123; String name; static int id; public String getName() &#123; return name; &#125; public static int getId() &#123; return id; &#125; public Son(String name, String name2) &#123; super(name); name = name2; &#125; public Son() &#123; super(); &#125; public void action()&#123; System.out.println("son's action"); &#125; public static void eat()&#123; System.out.println("son eat"); &#125; &#125;&#125; 观察者设计模式观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 当一个对象发生指定的动作时，要通知另一个对象做出该对象相对应的动作。步骤： 当前对象发生指定动作时，通知另一对象做出相应的处理，这时就把对方的相应处理方法定义在接口上。 当前对象维护接口的引用，当当前对象发生指定动作时就可以调用接口中的方法，方法中具体的执行条例由接口的实现类对象解决，当前对象中只保持了接口的引用，要想获得当前对象的动作信息就可实现该接口。即，实现了接口就相当于订阅了当前对象的通知。 例程：运钞车充当被观察者，警察劫匪充当观察者。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146/** * 观察者接口 * @author Wch * */public interface Watcher &#123; public void update(Information inf);&#125;/** * 被观察者接口 * @author Wch * */public interface Watched &#123; public void addWatcher(Watcher watcher); public void removeWatcher(Watcher watcher); public void notifyWatchers();&#125;/** * 发布的信息类 * @author Wch * */public class Information &#123; private int personNum;//押运人员数 private String address;//地点 private String carColor;//运钞车颜色 public int getPersonNum() &#123; return personNum; &#125; public String getAddress() &#123; return address; &#125; public String getCarColor() &#123; return carColor; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public Information(int personNum, String address, String carColor) &#123; super(); this.personNum = personNum; this.address = address; this.carColor = carColor; &#125;&#125;/** * 被观察者的实现类 * @author Wch * */public class Transporter implements Watched &#123; private List&lt;Watcher&gt; watcherList;//观察者列表，维护了所有的观察者 private Information inf; public void changeState(Information inf)&#123;//改变状态，每改变一次就通知给观察者 this.inf = inf; notifyWatchers(); &#125; public Transporter() &#123; super(); this.watcherList = new ArrayList&lt;&gt;(); &#125; public Transporter(List&lt;Watcher&gt; watcherList) &#123; super(); &#125; @Override public void addWatcher(Watcher watcher) &#123; watcherList.add(watcher); &#125; @Override public void removeWatcher(Watcher watcher) &#123; watcherList.remove(watcher); &#125; @Override public void notifyWatchers() &#123; for (Watcher watcher: watcherList) &#123; watcher.update(inf); &#125; &#125;&#125;/** * 警察，实现Watcher接口 * @author Wch * */public class Police implements Watcher &#123; @Override public void update(Information inf) &#123; System.out.println("监控中，汽车已行进到"+inf.getAddress()); &#125;&#125;public class Thief implements Watcher &#123; @Override public void update(Information inf) &#123; System.out.println("准备动手，汽车已进行到"+inf.getAddress()+";押运人员数为"+inf.getPersonNum()+";运钞车颜色是"+inf.getCarColor()); &#125;&#125;/** * 测试 * @author Wch * */public class ObserverTest &#123; public static void main(String[] args) throws InterruptedException &#123; Transporter transporter = new Transporter(); Police police = new Police(); Thief thief = new Thief(); transporter.addWatcher(police);//添加观察者 transporter.addWatcher(thief); Information inf = new Information(3, null,"绿色"); for(int i = 0;i&lt;10;i++)&#123; inf.setAddress("长安街"+i*100+"米"); transporter.changeState(inf);//修改状态，发布信息 Thread.sleep(2000); &#125; &#125;&#125;console:监控中，汽车已行进到长安街0米准备动手，汽车已进行到长安街0米;押运人员数为3;运钞车颜色是绿色监控中，汽车已行进到长安街100米准备动手，汽车已进行到长安街100米;押运人员数为3;运钞车颜色是绿色监控中，汽车已行进到长安街200米准备动手，汽车已进行到长安街200米;押运人员数为3;运钞车颜色是绿色监控中，汽车已行进到长安街300米准备动手，汽车已进行到长安街300米;押运人员数为3;运钞车颜色是绿色监控中，汽车已行进到长安街400米准备动手，汽车已进行到长安街400米;押运人员数为3;运钞车颜色是绿色监控中，汽车已行进到长安街500米准备动手，汽车已进行到长安街500米;押运人员数为3;运钞车颜色是绿色监控中，汽车已行进到长安街600米准备动手，汽车已进行到长安街600米;押运人员数为3;运钞车颜色是绿色监控中，汽车已行进到长安街700米准备动手，汽车已进行到长安街700米;押运人员数为3;运钞车颜色是绿色监控中，汽车已行进到长安街800米准备动手，汽车已进行到长安街800米;押运人员数为3;运钞车颜色是绿色监控中，汽车已行进到长安街900米准备动手，汽车已进行到长安街900米;押运人员数为3;运钞车颜色是绿色 观察者设计两种模式：在观察者模式中，又分为推模型和拉模型两种方式。 推模型主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。 拉模型主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。 两种模式的比较 推模型是假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。 推模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。 本例使用的是推模型，将所有的Information信息对象打包发布给观察者，任观察者自己解析。若使用拉模型，则将整个被观察者对象的引用发布，观察者得到的是被观察者的内存地址，也可以自由获取其内部的信息。 这两种模式的使用，取决于系统设计时的需要。如果目标角色比较复杂，并且观察者角色进行更新时必须得到一些具体变化的信息，则“推模式”比较合适。如果目标角色比较简单，则“拉模式”就很合适啦。 有关Java中对观察者模式支持更详细的解析参见：http://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.htmlhttp://blog.csdn.net/jason0539/article/details/45055233 工厂设计模式用来生产特定对象的一种设计模式。工厂模式可以分为： 简单工厂模式（simple factory） 工厂方法模式（factory method） 抽象工厂模式（abstract factory） 简单工厂模式可以看做是工厂方法模式的特例。两者的区别是：工厂方法模式：一个抽象产品类，可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类只能创建一个具体产品类的实例。抽象工厂模式：多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类可以创建多个具体产品类的实例。区别：工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。两者皆可。 简单工厂模式例程： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * 定义工厂类，不是接口或者抽象类，若需要增加车型，需要增加方法，不符合开闭原则（对扩展开放；对修改封闭） * 所以在工厂方法模式中，出现了Factory的基类，增加车型则新加工厂。原有的工厂不会修改。 */public class Factory &#123; public static BWM returnBWM(String color)&#123; return new BWM(color); &#125; public static Audi returnAuti(String color)&#123; return new Audi(color); &#125;&#125;/** *抽象产品角色，父接口或者是抽象类 */public abstract class Car &#123; private String type; private String color; public Car() &#123; super(); &#125; public Car(String type, String color) &#123; super(); this.type = type; this.color = color; &#125;&#125;/* * 具体产品角色 */public class BWM extends Car &#123; public BWM() &#123; System.out.println("BWM被制造了"); &#125; public BWM(String color)&#123; super("BWM",color); System.out.println("BWM被制造了"); &#125;&#125;public class Audi extends Car &#123; public Audi() &#123; System.out.println("Audi被制造了"); &#125; public Audi(String color)&#123; super("Audi",color); System.out.println("Audi被制造了"); &#125;&#125;//testpublic class FactoryTest &#123; public static void main(String[] args) &#123; Audi audi = Factory.returnAuti("红色"); BWM bwm = Factory.returnBWM("白色"); &#125;&#125; 关于抽象工厂模式详见：http://blog.csdn.net/jason0539/article/details/44976775 警告核心技术卷一P113：不要编写返回引用可变对象的get方法，这样坐会破坏封装性！！！如果需要返回一个可变对象的引用，应首先对它进行克隆，对象克隆指存放在另一内存位置上的对象副本。 ED]]></content>
      <categories>
        <category>学习笔记</category>
        <category>笔记整理</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记整理（3）]]></title>
    <url>%2F2019%2F02%2F14%2F%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[笔记整理（3）整理了从开始学习Java以来在纸质本上做的一些笔记，如有错误，恳请批评指正。 增强For循环 底层使用可迭代器获取，只不过获取有JVM完成。所以不能在循环的过程中使用集合对象对集合元素个数进行修改。 Map集合没有实现Iterable接口，所以Map集合不能使用for增强循环，但是可以借助Collection的集合。———&gt;entrySet返回Set&lt;Map.Entry&lt;K,V&gt;&gt; 自定义一个可以使用For循环的类，只需要实现Iterable接口。 可变参数 可变参数必须位于最后一位。 自动装箱、自动拆箱 自动装箱：自动把java的基本数据类型数据转换成对象类型数据。 自动拆箱：把引用类型的数据转换成基本类型的数据。 Integer类内部维护了缓冲数组，该缓冲数组存储的-128~127这些数据在一个数组中，超过这个范围才会创建新的Integer类。 IO流（Input Output）输入输出流路径问题： 绝对路径：该文件在硬盘上的完整路径。绝对路径一般以盘符开头。 相对路径：相对路径就是资源文件相对于当前程序所在的路径。 .:当前路径 `File.getAbsolutePath();`//获取当前路径。 ..:上一级路径 注意：若程序与资源文件不在同一盘符，无法使用相对路经。 File API创建：createNewFile() mkdir() mkdirs() renameTo(File des);// 略... 输入字节流InputStream 所有输入字节流的基类、抽象类public abstract class InputStream implements Closeable {} |——FileInputStream 读取文件数据的输入字节流 使用FileInputStream读取文件数据的步骤： 找到目标文件 建立数据的输入通道 读取文件中的数据：read() 返回已读取的字节数，末尾返回-1（int）。 关闭资源 资源必须关闭别的程序才能访问。 输出字节流OutputStream 所有输出字节流的父类 抽象类 `public abstract class OutputStream implements Closeable, Flushable {}` |------FileOutputStream 向文件输出数据的输出字节流 FileOutputStream使用步骤： 找到目标文件 建立数据的输出通道 把数据转换成字节数组写出 关闭资源 原则：先开后关，后开先关 注意的细节 使用FileOutputStream的时候，如果目标文件不存在，则自动创建一个目标文件对象。 如果目标文件已经存在，会清空文件中个所有数据，然后写入数据。 如果需要追加数据，需调用FileOutputStream(file,true)构造函数，第二个参数为true； 使用FileOutputStream的write()方法写出数据时，虽然接受的是一个int类型的数据，但真正写出的只是一个字节的数据，只是把低八位的二进制写出，其他二十四位全部丢弃。 输入字节流体系InputStream |------FileInputStream 读取文件数据的输入字节流 |------BufferedInputStream 缓冲输入字节流，为提高效率，其内部维护了一个8kb的字节数组。byte[8192] 注意：凡是缓冲流都不具备读写能力。 使用BufferedInputStream的步骤： 找到目标文件 建立数据的输入通道 建立缓冲的输入字节流 关闭资源注意：read()方法中，形参若传入了缓冲数组，内容是储存到缓冲数组中，返回值是存储到缓冲数组中的字节个数。若没有传入缓冲数组，返回值是读取到的内容的ASCII码值。 输出字节流体系OutputStream |------FileOutputStream |------BufferedOutputStream 内部也维护了一个8kb的字节数组。 注意：使用时需要flush()或者最后close()将缓存在数组中的内容写入到硬盘。 字符流的抽象基类：|---Reader | |---FileReader | |---BufferedReader | |---Writer | |---FileWriter | |---BufferedWriter FileReader：读取文件的输入字符流 找到目标文件 建立数据的输入通道 读取数据 关闭资源 FileWriter：向文件输出数据的输出字符流 找到目标文件 建立数据输出通道 写出数据 关闭资源 注意：缓冲流都不具备读写文件的能力。 BufferedReader：一次读一行拓展。readLine(); BufferedWriter：写入一个行分隔符。newLine(); 装饰者设计模式 装饰者设计模式：增强一个类的功能，且还可以让这些装饰类相互装饰。优势：内部可以通过多态技术对多个需要增强的类进行增强，可以使这些装饰类达到相互装饰的效果，使用比较灵活。缺点：需要内部通过多态技术维护需要被增强的类的实例，使得代码比较复杂。 设计步骤： 在装饰类的内部维护一个被装饰类的引用。 让装饰类有一个共同的父类或者是接口。为什么要继承？为了让这些装饰类对象可以作为参数传递，构成一个装饰链，达到相互装饰的效果。 例程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package cn.ustb.day03.decorator;public class Decorator &#123; /** * 被装饰者 * @author Wch * */ static class BeDecoratorClass&#123; private String name; private int salary; public BeDecoratorClass() &#123; super(); &#125; public BeDecoratorClass(String name, int salary) &#123; super(); this.name = name; this.salary = salary; &#125; public String getName() &#123; return name; &#125; public int getSalary() &#123; return salary; &#125; public void action()&#123; System.out.println("被装饰者的最初行为"); &#125; &#125; /** * //定义一个装饰者类的基类，用于装饰类共同继承,需要继承被装饰者类！！！ * @author Wch */ static class DecoratorClass extends BeDecoratorClass&#123; &#125; /** * 装饰者1类 * @author Wch * */ static class Decorator_one extends DecoratorClass&#123; BeDecoratorClass beDecoratorClass;//关键之处。装饰者内部有被装饰者类的引用。 //构造方法：传入其他的装饰类对象 public Decorator_one(BeDecoratorClass beDecoratorClass) &#123;//多态接参 super(); this.beDecoratorClass = beDecoratorClass; &#125; public String getName() &#123; return beDecoratorClass.getName()+"被装饰类1装饰过了"; &#125; public int getSalary() &#123; return beDecoratorClass.getSalary()+1000;//装饰类1+1000 &#125; public void action() &#123; beDecoratorClass.action(); System.out.println("装饰1+action"); &#125; &#125; static class Decorator_two extends DecoratorClass&#123; BeDecoratorClass beDecoratorClass; public Decorator_two(BeDecoratorClass beDecoratorClass) &#123;//多态接参 super(); this.beDecoratorClass = beDecoratorClass; &#125; public String getName() &#123; return beDecoratorClass.getName()+"被装饰类2装饰过了"; &#125; public int getSalary() &#123; return beDecoratorClass.getSalary()+2000;//装饰类2+2000 &#125; public void action() &#123; beDecoratorClass.action(); System.out.println("装饰2+action"); &#125; &#125; static class Decorator_three extends DecoratorClass&#123; BeDecoratorClass beDecoratorClass; public Decorator_three(BeDecoratorClass beDecoratorClass) &#123; super(); this.beDecoratorClass = beDecoratorClass; &#125; //还可以新增方法 public void newAction()&#123; System.out.println("装饰者3的新行为"); &#125; &#125; /** * 测试 * @param args */ public static void main(String[] args) &#123; BeDecoratorClass bdc = new BeDecoratorClass("被装饰者对象",5000); System.out.println(bdc.getName()+bdc.getSalary()); bdc.action(); System.out.println("------------------------"); Decorator_one d1 = new Decorator_one(bdc); System.out.println(d1.getName()+d1.getSalary()); d1.action(); System.out.println("------------------------"); Decorator_two d2 = new Decorator_two(d1); System.out.println(d2.getName()+d2.getSalary()); d2.action(); System.out.println("------------------------"); Decorator_three d3 = new Decorator_three(bdc); d3.newAction(); &#125;&#125; 1234567891011121314结果：被装饰者对象5000被装饰者的最初行为------------------------被装饰者对象被装饰类1装饰过了6000被装饰者的最初行为装饰1+action------------------------被装饰者对象被装饰类1装饰过了被装饰类2装饰过了8000被装饰者的最初行为装饰1+action装饰2+action------------------------装饰者3的新行为 更多详解参见：http://blog.csdn.net/jason0539/article/details/22713711 SequenceInputStream序列流表示其他输入流的逻辑串联，它从输入流的有序集合开始，并从第一个输入流开始，直到到达文件末尾，接着从第二个输入流读取，依次类推，末尾返-1。构造方法：12public SequenceInputStream(InputStream s1, InputStream s2)&#123;&#125;public SequenceInputStream(Enumeration&lt;? extends InputStream&gt; e) &#123;&#125; 1234567891011121314151617/** * 利用序列流将两个文件合并 * @author Wch */public class Test1 &#123; public static void main(String[] args) throws IOException &#123; FileInputStream fis1 = new FileInputStream("F:/java/a.txt"); FileInputStream fis2 = new FileInputStream("F:/java/b.txt"); FileOutputStream fos = new FileOutputStream("F:/java/c.txt",false); SequenceInputStream sis = new SequenceInputStream(fis1, fis2); int b; while((b = sis.read()) != -1) fos.write(b); sis.close();//传入的流也会一同关闭 fos.close(); &#125;&#125; 对象的输入输出流对象的输入输出流主要的作用是用于读写对象的信息，对象的信息一旦写到文件上就相当于持久化了。 对象的输入流：ObjectInputStream 输入流的一般步骤：（反序列化） 找到目标文件 建立数据输入流对象 建立对象的输入流对象 读取对象信息——创建对象肯定要依赖对象所属的class文件，但不再调用其构造方法。 关闭资源 对象的输出流：ObjectOutputStream 输出流的一般步骤：（序列化） 找到目标文件 建立数据输出流对象 建立对象的输出流对象 把对象输出 关闭资源 注意的细节： 对象需要实现Serializable接口，此接口是一个标识接口。NotSerializableException 反序列化不需要调用构造方法 serialVersionUID用于记录class文件的版本信息。其用过一个类的类名、成员、包名、工程名计算出一个数字作为标识，若在更改了类的以上四个信息后再对之前的文件反序列化，会因UID不同报异常。InvalidClassException 如果一个对象可能在后期会修改结构，最好从一开始就指定一个版本UID，定义方式：private static final long serialVersionUID = 1515654631289456l; 如果一个对象某个数据不想被序列化至硬盘，可以使用关键字transient修饰。 如果一个类里引用了另一个类，则另一个类也需要实现Serializable接口。注意：如果被引用的类无法访问或无法使其可序列化，应如何处理？ 方法一：继承该类，使子类可序列化。但若该类为final或引用有其他非序列化对象，不可继承不可修改，此法失败。 方法二：使用transient修饰，使其&lt;透明的，短暂的&gt; 序列化不适用于静态变量，因为静态变量并不属于对象的一部分，静态变量随着类的加载而加载，属于类变量。由于序列化只适用于对象，基本数据类型可以被序列化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package cn.ustb.objectstream;public class Test1 &#123; static class Employee implements Serializable&#123; private static final long serialVersionUID = 2207767874790831729L;//添加标识 private String name; transient private int id;//transient修饰会对该变量进行透明化处理，不对其进行序列化。 public Employee() &#123; super(); &#125; public Employee(String name, int id) &#123; super(); this.name = name; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; @Override public String toString() &#123; return "Employee [name=" + name + ", id=" + id + "]"; &#125; &#125; private static void objectOut(Object obj,String filePath) throws FileNotFoundException, IOException&#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath)); oos.writeObject(obj);//writeObject方法，更多的方法详见API oos.close(); &#125; private static Object objectIn(String filePath) throws ClassNotFoundException, IOException&#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filePath)); Object readObject = ois.readObject(); return readObject; &#125; public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException &#123; Employee e = new Employee(); e.setName("new name"); e.setId(111110000); objectOut(e, "f:/java/a.txt"); Employee b = (Employee) objectIn("f:/java/a.txt"); System.out.println(b);//Employee [name=new name, id=0] &#125;&#125; 关于transient的一些注解， Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。transient是Java语言的关键字，用来表示一个域不是该对象串行化的一部分。当一个对象被串行化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的。 详见：http://www.blogjava.net/fhtdy2004/archive/2009/06/20/286112.html Properties配置文件类主要用于生成配置文件和读取配置文件的信息。属于集合体系&lt;Map&gt;的一个类，继承了HashMap，该类表示一个持久的的属性集，可保存在流中或从流中加载，属性列表中的每个键及其对应值都是一个字符串。不建议使用继承自Map的put方法添加，因其强转可能不安全。而应用setProperty()的方法是安全的。输入：步骤： 创建Properties对象 load配置文件到Properties中 遍历，查找12void load(InputStream);void load(Reader); 输出：步骤： 创建Properties对象 使用store方法保存生产配置文件。 12void store(OutputStream,String comment);void store(Writer,Stirng comment); 12getProperty(String key);getProperty(String key,String defaultValue); 1234567891011public class Demo1 &#123; public static void main(String[] args) throws FileNotFoundException, IOException &#123; Properties p = new Properties(); p.setProperty("key", "value"); p.store(new FileOutputStream("F:/java/a.txt"), "comments"); &#125;&#125;#comments#Wed Mar 08 20:13:42 CST 2017key=value 注意的细节： 若有中文，需使用输出字符流。 如果Properties中的内容出现变化，要重新使用Properties生成配置文件。 转换流 InputStreamReader：字节流通向字符流的桥梁。 OutputStreamReader：字符到字节。 构造方法： InputStreamReader(InputStream)默认GBK InputStreamReader(InputStream,Charset) OutputStreamWriter(OutputStream)默认GBK OutputStreamWriter(OutputStream,Charset) 操作文件的字符流是转换流的子类： |--Reader | |----InputStreamReader | |---FileReader |--Writer |----OutputStreamWriter |---FileWriter 转换流的作用： 可把字节流转化成字符流 FileReader与FileWriter是固定码表，转换流可指定码表。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>笔记整理</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记整理（2）]]></title>
    <url>%2F2019%2F02%2F14%2F%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[笔记整理（2）整理了从开始学习Java以来在纸质本上做的一些笔记，如有错误，恳请批评指正。 jar打包需要使用到jdk的开发工具，用法格式：jar cvf jar 文件名 class文件或者文件夹注意事项： 一个程序打完jar之后，必须在清单文件上指定入口类：格式：Main-class： 包名.类名 jar包双击运行仅对图形化界面的程序起作用，对控制台的程序不起作用。 “==”和equals“==”用于比较引用数据类型数据的时候比较的是两个对象的内存地址，equals方式默认情况下也是比较两个对象的内存地址。String类对Object的equals方法进行了重写，比较的是两个字符串的内容是否一致。 String中的APIlength\charAt\indexOf\lastIndexOf\endsWith\isEmpty\contains\equals\equalsIgnoreCase\ toCharArray\getBytes\replace\split\subString\toUpperCase\toLowerCase\trim StringBufferStringBuffer：存储字符的容器，字符串缓冲类。字符串的特点：字符串是常量，他们的值在创建之后就不能更改。其内容一旦发生变化，马上创建一个新的对象。所以：字符串的内容不宜频繁的进行修改。StringBuffer底层依赖一个字符数组储存字符数据，默认长度是16，若不够用，自动增长一倍；源码：1234567891011121314151617public StringBuffer(String str) &#123; super(str.length() + 16); append(str);&#125;public StringBuffer(CharSequence seq) &#123; this(seq.length() + 16); append(seq);&#125;void expandCapacity(int minimumCapacity) &#123; int newCapacity = (value.length + 1) * 2; if (newCapacity &lt; 0) &#123; newCapacity = Integer.MAX_VALUE; &#125;else if (minimumCapacity &gt; newCapacity) &#123; newCapacity = minimumCapacity; &#125; value = Arrays.copyOf(value, newCapacity);&#125; API：增：append\insert\删：delete\deleteCharAt\改：replace\reverse\setCharAt\subString\ensureCapacity\查：indexOf\lastIndexOf\capacity\length\charAt\toString StringBuffer与StringBuilder之间的区别： 执行速度Builder快于Buffer 都是数组对象。 Builder是非线程安全Buffer是线程安全的。因此：少量数据用String，单线程用Builder，多线程用Buffer。 SimpleDateFormat1234567public class Demo1 &#123; public static void main(String[] args) throws ParseException &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");//自定义格式，查询api，默认也可。 String time = sdf.format(new Date());//format Date date = sdf.parse(time);//parse &#125;&#125; RuntimeRuntime类主要代表了应用程序的运行环境。单例模式，私有了构造函数，不能直接实例化，通过Runtime.getRuntime()获取当前应用程序的运行环境对象。API：exec（String command）//根据指定路径执行对应的可执行文件。 12345678public class Demo &#123; public static void main(String[] args) throws IOException, InterruptedException &#123; Runtime runtime = Runtime.getRuntime(); Process exec = runtime.exec("D:/Git/git-bash.exe");//返回进程对象 Thread.sleep(2000); exec.destroy();//结束进程的方法 &#125;&#125; Calendar也是单例模式，通过Calendar.getInstance();获取对象。 Collection接口属于util包。123|Colleciton |-----List：有序，可重复。 |-----Set：无序，不可重复。 Collection API增：add\addAll删：clear\remove\removeAll(Collection c2)删除与c2的交集\retainAll(Collection c2)保留与c2的交集查：size\判断：isEmpty\contains\containsAll迭代：toArray\储存到一个数组中并返回。 iterator()：返回在此Collection的元素进行迭代的迭代器，关于元素返回的顺序没有保证，除非是某个能保证顺序的类实例。 List接口List APIlistIterator();返回Iterator的子接口ListIterator，特有的方法是： 123456789101112//特有@hasPrevious\previouspublic class Demo2 &#123; public static void main(String[] args) &#123; Integer[] arr = &#123;5,4,8,121,6,56,5623,6,4,68,3415,2,5&#125;; List&lt;Integer&gt; asList = Arrays.asList(arr); ListIterator&lt;Integer&gt; listIterator = asList.listIterator(); while(listIterator.hasNext()) System.out.println(listIterator.next()); while(listIterator.hasPrevious()) System.out.println(listIterator.previous()); &#125;&#125; List |-----ArrayList：底层维护了一个Object[]数组。**数组元素在内存中个地址是连续的**。特点：查询快，增删慢。 |-----LinkedList：链表实现，增删快，查询慢。 |-----Vector(了解) ArrayList API特有的方法： 1234567891011121314151617181920212223242526272829303132//ensureCapacity(int capacity);JDK1.6public void ensureCapacity(int minCapacity) &#123; modCount++; int oldCapacity = elementData.length; if (minCapacity &gt; oldCapacity) &#123; Object oldData[] = elementData; int newCapacity = (oldCapacity * 3)/2 + 1; if (newCapacity &lt; minCapacity) newCapacity = minCapacity; // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125;&#125;private void grow(int minCapacity) &#123;//JDK1.7 // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//1.5+1 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125;//trimToSize();public void trimToSize() &#123; modCount++; int oldCapacity = elementData.length; if (size &lt; oldCapacity) &#123; elementData = Arrays.copyOf(elementData, size); &#125;&#125; ArrayList无参的构造函数创建一个对象时，默认的容量是多少？长度不够怎么办？答：底层维护了一个Object【】，使用无参构造函数时，Object数组默认容量是10，长度不够时，自动增长0.5倍（右移一位）。 LinkedList API特有的方法：addFirst\addLast\getFirst\getLast\removeFirst\removeLast\LinkedList中的堆栈数据结构的实现： 12345678910//push：进栈//pop：出栈//源码public void push(E e) &#123; addFirst(e);&#125;public E pop() &#123; return removeFirst();&#125; 队列数据 结构的实现： 1234567891011121314151617181920212223242526272829303132333435363738//offer：enqueue//poll：dequeue//源码public E poll() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);&#125;public boolean offer(E e) &#123; return add(e);&#125;private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125;private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element;&#125; descendingIterator返回逆序的迭代器对象 迭代器，俩个接口 Iterator(next,hasNext,remove) ListIterator(list特有的方法，previous...) 多个方法 iterator------Collection listIterator------List及其子类 descendingIterator------LinkedList及其子类 Set接口Set |------HashSet |------TreeSet HashSetHashSet:底层使用了哈希表来支持，存取速度快。API:add\clear\clone\contains\isEmpty\iterator\remove\size 实现原理：添加元素时，先调用元素的hashcode方法得到hash码，通过移位运算得到存储位置。 情况1：如果存储位置没有元素，直接存储。 情况2：该位置有元素，调用equals方法比较，相等说明重复，不存储。否则说明不重复，继续存储。（哈希表的特点之一：桶式结构，可容纳多个不同的相同hash值元素。） hashcode默认情况下表示的是内存地址，String类在重写equals方法时重写了hashCode方法，其内部维护了一个hash值，其值根据其字符串的内容得来。这也是String不可改变的原因之一。相同字符串内容的两个String对象，其hash码值一样。 TreeSet底层使用了红黑树（二叉树）实现，特点：会对元素进行排序（存储顺序依然和set一样是无序的）。treeSet注意事项： 本身有序，则按自然顺序排序。 若元素本身不具备自然顺序，该元素必须实现Comparable接口，把比较的规则定义在重写的compareTo()方法中。 如果添加的时候，compareTo()方法返回的元素是0，则视为重复元素，不予添加。（TreeSet与hashCode和equals方法没有任何关系） 如果存储的元素本身没有自然顺序，也没有实现Comparable接口，则必须在创建TreeSet对象的时候传入一个比较器Comparator：new TreeSet(Comparator c); 如果同时实现了Comparable接口和传入了比较器，则比较器的规则优先使用。 自定义比较器的步骤：自定义类实现Comparator接口，把比较规则定义在compare方法中。 泛型类 在类上自定义泛型不能作用于静态方法，如果静态的方法需要使用自定义泛型，需要自己声明。 MapMap |------HashMap |------Treemap |------HashTable Map API增删改查：put\putAll\remove\clear\get\size\containsKey\containsValue\isEmpty迭代：123Set keySet = map.keySet();Collection values = map.values();Set entrySet = map.entrySet(); HashMap的存储原理，调用键的hashCode方法，经过移位运算存储……(类似于HashSet)TreeMap的存储原理，对元素的键进行排序，类似于TreeSet的存储过程。 TreeMap要注意的事项： 自然顺序。 无自然顺序，需实现Comparable接口。 若没实现借口，需在创建TreeMap的时候传入比较器。 集合工具类Collections，完全由在Collection上操作或返回Collection的静态方法组成。 1. 对List进行二分查找： int binarySearch(list,key); int binarySearch(list,key,Comparator);//无自然顺序自定义比较器 2. 对list进行排序 `sort(list&lt;T&gt;); sort(list&lt;T&gt;,Comparator);` 3. 对集合取最大最小值 `public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll){} public static &lt;T&gt; T max(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp) {}` `public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T min(Collection&lt;? extends T&gt; coll) {} public static &lt;T&gt; T min(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp) {}` 4. 对list集合进行反转 `reverse(list);` 5. 可以将不同步的集合变成同步的集合 `public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) {}` 详见API； 数组工具类Arrays的static 方法组成 二分查找，数组需要排序：binarySearch() 数组排序：sort() 将数组转为字符串：toString() 复制数组：copyOf(); 复制部分数组：copyOfRange(); 比较两个数组是否相等：equals(int[],int[]); 将数组变为集合：public static &lt;T&gt; List&lt;T&gt; asList(T... a) {} 集合变数组：List.toArrays(); 正则表达式预定义字符类： .：任何字符。 \d：数字【0-9】 \D：非数字【^0-9】 \s：空白字符【\t\n\x0B\f\r】 \S：非空白字符【^\s】 \w：单词字符【a-zA-Z_0-9】 \W：非单词字符【^\w】 注意：任何预定义字符在没有加数量词之前都只能匹配一个字符。 Greedy数量词： ？ 一次活一次都没有 * 零次或多次 + 一次或多次 {n} 恰好n次 {n，} 至少n次 {n,m} 至少n次，至多m次 迭代器迭代器是专门取出集合元素的对象，其是接口，不能直接创建对象，其以内部类的形式存在于每个集合子类的内部。（封装的思想），Collection的所有子类都具有获取Iterator迭代器的方法，但由于数据结构的 不同，都进行了重写。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//ArrayList中的Iterator源码： /** * An optimized version of AbstractList.Itr */ private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125;//List中的Iterator内部类，加强了Itr。private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123;&#125;//LinkedList的descendingIteratorprivate class DescendingIterator implements Iterator&lt;E&gt; &#123; private final ListItr itr = new ListItr(size()); public boolean hasNext() &#123; return itr.hasPrevious(); &#125; public E next() &#123; return itr.previous(); &#125; public void remove() &#123; itr.remove(); &#125;&#125; HashSet、ArrayList、MapHashSet和ArrayList集合都有判断元素是否相同的方法：containsMap与Collection并列存在，都是集合框架。Map:双列集合；Collection:单列集合。 Map的遍历1234567891011121314151617181920212223242526272829303132333435public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put("1", "value1"); map.put("2", "value2"); map.put("3", "value3"); //第一种：普遍使用，二次取值 System.out.println("通过Map.keySet遍历key和value："); for (String key : map.keySet()) &#123; System.out.println("key= "+ key + " and value= " + map.get(key)); &#125; //第二种 System.out.println("通过Map.entrySet使用iterator遍历key和value："); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = it.next(); System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue()); &#125; //第三种：推荐，尤其是容量大时 //entrySet是Map中个内部类 System.out.println("通过Map.entrySet遍历key和value"); for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue()); &#125; //第四种 System.out.println("通过Map.values()遍历所有的value，但不能遍历key"); for (String v : map.values()) &#123; System.out.println("value= " + v); &#125; &#125; Map.Entry接口：Map中已经将map集合中键值映射关系打包为一个对象，Map.Entry&lt;K,E&gt;，将其存入Set集合，该对象具备getKey，getValue方法。1Map.entrySet()---&gt;Set&lt;Map.Entry&gt;---&gt;iterator()---&gt;Map.Entry&lt;&gt;---&gt;&#123;equals\getKey\getValue\hashCode\setValue&#125; 源码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash; /** * Creates new entry. */ Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; &#125; return false; &#125; public final int hashCode() &#123; return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue()); &#125; public final String toString() &#123; return getKey() + "=" + getValue(); &#125; /** * This method is invoked whenever the value in an entry is * overwritten by an invocation of put(k,v) for a key k that's already * in the HashMap. */ void recordAccess(HashMap&lt;K,V&gt; m) &#123; &#125; /** * This method is invoked whenever the entry is * removed from the table. */ void recordRemoval(HashMap&lt;K,V&gt; m) &#123; &#125; &#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>笔记整理</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记整理（1）]]></title>
    <url>%2F2019%2F02%2F14%2F%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[笔记整理（1）整理了从开始学习Java以来在纸质本上做的一些笔记，如有错误，恳请批评指正。 进制：42–十进制、042–八进制（0开头）、0x42–十六进制（0x开头）、0b10–二进制（0b开头） Java中的8中基本数据类型： 整数的数据类型： byte（字节）：8位（bit） || 2^8 = 256 || -128~127（0算整数） short（短整型）：16位 || 2^16 int（整型）：32位 || 2^32 long（长整型）：64位注：如果一个整数未加任何标记的时候，默认int，如果要变为long类型，需在其后加l。 小数的数据类型： float（单精度浮点型）：32bit || 7位小数 double（双精度浮点型）：64bit || 15位小数注：默认为double，转换成float，在后面加F。（case insensitive） 字符类型： char（字符）：16bit 布尔类型： boolean：8或32bit声明数组占8bit，声明基本数据类型占32bit。 static变量存入数据共享区。 单例设计模式：保证一个类在内存中只存在一个对象。 饿汉单例模式： 私有化构造函数 声明本类的引用类型变量，并且使用改变量指向本类对象private static 提供一个公共静态的方法获取本类对象。 懒汉单例模式： 私有化构造函数 声明本类的引用的类型变量，但不要创建对象。 提供共有静态的方法获取本类对象，获取之前进行判断。推荐使用饿汉单例模式，在线程安全下不能保证一个类在内存中只有一个对象。1234567891011121314151617181920212223242526/** * 懒汉 * @author Wch */public class LazySingle &#123; private static LazySingle ls; private LazySingle()&#123;&#125;//私有化构造函数 public static LazySingle getLS()&#123; if(ls==null) ls = new LazySingle(); return ls; &#125;&#125;/** * 饿汉 * @author Wch */public class HungrySingle &#123; private static HungrySingle hs = new HungrySingle(); private HungrySingle()&#123;&#125;; public static HungrySingle getHs()&#123; return hs; &#125;&#125; 静态函数不能直接访问非静态成员，只要存在对象也可以访问。 123456789public class Demo3 &#123; private static String field1; private String field2; public static void method1()&#123; Demo3 d3 = new Demo3(); String s = d3.field2; System.out.println(d3.field2); &#125;&#125; java中方法参数传递方式是按值传递。如果参数是基本类型，传递的是基本类型的字面量值的拷贝。如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝。 12345678910111213141516171819202122232425262728293031323334353637383940public class Demo2 &#123; int a = 3; String b = "test"; public void changeCallByValue(int a)&#123; a = 2; System.out.println(a); &#125; public void changeCallByReference(String b)&#123; b = "okToChange"; System.out.println(b); &#125; public void changeName(Employee e)&#123; e.setName("new name"); System.out.println(e); &#125; @Test public void test1()&#123; int a = 7; changeCallByValue(a); System.out.println(a);//还是7，值传递，基本数据类型传的是字面的值 String b = "original value"; changeCallByReference(b); System.out.println(b);//还是原值，值传递，Stirng为final，不能被改变，在方法内新new了一个 Employee e = new Employee(); e.setName("original name"); changeName(e); System.out.println(e.getName());//改变以后的值了，按值传递还是传的是Emp在内存中的地址，两者引用同一对象，要想不相互影响，需要clone &#125;//结果:/*27okToChangeoriginal valueEmployee [name=new name, hireDay=null]new name*/&#125; 多态注意的细节： 多态情况下，子父类存在同名的成员变量时，访问的是父类成员。 多态下，存在同名的非静态成员函数时，访问子类的方法。 多态下，存在同名的静态成员函数时，访问父类的方法。 多态情况下，不能访问子类特有的成员。（若要访问，需要进行强制类型转换） 多态情况下，子父类存在同名的成员时，除了非静态的函数，其余都是访问父类。原因：编译看左边，运行不一定看右边。Java编译器在编译的时候，会检查引用类型变量所属的类是否具备所指的成员，如果不具备编译则报错。 异常的处理 方式1：捕获处理 try-catch 需要注意的细节： try-catch块里面的的代码除了异常，若经过处理（非throw），try-catch块外面的代码可以正常执行。 try块中除了异常，其后的代码不会执行了。 方式2：抛出处理注意： 方法抛出异常，调用者就必须要处理。 方法抛出异常，throw语句后的代码不再执行，一个方法遇到throw关键字，该方法立即停止。 异常可分为编译时异常和运行时异常。 运行时异常：RuntimeException以及其子类。抛出该类，方法上可以不声明，调用者可以不处理。运行时异常在编码上可以避免。 编译时异常：除上类之外的其他异常，抛出改类，须声明和处理。 字符串String 问题：new String（“abc”）创建了几个对象 答：一个或者两个，如果在字符串常量池中存在“abc”，只在堆内存中创建一个对象；如果不存在，则在常量池和堆内存中同时创建两个对象。 12345678910111213public class Demo6 &#123; public static void main(String[] args) &#123; String str1 = "hello"; String str2 = "hello"; String str3 = new String("hello"); String str4 = new String("hello"); System.out.println(str1 == str2);//true System.out.println(str2 == str3);//false System.out.println(str3 == str4);//false System.out.println(str3.equals(str2));//true &#125;&#125; - String str = &quot;hello&quot;；//的方式创建时，1. 虚拟机检查字符串常量池中是否已经存在改字符串常量，如果存在则不会创建，直接返回改字符串在常量池中的内存地址，若不存在，创建+返回。 - String str = new String(&quot;hello&quot;);//方式创建时，首先也会检查常量池，然后还会去堆内存中创建一分字符串对象，将常量池中的字符串内容拷贝至内存中，然后返回内存中字符串对象的内存地址。 使用StringBuffer无参的构造函数创建一个对象时，默认的容量是多少？如果长度不够，自动增长多少？ StringBuffer底层依赖一个字符数组存储字符数据，默认容量是16，若不够用，自动增长1倍。 字符串的特点，字符串是常量；它们的值在创建之后不能更改。其内容一旦改变，那么马上就创建一个新的对象。所以字符串的内容不宜频繁的修改，如果需要频繁修改字符串的内容，建议使用字符缓冲类（StringBuffer）。 System类：系统类，主要用于获取系统的属性数据。 常用方法：12345678public static native void arraycopy(Object src, int srcPos,Object dest, int destPos,int length);currentTimeMillis();//获取当前时间nanoTime();//更精准的计时。exit();//退出jvm，若参数为0代表正常退出，否则不正常。gc();//建议jvm回收垃圾。getenv(Stirng name);//根据环境变量的名字获取环境变量getProperty("key");//获取系统某个属性getProperties();//获取系统的所有属性 自定义线程的实现方式： 方式1：继承Thread 自定义一个类继承Thread类。 重写Thread类的run方法，把自定义线程的任务代码写在run方法上。 创建Thread的子类对象，并且调用start方法开启线程。注意：不要直接调用run方法。重写run方法的目的：每个线程都有自己的任务代码，jvm创建的主线程的任务代码就是main方法中的代码，自定义线程的任务代码就是run方法中的代码。借用网上的线程生命周期状态图： 方式2：实现Runnable接口 自定义一个类实现Runnable接口 实现Runnable接口的run方法，把自定义线程的任务定义在run方法上。 创建Runnable实现类对象。 创建Thread类的对象，并把Runnable的实现类作为实参传递。 调用Thread对象的start方法开启一个线程。 问：Runnable的实现类对象是线程对象吗？ 答：不是，只是个Runnable接口的实现类，只有Thread和其子类才是。 问：为什么把Runnable实现类的对象作为实参传递？其作用是？ 答：作用就是把Runnable实现类对象的run方法作为线程的任务代码去执行。 线程的通讯：一个线程完成了自己的任务时，要通知另外一个线程去完成另外一个任务。 123wait();//等待，notify();//唤醒notifyAll(); 注意事项： wait()和notify()方法是属于Object对象的。 wait()方法与notify()方法必须在同步代码块或同步函数中使用。 wait方法与notify方法必须由同一个锁对象调用。否则会出现IllegalMonitorStateException。不同的锁对象调用wait方法会建立不同的线程池。线程间通讯就是多个线程在操作同一个资源，但操作动作不同。 线程常用的方法： 123456789Thread(String name);//constructorgetName();setName(String name);sleep();currentThread();getPriority();//优先级setPriotiry();getId();//返回线程标识符，线程Id是一个正的long数，唯一终身不变，可回收。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>笔记整理</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC学习笔记（一）]]></title>
    <url>%2F2019%2F02%2F14%2FSpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SpringMVC学习笔记（一）SpringMVC简介，URL处理器，视图解析器，控制器，基于注解的MVC实现个人笔记，如有错误，恳请批评指正。 Spring MVC简介SpringMVC是什么 Spring Web MVC是一种基于Java的实现了Web MVC设计模式的请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将web层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，SpringWeb MVC也是要简化我们日常Web开发的。另外还有一种基于组件的、事件驱动的Web框架在此就不介绍了，如Tapestry、JSF等。 Spring Web MVC也是服务到工作者模式的实现，但进行可优化。前端控制器是DispatcherServlet；应用控制器其实拆为处理器映射器(Handler Mapping)进行处理器管理和视图解析器(ViewResolver)进行视图管理；页面控制器/动作/处理器为Controller接口（仅包含ModelAndView handleRequest(request, response) 方法）的实现（也可以是任何的POJO类）；支持本地化（Locale）解析、主题（Theme）解析及文件上传等；提供了非常灵活的数据验证、格式化和数据绑定机制；提供了强大的约定大于配置（惯例优先原则）的契约式编程支持 Spring3 MVC VS Struts2 官方的下载网址是：http://www.springsource.org/download 我们用Struts2时采用的传统的配置文件的方式,并没有使用传说中的0配置SpringMVC可以认为已经100%零配置了 Spring会比Struts快,在Struts中默认配置了很多缺省的拦截器,在给开发者提供便利的同时,失去了灵活性和执行效率. Spring mvc是基于方法的设计, 而Sturts是基于类,每次发一次请求都会实例一个action，每个action都会被注入属性，而spring基于方法，粒度更细,可控制更强 设计思想上：Struts更加符合oop的编程思想,Spring是在在Servlet上扩展，使用AOP实现。 Intercepter的实现机制：Struts有以自己的interceptor机制，Spring mvc用的是独立的AOP方式. 需要的自己配置,比较麻烦但性能较优,灵活性高 提供强大的约定大于配置的契约式编程支持环境搭建与入门使用实例创建项目并导入相关jar包mvc、aop、core相关包 创建配置文件新建spring-mvc.xml文件 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd "&gt;&lt;/beans&gt; 配置前端过滤器org.springframework.web.servlet.DispatcherServlet，继承HttpServlet，需要在Web.xml文件中定义 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app version="3.0" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"&gt; &lt;display-name&gt;&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;!-- 继承servlet --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;&lt;!-- 配置文件目录 --&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;!-- 项目启动就初始化servlet --&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 创建控制器创建控制器FirstAction.java，实现Controller接口 12345678910111213141516171819202122232425262728// action实现Controller接口，并实现handleRequest方法（类似service方法），与JSP内置对象偶合public class FirstAction implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; // TODO Auto-generated method stub System.out.println("传入的数据为"); String userName=request.getParameter("userName"); String pwd=request.getParameter("pwd"); System.out.println("userName:"+userName); System.out.println("这里可以调用业务层处理业务。"); //封装数据，可以直接使用request对象，也可以使用封装等方式，真正使用时可以选择一种 request.setAttribute("rUserName", userName); Map&lt;String, String &gt; map=new HashMap&lt;String, String&gt;(); map.put("mUserName",userName); //返回视图层，如果使用map封装数据，需要作为（第二个）参数传递，也是request作用域。 return new ModelAndView("/jsp/first.jsp",map); //返回视图层,不传递map。 //return new ModelAndView("/jsp/first.jsp"); //也可以使用如下方式传递，不使用Map，数据一样是request作用域 //return new ModelAndView("/jsp/first.jsp","mUserName",userName); &#125;&#125; 修改配置文件，添加控制器信息修改spring-mvc.xm.文件 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd "&gt; &lt;!-- 1。配置action，实现controler接口 2。配置映射处理器，用来处理请求与action的映射，可以不用写id, 3。配置视图解析器：完成ModelAndView的解析 缺点： 1。与JSP偶合 2。只支持属性的注入，不支持封闭后对象注入 --&gt; &lt;!-- 声明bean的name，因为使用了BeanNameUrlHandlerMapping，所以不是定义id,用户调用的URL将通过bean的name匹配 --&gt; &lt;bean name="/first.action" class="cn.ustb.action.FirstAction" /&gt; &lt;!-- 声明 BeanNameUrlHandlerMapping，使用名称映射--&gt; &lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping" /&gt; &lt;!-- 支持servlet与jsp视图解析，可进行进一步处理，此步可省略， --&gt; &lt;!-- InternalResourceViewResolver支持servlet与jsp视图解析，没有配置时，默认使用它，此步可省略， --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 可以加前缀或后缀 --&gt; &lt;!-- &lt;property name="prefix" value="/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; --&gt; &lt;/bean&gt; 创建结果展现页面新建目录jsp及目录下新建first.jsp，用来展现访问结果。 1234567891011&lt;%@ page language="java" import="java.util.*" pageEncoding="utf-8"%&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;My JSP 'index.jsp' starting page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 这是/jsp/first.jsp页面.&lt;br/&gt; &lt;!-- 获取并展现控制层传递过来的值 --&gt; 直接通过request传递的值：$&#123;requestScope.rUserName&#125;&lt;br/&gt;通过Map传递的值：$&#123;requestScope.mUserName&#125; &lt;/body&gt;&lt;/html&gt; 编写测试(访问）页面编写index.jsp用来访问控制器 123456789&lt;%@ page language="java" import="java.util.*" pageEncoding="utf-8"%&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;My JSP 'index.jsp' starting page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href="first.action?userName=mike&amp;pwd=admin"&gt;firstMVC&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 流程分析 URL处理器BeanNameUrlHandlerMappingstrong textBeanNameUrlHandlerMapping：它将收到的HTTP请求映射到bean的名称(这些bean需要在web应用上下文中定义) 1234&lt;!-- 声明bean的name，因为使用了BeanNameUrlHandlerMapping，所以不是定义id,用户调用的URL将通过bean的name匹配 --&gt; &lt;bean name="/first.action" class="cn.ustb.action.FirstAction" /&gt; &lt;!-- 声明 BeanNameUrlHandlerMapping，使用名称映射 --&gt; &lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping" /&gt; SimpleUrlHandlerMappingSimpleUrlHandlerMapping：它将收到的HTTP请求映射到bean的ID(这些bean需要在web应用上下文中定义) 12345678910&lt;!-- 配置URL与ACTION对象ID进行映射 ,&lt;prop key="second.action"&gt;second&lt;/prop&gt;,其中key匹配url信息,value为action的ID --&gt; &lt;bean id="first" class="cn.ustb.action.FirstAction" /&gt; &lt;bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="mappings"&gt; &lt;props&gt; &lt;prop key="first.action"&gt;first&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 视图解析器UrlBasedViewResolver123456789&lt;!-- 支持servlet与jsp视图解析1，可进行进一步处理，此步可省略， --&gt; &lt;!-- viewClass不同的配置,支持解析jstl的相关资源--&gt; &lt;bean class="org.springframework.web.servlet.view.UrlBasedViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt; &lt;!-- &lt;property name="prefix" value="/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; --&gt;&lt;/bean&gt; InternalResourceViewResolver作为UrlBasedViewResolver的子类， 它支持页面jstl处理. 123456&lt;!-- 支持servlet与jsp视图解析，可进行进一步处理，此步可省略， --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 可以加前缀或后缀 --&gt; &lt;property name="prefix" value="/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; forward:前缀forward使用转发方式： 123return new ModelAndView("forward:/jsp/first.jsp",map); //控制器采用注解，方法在返回字符串时，可以使用： return "forward:/jsp/first.jsp"; Redirect:前缀redirect重定向方式 123return new ModelAndView("redirect:/jsp/first.jsp",map);//控制器采用注解，方法在返回字符串时，可以使用return "redirect:/jsp/first.jsp"; 控制器controller接口在spring mvc中控制对象要实现controller接口，并且必须实现handRequest方法。此控制器在接收到DispatcherServlet分配置的请求时，执行handRequest方法，并返回ModelAndView实例，此实例中封装了Model与View。 123456public class FirstAction implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ... ...&#125; 添加student实体类12345678public class Student implements Serializable &#123; private static final long serialVersionUID = 1785249781500211272L; private Integer stuId; private String stuName; private String stuPwd; private Integer stuAge; ... ...&#125; AbstractCommandController可以将请求参数值自动设置到command对象中，便于后继的使用。 创建或修改控制器类1234567891011121314151617181920212223242526272829303132333435public class StudentAction extends AbstractCommandController &#123; public StudentAction()&#123; //配置student对象可以注入 setCommandClass(Student.class); &#125; @Override protected ModelAndView handle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, BindException arg3) throws Exception &#123; // TODO Auto-generated method stub System.out.println("---接收数据---"); //方式1接收数据，只能每个属性都分开接书 String stuName=arg0.getParameter("stuName"); String stuPwd=arg0.getParameter("stuPwd"); System.out.println("方式1接收的数据为："+stuName+","+stuPwd); //方式2接收数据，实现对象属性注入 Student student = (Student)arg2; System.out.println("方式2接收的数据为："+student); System.out.println("---调用业务层，进行业务处理，略---"); //封装视图数据，有多种方式 ，这里列表方式 一和方式 二，可以任选一种： //方式一,直接采用request对象封装 arg0.setAttribute("rStudent", student); //封装视图数据，方式二,直接采用Map封装，默认作用域是request，需要在return的时候作为参数传递。 Map&lt;String ,Student &gt; map=new HashMap&lt;String, Student&gt;(); map.put("mStudent", student); //默认为forward方式 return new ModelAndView("/jsp/main.jsp",map); &#125;&#125; 添加或修改spring-mvc.xml文件12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd "&gt; &lt;bean id="student" class="cn.itcast.action.StudentAction"&gt;&lt;/bean&gt; &lt;bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="mappings"&gt; &lt;props&gt; &lt;prop key="student.action"&gt;student&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 添加跳转页面/jsp/main.jsp 1234567891011&lt;%@ page language="java" import="java.util.*" pageEncoding="utf-8"%&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;My JSP 'main.jsp' starting page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 这是/jsp/main.jsp页面.&lt;br/&gt; &lt;!-- 获取并展现控制层传递过来的值 --&gt; 直接通过request传递的值：$&#123;requestScope.rStudent&#125;&lt;br/&gt;通过Map传递的值：$&#123;requestScope.mStudent&#125; &lt;/body&gt;&lt;/html&gt; 添加登陆测试页面index.jsp 12345678910&lt;%@ page language="java" import="java.util.*" pageEncoding="utf-8"%&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;My JSP 'index.jsp' starting page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href="student.action?stuName=mike&amp;stuPwd=admin"&gt;test student&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; MultiActionController准备工作除action类以外，其它继续使用上一节代码 添加StudentMultiAction.java类继承MultiActionController12345678910111213141516171819202122public class StudentMultiAction extends MultiActionController &#123; //定义方法时，参数规则：(HttpServletRequest request, HttpServletResponse response, [,HttpSession session] [,MyObject]); public ModelAndView add(HttpServletRequest request,HttpServletResponse response,Student student)&#123; System.out.println("add.student:"+student); student.setStuName("rename"); return new ModelAndView("jsp/main","student",student); &#125; //定义方法时，参数规则：(HttpServletRequest request, HttpServletResponse response, [,HttpSession session] [,MyObject]); public ModelAndView update(HttpServletRequest request,HttpServletResponse response,Student student)&#123; System.out.println("update.student:"+student); student.setStuName("rename"); return new ModelAndView("jsp/main","student",student); &#125; //定义方法时，参数规则：(HttpServletRequest request, HttpServletResponse response, [,HttpSession session] [,MyObject]); public ModelAndView list(HttpServletRequest request,HttpServletResponse response,Student student)&#123; System.out.println("list.student:"+student); student.setStuName("updateName"); return new ModelAndView("jsp/main"); &#125;&#125; 修改spring-mvc.xml文件12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd "&gt; &lt;!-- 配置控制器，并指定通过methodNameResolver方法名调用相关方法处理相关逻辑--&gt; &lt;bean id="studentMultiAction" class="cn.ustb.action.StudentMultiAction"&gt; &lt;!-- 引用方法解析器 --&gt; &lt;property name="methodNameResolver" ref="parameterMethodNameResolver"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 定义通过方法名调用控制器相关方法的规则 --&gt; &lt;bean id="parameterMethodNameResolver" class="org.springframework.web.servlet.mvc.multiaction.ParameterMethodNameResolver"&gt; &lt;!-- 在url中使用do=方法名方式识别相关方法，例如：studentMulti.action?do=add，将调用add方法；这里的do不是固定的，可以改为其它 --&gt; &lt;property name="paramName" value="do" /&gt; &lt;!-- 如果没有指定方法名时，默认 调用控制器的list方法 --&gt; &lt;property name="defaultMethodName" value="list" /&gt; &lt;/bean&gt; &lt;!-- URL处理器 --&gt; &lt;bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="mappings"&gt; &lt;props&gt; &lt;prop key="/studentMulti.action"&gt;studentMultiAction&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.UrlBasedViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"&gt;&lt;/property&gt; &lt;property name="prefix" value="/WEB-INF/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt;&lt;/beans&gt; 测试页面index.jsp关键代码 12345678910&lt;body&gt; &lt;form action="studentMulti.action?do=add" method="post"&gt; &lt;input type="text" name="stuName"&gt;&lt;br&gt; &lt;input type="password" name="stuPwd"&gt;&lt;br&gt; &lt;input type="submit" value="student_add"&gt; &lt;/form&gt; &lt;a href="studentMulti.action?do=update&amp;stuPwd=testpwd&amp;stuName=testName"&gt;调用修改方法&lt;/a&gt; &lt;a href="studentMulti.action?&amp;stuPwd=testpwd&amp;stuName=testName"&gt;调用默认方法&lt;/a&gt;&lt;/body&gt; 结果显示页面12345/WEB-INF/jsp/main.jsp关键代码&lt;body&gt; this is WEB-INF/JSP main jsp&lt;br&gt; studentName:$&#123;requestScope.student.stuName&#125;&lt;br&gt; &lt;/body&gt; 基于注解的MVC实现示例1继续使用上一章节的代码（注意新建项目记得重新配置web.xml文件） 修改spring-mvc.xml文件添加DefaultAnnotationHandlerMapping，AnnotationMethodHandlerAdapter等相关信息。其中DefaultAnnotationHandlerMapping：支持通过url找到相关的actionAnnotationMethodHandlerAdapter：支持通过url匹配action定义方法base-package：定 义扫描的范围,spring可以自动去扫描base-pack下面或者子包下面的java文件，如果扫描到有@Component @Controller@Service等这些注解的类，则把这些类注册为bean 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd "&gt; &lt;bean class="org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping"&gt;&lt;/bean&gt; &lt;bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"&gt;&lt;/bean&gt; &lt;context:component-scan base-package="*"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 添加或修改控制类加入@Controller，@RequestMapping注解信息 123456789101112131415161718192021222324252627282930313233@Controller //用来声明控制器@RequestMapping("/student")public class StudentAction &#123; public StudentAction()&#123; System.out.println("---StudentAction构造方法被调用---"); &#125;//访问可用student/save.action,save后边的action是根据web.xml配置来的 //如果要添加其它的数据到最后跳转过去的页面，可以在方法中添加ModelMap的参数，例如 : public String save(Student student,ModelMap map)&#123;//...,通过map再存放其它的数据 @RequestMapping(value="/save") public ModelAndView save(Student student)&#123; System.out.println("save方法注入的student对象："+student); System.out.println("---调用业务逻辑进行业务处理---"); //修改学生名字，跳转到下一页面时看能否显示修改后的名字 student.setStuName("rename"); //直接使用字符串，返回视图，进行结果展现等 return new ModelAndView("forward:/jsp/main.jsp"); &#125; //同一个action中可以定义多个方法,方法的返回类型也可以用String @RequestMapping("/update") public String update(Student student,ModelMap paramMap)&#123; System.out.println("update方法已注入student对象："+student); System.out.println("---调用业务逻辑进行业务处理---"); paramMap.put("other","testOtherValue"); //直接使用字符串，返回视图，进行结果展现等 return "forward:/jsp/main.jsp"; &#125;&#125; 添加或修改跳转页面1234567891011&lt;%@ page language="java" import="java.util.*" pageEncoding="utf-8"%&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;My JSP 'main.jsp' starting page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 这是/jsp/main.jsp页面.&lt;br/&gt; &lt;!-- 获取并展现控制层传递过来的值 --&gt; 默认通过request传递的值：$&#123;requestScope.student&#125;&lt;br/&gt; &lt;/body&gt;&lt;/html&gt; 添加或修改测试页面1234567891011&lt;%@ page language="java" import="java.util.*" pageEncoding="utf-8"%&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;My JSP 'index.jsp' starting page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href="student/save.action?stuName=mike&amp;stuPwd=admin"&gt;调用save方法&lt;/a&gt; &lt;a href="student/update.action?stuName=mike&amp;stuPwd=admin"&gt;调用update方法&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 示例2（基于annotation-driven的注解）基于上面的示例，在spring3中可以进一步简化配置，取代上面的注解方式. 步骤如下 1. 使用上面的action类，仍然给类及方法添加@Controller（类）、@RequestMapping（类及方法）注解 2. 本文件顶部添加spring mvc 命名空间的信息（可以参考org.springframework.web.servlet.config包） 3. 添加下面注解驱动**mvc:annotation-driven**，取代了上面的DefaultAnnotationHandlerMapping、AnnotationMethodHandlerAdapter，并启动了json的注解。 修改内容如下： 修改配置文件修改spring-mvc.xml文件： 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd "&gt;&lt;!-- &lt;bean class="org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping"&gt;&lt;/bean&gt; &lt;bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"&gt;&lt;/bean&gt; &lt;context:component-scan base-package="*"&gt;&lt;/context:component-scan&gt; --&gt; &lt;!-- mvc:annotation-driven，取代了上面的DefaultAnnotationHandlerMapping，AnnotationMethodHandlerAdapter两个Bean的配置 --&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;context:component-scan base-package="*"/&gt;&lt;/beans&gt; @SessionAttributes与model.addAttribute使用Spring 2.0 定义了一个 org.springframework.ui.ModelMap 类，它作为通用的模型数据承载对象，传递数据供视图所用。我们可以在请求处理方法中声明一个 ModelMap 类型的入参，Spring 会将本次请求模型对象引用通过该入参传递进来，这样就可以在请求处理方法内部访问模型对象了在默认情况下，ModelMap 中的属性作用域是 request 级别是，也就是说，当本次请求结束后，ModelMap 中的属性将销毁，但实际上有时候需要把ModelMap值存放于session中或有时候也可以从Session中获取对象的值注入到ModelMap中。 继续使用上一节代码 modelMap属性注入到Session如果希望在多个请求中共享 ModelMap 中的属性，必须将其属性转存到 session 中，这样 ModelMap 的属性才可以被跨请求访问；可以在定义 类时使用@SessionAttributes(“属性名”)或@SessionAttributes({“attr1”,”attr2”})等方式将尝试从modelMap中寻找相同属性名相应的value.修改StudentAction.java类, 12345678910111213141516171819202122232425262728293031323334@Controller@RequestMapping("/student")//下边如有多个属性可以用 @SessionAttributes(&#123;“attr1”,”attr2”&#125;)。@SessionAttributes("user") public class StudentAction &#123; public StudentAction()&#123; System.out.println("---StudentAction构造方法被调用---"); &#125; @RequestMapping(value="/save") public String save(Student student,ModelMap map)&#123; System.out.println("---调用业务逻辑进行业务处理---"); Student s2=new Student(); s2.setStuAge(11); s2.setStuId(11111); map.addAttribute("user", s2);//属性名必须与session一致 //map.addAttribute("stu", student); //直接使用字符串，返回视图，进行结果展现等 return "forward:/jsp/main.jsp"; &#125; //同一个action中可以定义多个方法 @RequestMapping(value="/update") public String update(Student student)&#123; System.out.println("update方法已注入student对象："+student); System.out.println("---调用业务逻辑进行业务处理---"); paramMap.put("student",student); //直接使用字符串，返回视图，进行结果展现等 return "forward:/jsp/main.jsp"; &#125;&#125; 修改/jsp/main.jsp 123456789101112131415&lt;%@ page language="java" import="java.util.*" pageEncoding="utf-8"%&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;My JSP 'main.jsp' starting page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 这是/jsp/main.jsp页面.&lt;br/&gt; &lt;!-- 获取并展现控制层传递过来的值 --&gt; 默认直接通过request传递的值：$&#123;requestScope.student&#125;&lt;br/&gt; &lt;!-- 默认直接通过session传递的值stu：$&#123;sessionScope.stu&#125;&lt;br/&gt; --&gt; 默认直接通过session传递user值：$&#123;sessionScope.user&#125;&lt;br/&gt;&lt;!--下边的代码给下一示例使用:调用update方法测试把session的值注入到map中，此时session已经有user相关信息--&gt; &lt;a href="../student/update.action"&gt;session的值注入到map中&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; session属性注入到ModelMap在参数中使用@ModelAttribute(“user”)，可以获取@SessionAttributes(“user”)值 继续使用上节代码修改StudentAction.java类,定义类时继续使用@SessionAttributes(“user”)，并修改update方法，在参数中添加@ModelAttribute(“user”)：参数中的student的对象将由session中获取。 1234567891011121314151617@Controller@RequestMapping("/student")//下边如有多个属性可以用 @SessionAttributes(&#123;“attr1”,”attr2”&#125;)。@SessionAttributes("user") public class StudentAction &#123; public StudentAction()&#123; System.out.println("---StudentAction构造方法被调用---"); &#125; //同一个action中可以定义多个方法 @RequestMapping(value="/update") public String update(@ModelAttribute("user")Student student)&#123; System.out.println("update方法已注入student对象："+student); System.out.println("---调用业务逻辑进行业务处理---"); //直接使用字符串，返回视图，进行结果展现等 return "forward:/jsp/main.jsp"; &#125;&#125;]]></content>
      <categories>
        <category>实用技术</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>MVC框架</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC学习笔记（三）]]></title>
    <url>%2F2019%2F02%2F14%2FSpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SpringMVC学习笔记（三）SSI框架的整合及优化个人笔记，如有错误，恳请批评指正。 ssi整合创建项目新建项目后规划好各层的包。 导入包 整合spring与mybatis调整spring与mybatis配置文件 创建、编写配置文件：myBatis-config.xml文件 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;&lt;!-- 通过别名简化对类的使用 &lt;typeAliases&gt; &lt;typeAlias type="cn.ustb.entity.Dept" alias="Dept" /&gt;&lt;/typeAliases&gt; &lt;mappers&gt; &lt;mapper resource="cn/ustb/entity/DeptMapper.xml" /&gt; &lt;/mappers&gt; --&gt;&lt;/configuration&gt; applicationContext.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd"&gt; &lt;!-- 配置数据源，记得去掉myBatis-config.xml的数据源相关配置 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=UTF-8" /&gt; &lt;property name="user" value="root" /&gt; &lt;property name="password" value="root" /&gt; &lt;/bean&gt; &lt;!-- 配置session工厂 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;property name="configLocation" value="classpath:myBatis-config.xml" /&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器,管理数据源事务处理--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 配置事务通知 --&gt; &lt;tx:advice id="advice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt;&lt;!-- 默认只处理运行时异常，可加rollback-for="Exception/Throwable"等处理所有异常或包括错误 --&gt; &lt;tx:method name="insert*" propagation="REQUIRED" rollback-for="Exception"/&gt; &lt;tx:method name="update*" propagation="REQUIRED" rollback-for="Exception"/&gt; &lt;tx:method name="delete*" propagation="REQUIRED" rollback-for="Exception"/&gt; &lt;tx:method name="*" propagation="SUPPORTS"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置切面织入的范围,后边要把事务边界定在service层 --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref="advice" pointcut="execution(* cn.ustb.scm.dao.impl.*.*(..))"/&gt; &lt;/aop:config&gt; &lt;!-- 配置SessionTemplate，已封装了繁琐的数据操作--&gt; &lt;bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate"&gt; &lt;constructor-arg name="sqlSessionFactory" ref="sqlSessionFactory"/&gt; &lt;/bean&gt; &lt;context:component-scan base-package="*"/&gt; &lt;/beans&gt; web.xml配置1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app version="3.0" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"&gt; &lt;display-name&gt;&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 编写实体及sql映射文件如没有建库表，先建库表,可参考如下sql: 1234567891011121314drop database if exists mybatis;create database mybatis CHARACTER SET UTF8;use mybatis;create table dept( dept_id int primary key auto_increment, dept_name varchar(50), dept_address varchar(50));insert into dept(dept_name,dept_address) values('研发部一部','广州');insert into dept(dept_name,dept_address) values('研发部二部','广州');insert into dept(dept_name,dept_address) values('研发部三部','深圳');select * from dept; 编写实体类 123456public class Dept implements Serializable &#123; private Integer deptId; private String deptName; private String deptAddress; ......&#125; sql映射文件，并将相关信息映射到mybatis-config.xml文件。 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.ustb.entity.DeptMapper"&gt; &lt;resultMap type="Dept" id="deptResultMap"&gt; &lt;id property="deptId" column="dept_id" /&gt; &lt;result property="deptName" column="dept_name" /&gt; &lt;result property="deptAddress" column="dept_address" /&gt; &lt;/resultMap&gt; &lt;!-- id和命名空间用来定位SQL语句，parameterType表示参数的类型，resultMap返回类型 --&gt; &lt;select id="selectDept" parameterType="Integer" resultMap="deptResultMap"&gt; &lt;!--参数的写法#&#123;deptID&#125; --&gt; select * from dept where dept_id=#&#123;deptID&#125; &lt;/select&gt; &lt;insert id="insertDept" parameterType="Dept"&gt; insert into dept(dept_name,dept_address) values(#&#123;deptName&#125;,#&#123;deptAddress&#125;); &lt;/insert&gt;&lt;/mapper&gt; myBatis-config.xml文件修改后为如下内容123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;&lt;!-- 通过别名简化对类的使用 --&gt;&lt;typeAliases&gt; &lt;typeAlias type="cn.ustb.entity.Dept" alias="Dept" /&gt;&lt;/typeAliases&gt; &lt;mappers&gt; &lt;mapper resource="cn/ustb/entity/DeptMapper.xml" /&gt; &lt;/mappers&gt; &lt;/configuration&gt; 编写Dao接口及实现123456789101112131415161718192021222324252627DeptDaoImpl.java@Repository("deptDao")public class DeptDaoImpl&#123; @Resource private SqlSessionTemplate sqlSessionTemplate; /** * 根据部门编号查询部门信息 * @param deptId 部门编号 * @return 部门信息 */ public Dept selectDept(Integer deptId)&#123; Dept dept= sqlSessionTemplate.selectOne("cn.ustb.entity.DeptMapper.selectDept", deptId); return dept; &#125; /** * 添加部门信息 * @param dept 部门信息 * @return 添加成功的记录数 */ public int insertDept(Dept dept)&#123; System.out.println("------dao.dept:"+dept); return sqlSessionTemplate.insert("cn.ustb.entity.DeptMapper.insertDept", dept); &#125;&#125; 测试spring与mybatis整合12345678910111213141516171819202122232425262728public class TestDeptDao &#123; //@Resource //这里没法使用，后继版本有其它方式可以注入 static private DeptDaoImpl deptDao; @BeforeClass public static void setUpBeforeClass() throws Exception &#123; ApplicationContext context =new ClassPathXmlApplicationContext("applicationContext.xml"); deptDao=(DeptDaoImpl) context.getBean("deptDao"); &#125; @AfterClass public static void tearDownAfterClass() throws Exception &#123; &#125; @Test public void testSelectDept() &#123; System.out.println(deptDao.selectDept(1)); &#125; @Test public void testInsertDept() &#123; Dept dept=new Dept(); //dept.setDeptId(117); dept.setDeptName("name117"); dept.setDeptAddress("address117"); System.out.println("受影响行数："+deptDao.insertDept(dept)); &#125;&#125; 整合springmvc修改web.xml文件，加入springmvc相关信息，编写 控制器类及相关jsp 文件spring-mvc.xml 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd "&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;context:component-scan base-package="*"/&gt;&lt;/beans&gt; web.xml文件配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app version="3.0" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"&gt; &lt;display-name&gt;&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; 编写控制器类12345678910111213@Controller@RequestMapping(value="/dept")public class DeptAction &#123; @Resource private DeptDaoImpl deptDao; @RequestMapping(value="/insert") public String insert(Dept dept)&#123; System.out.println("---action.dept:"+dept); deptDao.insertDept(dept); return "forward:/jsp/main.jsp"; &#125;&#125; 缩写跳转页面/jsp/main.jsp 12345678&lt;%@ page language="java" import="java.util.*" pageEncoding="utf-8"%&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; this is main jsp&lt;/body&gt;&lt;/html&gt; 测试ssi整合 缩写测试页面index.jsp123456789101112&lt;%@ page language="java" import="java.util.*" pageEncoding="utf-8"%&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="dept/insert.action" method="post"&gt; 名称：&lt;input type="text" name="deptName"&gt;&lt;br&gt; 地址：&lt;input type="text" name="deptAddress"&gt;&lt;br&gt; &lt;input type="submit" value="ok"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 优化中文乱码中文乱码处理，在web.xml中配置拦截器（参考前面） 123456789101112&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 添加业务层添加业务层相关包、接口及实现接口包：cn.ustb.service实现类包：cn.ustb.service.impl编写接口与实现类（实现类用@Service进行注解，dao接口结合下边的配置，通过@Autowired方式注入代理实例），略。 添加dao层接口略 修改applicationContext.xml与spring-mvc.xml文件添加如下内容： 12345678910111213141516&lt;!-- 把事务边界定在service层 --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref="advice" pointcut="execution(* cn.ustb.scm.service.impl.*.*(..))"/&gt; &lt;/aop:config&gt;&lt;!-- 自动扫描组件，要把controller去除，他们是在spring-mvc.xml中配置，如果不去除会影响事务管理。 --&gt; &lt;context:component-scan base-package="cn.ustb"&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller" /&gt; &lt;/context:component-scan&gt; &lt;!-- 配置 转换器，对于在basePackage设置的包（包括子包）下的接口类，如果在Mapper.xml文件中定义过， 将被转换成spring的BEAN，在调用 的地方通过@Autowired方式将可以注入接口实例--&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="sqlSessionFactory" ref="sqlSessionFactory"/&gt; &lt;property name="basePackage" value="cn.ustb.scm.dao"/&gt; &lt;/bean&gt; spring-mvc.xml 1234567&lt;!-- 扫描所有的controller 但是不扫描service --&gt; &lt;context:component-scan base-package="cn.ustb"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller" /&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Service" /&gt; &lt;/context:component-scan&gt; 修改sql映射文件中命名空间1&lt;mapper namespace="cn.ustb.dao.DeptDao"&gt; 修改各层的调用控制器类通过业务层接口调用业务层，业务层再通过dao接口（可删除dao实现类，及测试类）获取代理对象执行相关SQL，进行数据的操作 ED]]></content>
      <categories>
        <category>实用技术</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>MVC框架</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC学习笔记（二）]]></title>
    <url>%2F2019%2F02%2F14%2FSpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SpringMVC学习笔记（二）综合示例，文件上传，自定义拦截器，json交互个人笔记，如有错误，恳请批评指正。 综合示例（springmvc文件上传）multipartResolver使用spring-mvc.xml文件添加如下内容： 12345&lt;!--文件上传使用， 配置multipartResolver，id名为约定好的 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt;&lt;!-- 配置文件（每次上传的所有文件总大小)大小，单位为b, 1024000表示1000kb --&gt; &lt;property name="maxUploadSize" value="1024000" /&gt; &lt;/bean&gt; 中文乱码处理web.xml文件添加如下内容： 123456789101112&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;&lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-v alue&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 如果上边的方式设置后，仍然有乱码，请尝试修改tomcat安装目录下的apache-tomcat安装目录\conf\server.xml文件，修改Connector元素内容,添加URIEncoding=”UTF-8” ,修改后内容 如下： 123&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" URIEncoding="UTF-8"/&gt; properties文件信息注入PropertiesFactoryBean：用来注入properties类型的配置文件信息 1234&lt;!--PropertiesFactoryBean对properties文件可用 ，可以用来注入properties配置文件的信息 --&gt; &lt;bean id="uploadProperties" class="org.springframework.beans.factory.config.PropertiesFactoryBean"&gt; &lt;property name="location" value="classpath:xxxxx.properties"&gt;&lt;/property&gt; &lt;/bean&gt; 文件上传示例导入包继续使用上一章节代码，并导入文件上传需要的jar包：commons-fileupload-1.2.2.jar, commons-io-2.0.1.jar 修改student实体类，添加文件类型属性12345678910public class Student implements Serializable &#123; private static final long serialVersionUID = -5304386891883937131L; private Integer stuId; private String stuName; private String stuPwd; private Integer stuAge; private MultipartFile[] files; ......&#125; 编写上传页面12345678910111213141516&lt;%@ page language="java" import="java.util.*" pageEncoding="utf-8"%&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;My JSP 'index.jsp' starting page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="student/save.action" method="post" enctype="multipart/form-data"&gt; 姓名：&lt;input type="text" name="stuName"&gt;&lt;br/&gt; 密码&lt;input type="password" name="stuPwd"&gt;&lt;br&gt; 请选择文件：&lt;br/&gt;&lt;input type="file" name="files"&gt;&lt;br/&gt; &lt;input type="file" name="files"&gt;&lt;br/&gt; &lt;input type="submit" value="文件上传测试"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 编写控制器StudentAction.java 123456789101112131415161718192021222324252627282930313233@Controller@RequestMapping("/student")public class StudentAction &#123; public StudentAction()&#123; System.out.println("---StudentAction构造方法被调用---"); &#125; @RequestMapping("/save") public String save(Student student) &#123; System.out.println("save方法已注入student对象："+student); MultipartFile[] files=student.getFiles(); for(MultipartFile file:files)&#123; if(file.isEmpty())&#123; System.out.println("文件为空"); &#125;else&#123; System.out.println("文件不为空！"); System.out.println("格式:" + file.getContentType()); System.out.println("原名:" + file.getOriginalFilename()); System.out.println("大小:" + file.getSize()); System.out.println("表单控件的名称" + file.getName()); try &#123; FileUtils.copyInputStreamToFile(file.getInputStream(), new File("e:/testupload/"+file.getOriginalFilename())); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; System.out.println("---调用业务逻辑进行业务处理---"); //直接使用字符串，返回视图，进行结果展现等 return "forward:/jsp/main.jsp"; &#125;&#125; 修改配置文件添加文件处理器CommonsMultipartResolver配置 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd "&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;context:component-scan base-package="*"/&gt; &lt;!--文件上传使用， 配置multipartResolver，id名称为约定好的 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 配置文件（每次上传的所有文件总大小)大小,单位为b, 1024000表示1000kb --&gt; &lt;property name="maxUploadSize" value="1024000" /&gt; &lt;/bean&gt;&lt;/beans&gt; 编写处理完后跳转的页面main.jsp 1234567891011&lt;%@ page language="java" import="java.util.*" pageEncoding="utf-8"%&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;main.jsp&lt;/title&gt; &lt;/head&gt; &lt;body&gt; /jsp/main.jsp页面 student： $&#123;requestScope.student&#125; &lt;/body&gt;&lt;/html&gt; 文件存放于tomcat目录下处理方式 在项目目录下新建upload文件夹  修改StudentAction.java。 123456789101112131415161718192021222324252627282930313233343536373839@Controller@RequestMapping("/student")public class StudentAction &#123; public StudentAction()&#123; System.out.println("---StudentAction构造方法被调用---"); &#125; @Resource ServletContext application; @RequestMapping("/save") public String save(Student student) &#123; System.out.println("save方法已注入student对象："+student); MultipartFile[] files=student.getFiles(); System.out.println("真实路径："+application.getRealPath("/")); for(MultipartFile file:files)&#123; if(file.isEmpty())&#123; System.out.println("文件为空"); &#125;else&#123; System.out.println("文件不为空！"); System.out.println("格式:" + file.getContentType()); System.out.println("原名:" + file.getOriginalFilename()); System.out.println("大小:" + file.getSize()); System.out.println("表单控件的名称" + file.getName()); try &#123; FileUtils.copyInputStreamToFile(file.getInputStream(), new File(application.getRealPath("/")+"upload/"+file.getOriginalFilename())); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; System.out.println("---调用业务逻辑进行业务处理---"); //直接使用字符串，返回视图，进行结果展现等 return "forward:/jsp/main.jsp"; &#125;&#125; 其它代码同上一章节，可以在application.getRealPath(“/“)+”upload/“目录下查看到文件。 文件上传优化编写文件上传工具类FileUploadUtil.java 12345678910111213141516171819202122232425262728293031323334353637@Component(value="fileUploadUtils") //普通的bean注入public class FileUploadUtils &#123; /* * 注入字符串,#&#123;&#125;为spel语言，其中uploadProperties，是xml配置文件中注入properties文件的bean id， * path为properties文件的其中一个key ，也可以通过下边的set方法注入 */ @Value("#&#123;uploadProperties.path&#125;") private String path; //private String path="e:/testupload"; //path也可以通过set方法注入// @Value("#&#123;uploadProperties.path&#125;") // public void setPath(String path) &#123;// this.path = path;// &#125; private String getExtName(MultipartFile file)&#123; return FilenameUtils.getExtension(file.getOriginalFilename()); &#125; private String createNewName(MultipartFile file)&#123; return UUID.randomUUID().toString()+"."+getExtName(file); &#125; public String uploadFile(MultipartFile file)&#123; try &#123; String newName=createNewName(file); FileUtils.copyInputStreamToFile(file.getInputStream(), new File(path,newName )); return newName; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); throw new RuntimeException(e); &#125; &#125;&#125; 修改StudentAction.java主要修改save方法，使用自已的文件上传工具类进行文件上传。 1234567891011121314151617181920212223242526272829303132@Controller@RequestMapping(value="/student")public class StudentAction &#123; @Resource private ServletContext application; @Resource private FileUploadUtils fileUploadUtils; public StudentAction()&#123; System.out.println("---StudentAction构造方法被调用---"); &#125; @RequestMapping(value="/save") public String save(Student student,Map&lt;String, Student&gt; paramMap) &#123; System.out.println("save方法已注入student对象："+student); MultipartFile[] files=student.getFiles(); for(MultipartFile file:files)&#123; if(file.isEmpty())&#123; System.out.println("文件为空"); &#125;else&#123; System.out.println("文件不为空！"); fileUploadUtils.uploadFile(file); &#125; &#125; System.out.println("---调用业务逻辑进行业务处理---"); paramMap.put("student",student); //直接使用字符串，返回视图，进行结果展现等 return "forward:/jsp/main.jsp"; &#125;&#125; 添加upload.properties文件配置文件上传后的存放目录 1path=e\:\\testdir\\upload\\ 修改spring-mvc.xml配置文件注入配置文件的信息 1234&lt;!--PropertiesFactoryBean对properties文件可用 ，可以用来注入properties配置文件的信息 --&gt; &lt;bean id="uploadProperties" class="org.springframework.beans.factory.config.PropertiesFactoryBean"&gt; &lt;property name="location" value="classpath:upload.properties"&gt;&lt;/property&gt; &lt;/bean&gt; 综合示例（登陆）拦截器使用编写拦截器类LoginInterceptor.java，需要实现HandlerInterceptor接口 123456789101112131415161718192021222324public class LoginInterceptor implements HandlerInterceptor &#123; @Override public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) throws Exception &#123; // TODO Auto-generated method stub System.out.println("---访问请求资源后不管理有没有异常都一定执行此方法---"); &#125; @Override public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3) throws Exception &#123; // TODO Auto-generated method stub System.out.println("---访问请求资源后，如果没有异常，将执行此方法---"); &#125; @Override public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2) throws Exception &#123; // TODO Auto-generated method stub System.out.println("---访问请求资源前执行，如果此方法返回false，将不能访问请求资源---"); return true; &#125;&#125; 配置文件中添加拦截器12345&lt;!-- 配置spring mvc拦截器 --&gt; &lt;mvc:interceptors&gt; &lt;!-- 默认拦截DispatcherServlet指定的后缀（这里是.action） --&gt; &lt;bean class="cn.itcast.interceptor.LoginInterceptor"/&gt; &lt;/mvc:interceptors&gt; 登陆示例编写及配置拦截器添加拦截器类及拦截器配置信息，如上面。 修改拦截器类preHandle方法1234567891011@Override public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2) throws Exception &#123; // TODO Auto-generated method stub System.out.println("---访问请求资源前执行，如果此方法返回false，将不能访问请求资源---"); if(arg0.getSession().getAttribute("user")==null)&#123; arg1.sendRedirect(arg0.getContextPath()+"/login.jsp"); return false; &#125; return true; &#125; 编写登陆页面login.jsp,本页面已模仿了登陆 1234567891011121314&lt;%@page import="cn.itcast.entity.Student"%&gt;&lt;%@ page language="java" import="java.util.*" pageEncoding="utf-8"%&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;My JSP 'index.jsp' starting page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% session.setAttribute("user", new Student(1001,"zcf","admin",20)); %&gt; &lt;!-- 这里正常应该跳到action再到页面 ,为了演示，这里简略--&gt; &lt;a href="index.jsp"&gt;已登陆，返回首页&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; json交互使用上面的源码，暂时去掉拦截器的登陆权限处理 导入json包及jquery的js文件修改action文件123456789101112131415@Controller@RequestMapping(value="/student")public class StudentAction &#123; public StudentAction()&#123; System.out.println("---StudentAction构造方法被调用---"); &#125; @RequestMapping("/doAjax") @ResponseBody //如果返回json格式，需要这个注解 public Object doAjax(Student student)&#123; System.out.println("---doAjax.student:"+student); student.setStuName("1001name"); return student; &#125;&#125; 修改访问页面1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;% pageContext .setAttribute("basePath", request.getContextPath() + "/");%&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;script type="text/javascript" src="$&#123;basePath &#125;js/jquery/jquery-1.3.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function() &#123; $("#login").click(function() &#123; $.ajax(&#123; url : "student/doAjax.action", type : "post", dataType : "json", data : &#123; "stuName" : "sss", "stuPwd" : "sss" &#125;, success : function(ajax) &#123; alert(ajax.stuName + ajax.stuPwd); &#125; &#125;); &#125;); &#125;); $( function()&#123; $("#bt1").click( function()&#123; $.post( "student/doAjax.action", &#123;stuName:"name1001",stuPwd:"pwd1001"&#125;, function(json)&#123;alert(json.stuName+"||"+json.stuPwd);&#125;, "json" ); &#125; ); &#125; ); &lt;/script&gt;&lt;body&gt; &lt;button id="login"&gt;testajax&lt;/button&gt; &lt;button id="bt1"&gt;testajax&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>实用技术</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>MVC框架</tag>
        <tag>注解</tag>
      </tags>
  </entry>
</search>
