<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java,核心技术,多线程,">










<meta name="description" content="Java核心技术（卷一）（第十四章 线程） 个人笔记，如有错误，恳请批评指正。  并发执行的进程数并不是由CPU数目制约的，操作系统将CPU的时间片分配给每一个进程，给人以并行处理的感觉。 多线程和多进程的区别：每个进程都拥有一整套自己的变量，而线程则共享数据。然而，共享变量使线程之间的通信比进程之间的通信更有效、更容易。  14.1 实现线程的方式方式1、继承Thread方式2、实现Runnab">
<meta name="keywords" content="Java,核心技术,多线程">
<meta property="og:type" content="article">
<meta property="og:title" content="Java核心技术（卷一）（第十四章 线程）">
<meta property="og:url" content="http://yoursite.com/2019/02/01/Java核心技术（卷一）（第十四章 线程）/index.html">
<meta property="og:site_name" content="Wch&#39;s blog">
<meta property="og:description" content="Java核心技术（卷一）（第十四章 线程） 个人笔记，如有错误，恳请批评指正。  并发执行的进程数并不是由CPU数目制约的，操作系统将CPU的时间片分配给每一个进程，给人以并行处理的感觉。 多线程和多进程的区别：每个进程都拥有一整套自己的变量，而线程则共享数据。然而，共享变量使线程之间的通信比进程之间的通信更有效、更容易。  14.1 实现线程的方式方式1、继承Thread方式2、实现Runnab">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://oli0whb3w.bkt.clouddn.com/timsfdwfwfwfwg.jpg">
<meta property="og:updated_time" content="2017-03-19T07:49:45.120Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java核心技术（卷一）（第十四章 线程）">
<meta name="twitter:description" content="Java核心技术（卷一）（第十四章 线程） 个人笔记，如有错误，恳请批评指正。  并发执行的进程数并不是由CPU数目制约的，操作系统将CPU的时间片分配给每一个进程，给人以并行处理的感觉。 多线程和多进程的区别：每个进程都拥有一整套自己的变量，而线程则共享数据。然而，共享变量使线程之间的通信比进程之间的通信更有效、更容易。  14.1 实现线程的方式方式1、继承Thread方式2、实现Runnab">
<meta name="twitter:image" content="http://oli0whb3w.bkt.clouddn.com/timsfdwfwfwfwg.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/02/01/Java核心技术（卷一）（第十四章 线程）/">





  <title>Java核心技术（卷一）（第十四章 线程） | Wch's blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Wch's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">勿忘初心</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/01/Java核心技术（卷一）（第十四章 线程）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tangwenchuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wch's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java核心技术（卷一）（第十四章 线程）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-01T17:08:21+08:00">
                2019-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/Java核心技术/" itemprop="url" rel="index">
                    <span itemprop="name">Java核心技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Java核心技术（卷一）（第十四章-线程）"><a href="#Java核心技术（卷一）（第十四章-线程）" class="headerlink" title="Java核心技术（卷一）（第十四章 线程）"></a>Java核心技术（卷一）（第十四章 线程）</h1><hr>
<p><em>个人笔记，如有错误，恳请批评指正。</em></p>
<ul>
<li>并发执行的进程数并不是由CPU数目制约的，操作系统将CPU的时间片分配给每一个进程，给人以并行处理的感觉。</li>
<li>多线程和多进程的区别：每个进程都拥有一整套自己的变量，而线程则共享数据。然而，共享变量使线程之间的通信比进程之间的通信更有效、更容易。</li>
</ul>
<h3 id="14-1-实现线程的方式"><a href="#14-1-实现线程的方式" class="headerlink" title="14.1 实现线程的方式"></a>14.1 实现线程的方式</h3><p>方式1、继承Thread<br>方式2、实现Runnable接口，作为参数传递入Thread的构造函数。<br>P627中提到：</p>
<blockquote>
<p>继承的方式不再推荐，应该从运行机制上减少需要并行运行的任务数量，如果有很多的任务，要为每个任务创建一个独立的线程所付出的代价太大了。可以使用线程池解决这个问题。</p>
</blockquote>
<p>继承的方法不再推荐，理由是Java是单继承、多实现的，况且，在多任务的情况下，每个任务对应一个线程，如果是继承的方式，需要创建多个对象，况且实现的对象不利于线程池。</p>
<h3 id="14-2-中断线程"><a href="#14-2-中断线程" class="headerlink" title="14.2 中断线程"></a>14.2 中断线程</h3><p>当线程run方法中顺利执行完毕时，这个线程将会终止。在Java的早起版本中，有手动的<code>stop()</code>方法终止线程，但是现已被启用。具体原因是stop方法天生就不安全，该方法视图终止所有未结束的方法，包括run方法。当线程被终止时，立即释放锁对象，此时别的线程会有机会执行，这会导致操作对象的不一致。</p>
<p><strong>没有可以强制终止线程的方法</strong>，但是<code>interrupt()</code>用来请求终止线程，当对某个线程使用该方法时，线程中的<code>中断状态</code>将会被置位，这是每个线程都具有的boolean状态。每个线程都应该不时的检查这个标志，以判断线程是否被终止。</p>
<p>检测是否处于中断状态，使用<code>isInterrupted()</code>;<strong>对一个阻塞的进程</strong>（wait或sleep）的进程使用会抛出InterruptedException异常。</p>
<p>被中断的进程不一定会终止，某些进程很重要，处理完异常后继续执行不会终止。更普遍的情况是线程将简单的中断作为一个终止的请求。</p>
<p><code>interrupted</code>和<code>isInterrupted</code>方法的区别：两者都可以查看当前进程的中断状态，后者不会改变当前进程的中断状态。</p>
<h3 id="14-3-线程状态"><a href="#14-3-线程状态" class="headerlink" title="14.3 线程状态"></a>14.3 线程状态</h3><ul>
<li>新建状态(New)：<br>当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 当一个线程处于新生状态时，程序还没有开始运行线程中的代码。</li>
<li>可运行线程（Runnable）：一个可运行状态线程可能正在运行也可能没有运行。运行与否取决于线程调度，线程调度的细节依赖于操作系统提供的服务，分为<code>抢占式调度</code>和<code>协作式调度</code>。抢占式调度给每个可运行线程一个时间片来运行，时间到，进程之间进行竞争，Java进程之间存在优先级的概念，优先级从1开始到10，依次升高。但是优先级在操作系统上存在映射，Windows只有7个优先级，Linux则不存在优先级。现在所有的桌面和服务器操作系统都采取抢占式调度；手机小型设备做协作式调度，在这样的设备中，进程只有采用yield、或者被阻塞、等待时才会失去控制权。</li>
<li>运行状态(Running)<br>当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法.</li>
<li><p>阻塞状态(Blocked)</p>
<pre><code>线程运行过程中，可能由于各种原因进入阻塞状态:
1. 线程通过调用sleep方法进入睡眠状态；
2. 线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；
3. 线程试图得到一个锁，而该锁正被其他线程持有；
4. 线程在等待某个触发条件；
......           
</code></pre><p>所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。</p>
</li>
<li><p>死亡状态(Dead)<br>有两个原因会导致线程死亡：</p>
<pre><code>1.  run方法正常退出而自然死亡，
2.  一个未捕获的异常终止了run方法而使线程猝死。
</code></pre><p>为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法。如果是可运行或被阻塞，这个方法返回true； 如果线程仍旧是new状态且不是可运行的， 或者线程死亡了，则返回false。</p>
</li>
</ul>
<h4 id="线程状态关系图如下："><a href="#线程状态关系图如下：" class="headerlink" title="线程状态关系图如下："></a>线程状态关系图如下：</h4><p><img src="http://oli0whb3w.bkt.clouddn.com/timsfdwfwfwfwg.jpg" alt="enter image description here"></p>
<h3 id="14-4-线程属性"><a href="#14-4-线程属性" class="headerlink" title="14.4 线程属性"></a>14.4 线程属性</h3><p>属性包括：线程优先级、守护线程、线程组以及处理为<code>捕获异常的处理器</code>。</p>
<h4 id="14-4-1-线程优先级"><a href="#14-4-1-线程优先级" class="headerlink" title="14.4.1 线程优先级"></a>14.4.1 线程优先级</h4><p>priority，不要过度使用优先级。不同系统对优先级的支持不一样。<br><strong>API</strong><br><code>static void yield()</code>:导致当前的进程做出让步，同优先级或以上的进程会被调度。</p>
<h4 id="14-4-2-守护线程"><a href="#14-4-2-守护线程" class="headerlink" title="14.4.2 守护线程"></a>14.4.2 守护线程</h4><p>为其他线程服务的线程，<code>t.setDaemon(true)</code>;守护线程不能访问固有资源，如文件、数据库，因为它可能在任何时候甚至在一个操作的中间发生中断。setDaemon方法必须在线程启动之前调用。</p>
<h4 id="14-4-3-未捕获异常处理器"><a href="#14-4-3-未捕获异常处理器" class="headerlink" title="14.4.3 未捕获异常处理器"></a>14.4.3 未捕获异常处理器</h4><p>待详细了解</p>
<h3 id="14-5-同步"><a href="#14-5-同步" class="headerlink" title="14.5 同步"></a>14.5 同步</h3><p>多个线程同时操作同一资源，会产生竞争条件（race condition）。<br>下面用一个银行转账的例程来演示线程安全问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 银行对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Wch</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] accounts;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> initBalance)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.accounts = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">			accounts[i] = initBalance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from ,<span class="keyword">int</span> to,<span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(amount&gt;accounts[from])</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(from == <span class="number">0</span>||to == <span class="number">0</span> )</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		accounts[from-<span class="number">1</span>] -= amount;</span><br><span class="line">		System.out.printf(<span class="string">"从账户%1$d转了%3$d元到账户%2$d"</span>,from,to,amount);</span><br><span class="line">		accounts[to-<span class="number">1</span>] += amount;</span><br><span class="line">		System.out.printf(<span class="string">"银行里的总钱数有%d元"</span>,getTotalBalance());</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getTotalBalance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;accounts.length;i++)</span><br><span class="line">			total += accounts[i];</span><br><span class="line">		<span class="keyword">return</span> total;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Bank b = <span class="keyword">new</span> Bank(<span class="number">100</span>, <span class="number">5000</span>);</span><br><span class="line">		b.transfer(<span class="number">1</span>, <span class="number">2</span>, <span class="number">200</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> accounts.length;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Bank bank;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> from;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxAmount;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> delay = <span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TransferRunnable</span><span class="params">(Bank bank, <span class="keyword">int</span> from, <span class="keyword">int</span> maxAmount)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.bank = bank;</span><br><span class="line">		<span class="keyword">this</span>.from = from;</span><br><span class="line">		<span class="keyword">this</span>.maxAmount = maxAmount;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">int</span> amount = (<span class="keyword">int</span>) (maxAmount*Math.random());</span><br><span class="line">				<span class="keyword">int</span> to = (<span class="keyword">int</span>) (bank.size()*Math.random());</span><br><span class="line">				bank.transfer(from, to, amount);</span><br><span class="line">				Thread.sleep((<span class="keyword">long</span>) (delay*Math.random()));</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Bank b = <span class="keyword">new</span> Bank(<span class="number">100</span>, <span class="number">5000</span>);</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">			TransferRunnable t = <span class="keyword">new</span> TransferRunnable(b, i, <span class="number">100</span>);</span><br><span class="line">			Thread t2 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">			t2.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">银行的总金额发生了混乱：</span><br><span class="line">从账户<span class="number">36</span>转了<span class="number">72</span>元到账户<span class="number">9</span>银行里的总钱数有<span class="number">500032</span>元</span><br><span class="line">银行里的总钱数有<span class="number">499863</span>元</span><br><span class="line">从账户<span class="number">76</span>转了<span class="number">51</span>元到账户<span class="number">5</span>银行里的总钱数有<span class="number">500032</span>元</span><br><span class="line">从账户<span class="number">45</span>转了<span class="number">3</span>元到账户<span class="number">58</span>银行里的总钱数有<span class="number">500032</span>元</span><br><span class="line">从账户<span class="number">13</span>转了<span class="number">57</span>元到账户<span class="number">51</span>银行里的总钱数有<span class="number">500032</span>元</span><br><span class="line">从账户<span class="number">21</span>转了<span class="number">45</span>元到账户<span class="number">80</span>银行里的总钱数有<span class="number">500032</span>元</span><br><span class="line">从账户<span class="number">86</span>转了<span class="number">34</span>元到账户<span class="number">89</span>银行里的总钱数有<span class="number">500032</span>元</span><br><span class="line">从账户<span class="number">16</span>转了<span class="number">57</span>元到账户<span class="number">59</span>银行里的总钱数有<span class="number">500032</span>元</span><br><span class="line">从账户<span class="number">68</span>转了<span class="number">91</span>元到账户<span class="number">28</span>银行里的总钱数有<span class="number">500032</span>元</span><br><span class="line">从账户<span class="number">26</span>转了<span class="number">34</span>元到账户<span class="number">9</span>银行里的总钱数有<span class="number">500019</span>元</span><br><span class="line">从账户<span class="number">52</span>转了<span class="number">13</span>元到账户<span class="number">93</span>银行里的总钱数有<span class="number">500032</span>元</span><br><span class="line">从账户<span class="number">78</span>转了<span class="number">9</span>元到账户<span class="number">17</span>银行里的总钱数有<span class="number">499967</span>元</span><br><span class="line">从账户<span class="number">85</span>转了<span class="number">65</span>元到账户<span class="number">90</span>银行里的总钱数有<span class="number">500032</span>元</span><br><span class="line">从账户<span class="number">12</span>转了<span class="number">1</span>元到账户<span class="number">54</span>银行里的总钱数有<span class="number">499924</span>元</span><br><span class="line">从账户<span class="number">89</span>转了<span class="number">90</span>元到账户<span class="number">40</span>银行里的总钱数有<span class="number">500014</span>元</span><br><span class="line">从账户<span class="number">66</span>转了<span class="number">18</span>元到账户<span class="number">23</span>银行里的总钱数有<span class="number">500032</span>元</span><br><span class="line">从账户<span class="number">18</span>转了<span class="number">16</span>元到账户<span class="number">19</span>银行里的总钱数有<span class="number">499931</span>元</span><br><span class="line">从账户<span class="number">43</span>转了<span class="number">11</span>元到账户<span class="number">60</span>银行里的总钱数有<span class="number">499942</span>元</span><br><span class="line">从账户<span class="number">39</span>转了<span class="number">43</span>元到账户<span class="number">52</span>银行里的总钱数有<span class="number">499985</span>元</span><br><span class="line">从账户<span class="number">67</span>转了<span class="number">47</span>元到账户<span class="number">83</span>银行里的总钱数有<span class="number">500032</span>元</span><br><span class="line">从账户<span class="number">81</span>转了<span class="number">69</span>元到账户<span class="number">12</span>银行里的总钱数有<span class="number">499937</span>元</span><br><span class="line">从账户<span class="number">47</span>转了<span class="number">95</span>元到账户<span class="number">89</span>银行里的总钱数有<span class="number">500032</span>元</span><br></pre></td></tr></table></figure>
<p>原因：transfer操作非原子操作，执行到任何一步都可能被剥夺运行权。</p>
<h3 id="线程问题的解决办法"><a href="#线程问题的解决办法" class="headerlink" title="线程问题的解决办法"></a>线程问题的解决办法</h3><h4 id="14-5-3-锁对象"><a href="#14-5-3-锁对象" class="headerlink" title="14.5.3 锁对象"></a>14.5.3 锁对象</h4><p>显式锁对象 <code>ReentrantLock</code>类，存在于<code>java.util.concurrent</code>框架中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();<span class="comment">//显示锁对象</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...java</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from ,<span class="keyword">int</span> to,<span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">		lock.lock();<span class="comment">//锁住</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(amount&gt;accounts[from])</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">if</span>(from == <span class="number">0</span>||to == <span class="number">0</span> )</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			accounts[from-<span class="number">1</span>] -= amount;</span><br><span class="line">			System.out.printf(<span class="string">"从账户%1$d转了%3$d元到账户%2$d"</span>,from,to,amount);</span><br><span class="line">			accounts[to-<span class="number">1</span>] += amount;</span><br><span class="line">			System.out.printf(<span class="string">"银行里的总钱数有%d元"</span>,getTotalBalance());</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">			lock.unlock();<span class="comment">//解锁，必须保证会执行，否则程序会挂起</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>注意：如果使用了锁，就不能使用带资源的try语句，关于带资源的trry语句详解见：<a href="http://blog.csdn.net/u012421846/article/details/46129237" target="_blank" rel="noopener">http://blog.csdn.net/u012421846/article/details/46129237</a></p>
<p>当线程访问同一对象（此处是bank）中的锁对象时，锁以串行的方式提供服务。如果访问不同对象的锁对象，不会发生阻塞。</p>
<p><strong>锁是可重入的</strong>，线程可以重复获取已经持有的锁。所保持有一个持有计数（hold count）<code>getHoldCount()</code>来跟踪对lock方法的嵌套调用。线程在每一次调用lock都要调用unlock来释放锁，由于这一特性，被一个锁保护的代码可以调用另一个使用相同锁的方法。</p>
<p><strong>警告：</strong>临界区中的代码不能因为异常的抛出提前退出临界区，如果这样，finally会提前释放锁，而不完整的修改会使对象处于一种受损状态。以下的代码说明了这种情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from ,<span class="keyword">int</span> to,<span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">		lock.lock();<span class="comment">//锁住</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(amount&gt;accounts[from])</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">if</span>(from == <span class="number">0</span>||to == <span class="number">0</span> )</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			accounts[from-<span class="number">1</span>] -= amount;</span><br><span class="line">			System.out.printf(<span class="string">"从账户%1$d转了%3$d元到账户%2$d"</span>,from,to,amount);</span><br><span class="line">			</span><br><span class="line">			System.out.println(<span class="number">1</span>/(<span class="keyword">int</span>)(Math.random()*<span class="number">10</span>));<span class="comment">//临界区的代码不能因为异常提前退出，否则会对对象有损</span></span><br><span class="line">			</span><br><span class="line">			accounts[to-<span class="number">1</span>] += amount;</span><br><span class="line">			System.out.println(<span class="string">"持有计数"</span>+lock.getHoldCount());</span><br><span class="line">			System.out.printf(<span class="string">"银行里的总钱数有%d元"</span>,getTotalBalance());</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();<span class="comment">//捕获的是java.lang.ArithmeticException: / by zero</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span>&#123;</span><br><span class="line">			lock.unlock();<span class="comment">//解锁，必须保证会执行，否则程序会挂起</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">运行结果：<span class="comment">//出错就会使bank对象受损！</span></span><br><span class="line">	从账户<span class="number">18</span>转了<span class="number">40</span>元到账户<span class="number">460</span></span><br><span class="line">	持有计数<span class="number">1</span></span><br><span class="line">	transfer中的持有计数<span class="number">2</span></span><br><span class="line">	银行里的总钱数有<span class="number">500000</span>元</span><br><span class="line">	从账户<span class="number">19</span>转了<span class="number">65</span>元到账户<span class="number">14</span>java.lang.ArithmeticException: / by zero</span><br><span class="line">		at cn.ustb.chapter14.bank.Bank.transfer(Bank.java:<span class="number">31</span>)</span><br><span class="line">		at cn.ustb.chapter14.bank.TransferRunnable.run(TransferRunnable.java:<span class="number">27</span>)</span><br><span class="line">		at java.lang.Thread.run(Thread.java:<span class="number">744</span>)</span><br><span class="line">	从账户<span class="number">20</span>转了<span class="number">80</span>元到账户<span class="number">610</span></span><br><span class="line">	持有计数<span class="number">1</span></span><br><span class="line">	transfer中的持有计数<span class="number">2</span></span><br><span class="line">	银行里的总钱数有<span class="number">499935</span>元</span><br></pre></td></tr></table></figure>
<p><strong>API</strong></p>
<ul>
<li>lock()</li>
<li>unLock()</li>
<li>ReentrantLock()</li>
<li>ReentrantLock(boolean fair)//是否启用带有公平策略的锁，这将大大降低性能，并且也不能保证线程调度器是公平的。</li>
</ul>
<h4 id="14-5-4-条件对象"><a href="#14-5-4-条件对象" class="headerlink" title="14.5.4 条件对象"></a>14.5.4 条件对象</h4><p>当进入临界区以后又发现某些条件不能满足执行条件时，用到条件对象。<br><code>Condition condition = lock.newCondition()</code>获取条件对象。当不满足执行条件时，使用condition.await();放弃当前锁，这时候其他线程可以对对象进行操作，当之前进程再次满足执行条件时<strong>且另外的进程调用了signalAll()方法时</strong>，改线程被激活。原来，原线程在condition.await()之后进入了该条件的等待集，在别的进程中condition.signalAll()之后，重新激活了因为这一条件而等待的所有线程。这些进程再次成为可运行的，调度器再次激活他们，获取锁对象的进程从<strong>被阻塞的地方重新执行</strong>，此时应该重新检测是否满足条件，signalAll仅仅是通知正在等待的线程：此时可能已经满足了执行条件。</p>
<p>通常，对await的调用应该在如下的循环体中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!(ok to process))</span><br><span class="line">	condition.await();</span><br></pre></td></tr></table></figure></p>
<p>如果一个线程始终没有被signal，它将始终处于阻塞。条件对象可能会引起死锁，调用signalAll的时机是：在对象的状态有利于等待线程的方向改变时调用signalAll()。</p>
<h4 id="14-5-5-synchronized关键字"><a href="#14-5-5-synchronized关键字" class="headerlink" title="14.5.5 synchronized关键字"></a>14.5.5 synchronized关键字</h4><p>一种嵌入到Java语言内部的机制，从1.0开始，Java中的每一个对象都有一个内部锁，如果一个方法用synchronized关键字声明<br>可对方法和代码块进行同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from ,<span class="keyword">int</span> to,<span class="keyword">int</span> amount)</span></span>&#123;&#125;</span><br><span class="line">or</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (amount &gt; accounts[from])</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">if</span> (from == <span class="number">0</span> || to == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">while</span> (accounts[from] &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">				System.out.printf(<span class="string">"账户%d余额不足1000，等待充值"</span>, from);</span><br><span class="line">				System.out.println();</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					wait();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			accounts[from - <span class="number">1</span>] -= amount;</span><br><span class="line">			System.out.print(Thread.currentThread());</span><br><span class="line">			System.out.printf(<span class="string">"从账户%1$d转了%3$d元到账户%2$d"</span>, from, to, amount);</span><br><span class="line">			accounts[to - <span class="number">1</span>] += amount;</span><br><span class="line">			System.out.printf(<span class="string">"银行里的总钱数有%d元"</span>, getTotalBalance());</span><br><span class="line">			System.out.println();</span><br><span class="line">			notifyAll();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>使用synchronized比显式锁和条件来同步的方式要简洁很多，每一个对象都有一个内部锁，并且该内部锁有一个内部条件。由锁管理试图进入synchronized方法的线程，由条件来管理那些调用wait的线程。</p>
<p><code>wait、notifyAll</code>以及<code>notify</code>方法是Object中的final方法。只可以在一个同步方法或者同步代码块中调用，如果当前的线程不是对象锁的持有者，改方法都会抛出<code>IllegalMonitorStateException</code>的异常。</p>
<h4 id="14-5-8-Volatile域"><a href="#14-5-8-Volatile域" class="headerlink" title="14.5.8 Volatile域"></a>14.5.8 Volatile域</h4><p>现代的处理器与编译器中：</p>
<ul>
<li>多处理器的计算机能够暂时在寄存器或本地缓存中保存内存中值，导致的结果是：不同处理器的线程可能在同一内存位置取到不同的值。</li>
<li>编译器可以改变指令的顺序使吞吐量最大化。这也会导致错误的发生。</li>
</ul>
<p>锁的机制是让编译器在必要的时候刷新本地缓存来保持锁定的效应，并且不能不正当的重新排序指令。</p>
<p>volatile关键字为实例域的同步访问提供了一种免锁机制，如果声明为volitale，编译器和虚拟机默认该域可能被另一个进程并发更新的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span>  <span class="keyword">int</span>[] accounts;<span class="comment">//用volitale声明了account数组，然而并没有什么卵用，原因是transfer对其进行了非原子性操作，破坏了对象的状态。</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> initBalance)</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> amount)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getTotalBalance</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>警告</strong>：Volatile变量不能提供原子性，其仅适合于get or set操作，不适合getAndOperate操作。</p>
<p>Volitale在执行时插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。内存屏障另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。<br>更详细的解析见：<a href="http://blog.csdn.net/hupitao/article/details/45227891" target="_blank" rel="noopener">http://blog.csdn.net/hupitao/article/details/45227891</a></p>
<h4 id="final变量、原子性、死锁"><a href="#final变量、原子性、死锁" class="headerlink" title="final变量、原子性、死锁"></a>final变量、原子性、死锁</h4><p>final用于声明安全访问的共享域。<br>原子性指java.util.concurrent.atomic框架中一些高级指令，他们将一些简单的自增自减变为原子操作。<br>死锁，线程之间的相互等待、或者互不相让的一种状态。</p>
<h4 id="14-5-12-线程局部变量"><a href="#14-5-12-线程局部变量" class="headerlink" title="14.5.12 线程局部变量"></a>14.5.12 线程局部变量</h4><p>在线程之间共享变量有风险，有时候需要避免共享变量，这是就用到了局部变量。Java中使用ThreadLocal辅助类为各个线程提供各自的实例，不会因为线程导致安全问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThreadLocal&lt;SimpleDateFormat&gt; dateFormat = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out</span><br><span class="line">						.println(<span class="string">"Demo2.main(...).new ThreadLocal() &#123;...&#125;.initialValue()"</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		SimpleDateFormat simpleDateFormat = dateFormat.get();<span class="comment">//get获取线程局部变量对象，线程安全的</span></span><br><span class="line">		SimpleDateFormat simpleDateFormat2 = dateFormat.get();</span><br><span class="line">		System.out.println(simpleDateFormat);</span><br><span class="line">		System.out.println(simpleDateFormat2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在<code>initialValue</code>方法初始化局部变量。在一个给定线程首次调用<code>get</code>方法时，会调用initialValue方法，值调用一次，此后返回的都是同一个线程局部变量，此变量是线程安全的。</p>
<p>14.5.14 读写锁<br>java.uitl.concurrent.locks中定义的ReentrantReadWriteLock类，适用于线程很少修改数据。<br><strong>API</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"><span class="keyword">private</span> Lock readLock = rwl.readLock();<span class="comment">//得到一个可以被多个读操作公用的读锁，但会排斥所有的写操作。</span></span><br><span class="line"><span class="keyword">private</span> Lock writeLock = rwl.writeLock();<span class="comment">//得到一个写锁，排斥所有其他的读操作和写操作。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="关于printf的用法："><a href="#关于printf的用法：" class="headerlink" title="关于printf的用法："></a>关于printf的用法：</h3><p><a href="http://heidian.iteye.com/blog/404632" target="_blank" rel="noopener">http://heidian.iteye.com/blog/404632</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/核心技术/" rel="tag"># 核心技术</a>
          
            <a href="/tags/多线程/" rel="tag"># 多线程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/01/Java核心技术（卷一）（第十三章 集合）/" rel="next" title="Java核心技术（卷一）（第十三章 集合）">
                <i class="fa fa-chevron-left"></i> Java核心技术（卷一）（第十三章 集合）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/01/Java核心技术（卷一）（第十一章 异常、日志和调试）/" rel="prev" title="Java核心技术（卷一）（第十一章 异常、日志和调试）">
                Java核心技术（卷一）（第十一章 异常、日志和调试） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tangwenchuan</p>
              <p class="site-description motion-element" itemprop="description">nothing more</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">54</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">66</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java核心技术（卷一）（第十四章-线程）"><span class="nav-number">1.</span> <span class="nav-text">Java核心技术（卷一）（第十四章 线程）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-1-实现线程的方式"><span class="nav-number">1.0.1.</span> <span class="nav-text">14.1 实现线程的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-中断线程"><span class="nav-number">1.0.2.</span> <span class="nav-text">14.2 中断线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-3-线程状态"><span class="nav-number">1.0.3.</span> <span class="nav-text">14.3 线程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程状态关系图如下："><span class="nav-number">1.0.3.1.</span> <span class="nav-text">线程状态关系图如下：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-4-线程属性"><span class="nav-number">1.0.4.</span> <span class="nav-text">14.4 线程属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#14-4-1-线程优先级"><span class="nav-number">1.0.4.1.</span> <span class="nav-text">14.4.1 线程优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-4-2-守护线程"><span class="nav-number">1.0.4.2.</span> <span class="nav-text">14.4.2 守护线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-4-3-未捕获异常处理器"><span class="nav-number">1.0.4.3.</span> <span class="nav-text">14.4.3 未捕获异常处理器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-5-同步"><span class="nav-number">1.0.5.</span> <span class="nav-text">14.5 同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程问题的解决办法"><span class="nav-number">1.0.6.</span> <span class="nav-text">线程问题的解决办法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#14-5-3-锁对象"><span class="nav-number">1.0.6.1.</span> <span class="nav-text">14.5.3 锁对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-5-4-条件对象"><span class="nav-number">1.0.6.2.</span> <span class="nav-text">14.5.4 条件对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-5-5-synchronized关键字"><span class="nav-number">1.0.6.3.</span> <span class="nav-text">14.5.5 synchronized关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-5-8-Volatile域"><span class="nav-number">1.0.6.4.</span> <span class="nav-text">14.5.8 Volatile域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#final变量、原子性、死锁"><span class="nav-number">1.0.6.5.</span> <span class="nav-text">final变量、原子性、死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-5-12-线程局部变量"><span class="nav-number">1.0.6.6.</span> <span class="nav-text">14.5.12 线程局部变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于printf的用法："><span class="nav-number">1.0.7.</span> <span class="nav-text">关于printf的用法：</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tangwenchuan</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
