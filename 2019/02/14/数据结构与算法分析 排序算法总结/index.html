<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="排序算法,">










<meta name="description" content="数据结构与算法分析 排序算法总结冒泡排序，快速排序，插入排序，希尔排序，简单排序，堆排序，归并排序  之前的记录： 别人家的记录：http://blog.csdn.net/jianyuerensheng/article/details/51258460 各排序算法复杂度比较 冒泡排序 时间复杂度：O(n^2)      空间复杂度：O(1) 没有辅助空间    稳定性：稳定   123456789">
<meta name="keywords" content="排序算法">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法分析 排序算法总结">
<meta property="og:url" content="http://yoursite.com/2019/02/14/数据结构与算法分析 排序算法总结/index.html">
<meta property="og:site_name" content="Wch&#39;s blog">
<meta property="og:description" content="数据结构与算法分析 排序算法总结冒泡排序，快速排序，插入排序，希尔排序，简单排序，堆排序，归并排序  之前的记录： 别人家的记录：http://blog.csdn.net/jianyuerensheng/article/details/51258460 各排序算法复杂度比较 冒泡排序 时间复杂度：O(n^2)      空间复杂度：O(1) 没有辅助空间    稳定性：稳定   123456789">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://oli0whb3w.bkt.clouddn.com/faafdasfsdafwferfgsergserg">
<meta property="og:image" content="http://oli0whb3w.bkt.clouddn.com/faffasfeweffffff">
<meta property="og:updated_time" content="2017-03-30T14:53:27.477Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据结构与算法分析 排序算法总结">
<meta name="twitter:description" content="数据结构与算法分析 排序算法总结冒泡排序，快速排序，插入排序，希尔排序，简单排序，堆排序，归并排序  之前的记录： 别人家的记录：http://blog.csdn.net/jianyuerensheng/article/details/51258460 各排序算法复杂度比较 冒泡排序 时间复杂度：O(n^2)      空间复杂度：O(1) 没有辅助空间    稳定性：稳定   123456789">
<meta name="twitter:image" content="http://oli0whb3w.bkt.clouddn.com/faafdasfsdafwferfgsergserg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":50},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/02/14/数据结构与算法分析 排序算法总结/">





  <title>数据结构与算法分析 排序算法总结 | Wch's blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Wch's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">勿忘初心</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/14/数据结构与算法分析 排序算法总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wch">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wch's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">数据结构与算法分析 排序算法总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-14T16:16:48+08:00">
                2019-02-14
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2017-03-30T22:53:27+08:00">
                2017-03-30
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/数据结构与算法分析/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  21
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="数据结构与算法分析-排序算法总结"><a href="#数据结构与算法分析-排序算法总结" class="headerlink" title="数据结构与算法分析 排序算法总结"></a>数据结构与算法分析 排序算法总结</h1><p><em>冒泡排序，快速排序，插入排序，希尔排序，简单排序，堆排序，归并排序</em></p>
<hr>
<p><a href="http://vsimple.me/2017/03/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%88JAVA%E6%8F%8F%E8%BF%B0%EF%BC%89%EF%BC%88%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E6%8E%92%E5%BA%8F%EF%BC%89/" target="_blank" rel="noopener">之前的记录</a>：</p>
<p>别人家的记录：<br><a href="http://blog.csdn.net/jianyuerensheng/article/details/51258460" target="_blank" rel="noopener">http://blog.csdn.net/jianyuerensheng/article/details/51258460</a></p>
<h3 id="各排序算法复杂度比较"><a href="#各排序算法复杂度比较" class="headerlink" title="各排序算法复杂度比较"></a>各排序算法复杂度比较</h3><p><img src="http://oli0whb3w.bkt.clouddn.com/faafdasfsdafwferfgsergserg" alt="enter image description here"></p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul>
<li>时间复杂度：O(n^2)     </li>
<li>空间复杂度：O(1) 没有辅助空间   </li>
<li>稳定性：稳定 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 冒泡排序是最慢的排序算法。在实际运用中它是效率最低的算法。它通过一趟又一趟地比较数组中的每一个元素，使</span></span><br><span class="line"><span class="comment">	 * 较大的数据下沉，较小的数据上升。它是O(n^2)的算法。</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 步骤： </span></span><br><span class="line"><span class="comment">	 * （1）比较相邻的元素。如果第一个比第二个大，就交换他们两个。</span></span><br><span class="line"><span class="comment">	 * （2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</span></span><br><span class="line"><span class="comment">	 * （3）针对所有的元素重复以上的步骤，除了最后一个。 </span></span><br><span class="line"><span class="comment">	 * （4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 时间复杂度：O(n^2) 空间复杂度：O(1) 没有辅助空间</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = arr.length;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">					<span class="keyword">int</span> temp = arr[j];</span><br><span class="line">					arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">					arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Arrays.toString(arr));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul>
<li>时间复杂度：O(n^2) </li>
<li>空间复杂度：O(1) </li>
<li>稳定性：不稳定</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 选择排序(Selection</span></span><br><span class="line"><span class="comment">	 * sort)是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，</span></span><br><span class="line"><span class="comment">	 * 再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。以此类推，直到所有元素均排序完毕。 这种排序方法效率是</span></span><br><span class="line"><span class="comment">	 * O(n2)。在实际应用中处于和冒泡排序基本相同的地位。它们只是排序算法发展的初级阶段，在实际中使用较少</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 时间复杂度：O(n^2) 空间复杂度：O(1) 稳定性：bu稳定</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = arr.length;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">					<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">					arr[i] = arr[j];</span><br><span class="line">					arr[j] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Arrays.toString(arr));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：稳定</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 插入排序（Insertion</span></span><br><span class="line"><span class="comment">	 * Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描</span></span><br><span class="line"><span class="comment">	 * ，找到相应位置并插入。插入排序在实现上</span></span><br><span class="line"><span class="comment">	 * ，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位</span></span><br><span class="line"><span class="comment">	 * ，为最新元素提供插入空间。</span></span><br><span class="line"><span class="comment">	 * 插入排序是对冒泡排序的改进。它比冒泡排序快2倍。一般不用在数据大于1000的场合下使用插入排序，或者重复排序超过200数据项的序列。 </span></span><br><span class="line"><span class="comment">	 * 步骤：</span></span><br><span class="line"><span class="comment">	 * （1）从第一个元素开始，该元素可以认为已经被排序 </span></span><br><span class="line"><span class="comment">	 * （2）取出下一个元素，在已经排序的元素序列中从后向前扫描</span></span><br><span class="line"><span class="comment">	 * （3）如果该元素（已排序）大于新元素，将该元素移到下一位置 （4）重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置中</span></span><br><span class="line"><span class="comment">	 * （4）重复步骤2</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">	 *            时间复杂度：O(n^2) 空间复杂度：O(1) 直接插入排序法比冒泡和简单选择排序的性能要好一些。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = arr.length;</span><br><span class="line">		<span class="keyword">int</span> j;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> insert = arr[i];<span class="comment">//插入元素位置</span></span><br><span class="line">			<span class="keyword">for</span>(j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>&amp;&amp;insert&lt;arr[j];j--)&#123;<span class="comment">//&#123;2,3,4,5插入1&#125;</span></span><br><span class="line">				arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">			&#125;</span><br><span class="line">			arr[j+<span class="number">1</span>] = insert;<span class="comment">//+1的原因是此时的j不满足insert&lt;arr[j],因此insert插入到j之后的位置</span></span><br><span class="line">			System.out.println(Arrays.toString(arr));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序，也称递减增量排序算法，是插入排序的一种高速而稳定的改进版本。希尔排序是基于插入排序的以下两点性质而提出改进方法的：<br>（1）插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率<br>（2）但插入排序一般来说是低效的， 因为插入排序每次<strong>只能将数据移动一位</strong></p>
<ul>
<li>时间复杂度：O(n logn)</li>
<li>空间复杂度：O(1)</li>
<li>不稳定</li>
</ul>
<p>Shell排序比冒泡排序快5倍，比插入排序大致快2倍。Shell排序比起<strong>QuickSort，MergeSort，HeapSort</strong>慢很多。但是它相对比较简单，它适合于数据量在5000以下并且速度并不是特别重要的场合。它对于数据量较小的数列重复排序是非常好的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 希尔排序：对直接插入排序的升级和优化</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">	 * 时间复杂度:O(n*logn) </span></span><br><span class="line"><span class="comment">	 * 空间复杂度：O(1) </span></span><br><span class="line"><span class="comment">	 * 稳定性：不稳定</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * Shell排序通过将数据分成不同的组，先对每一组进行排序，然后再对所有的元素进行一次插入排序，以减少数据交换和移动的次数。</span></span><br><span class="line"><span class="comment">	 * 平均效率是O(nlogn)。其中分组的合理性会对算法产生重要的影响。现在多用D.E.Knuth的分组方法。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Shell排序比冒泡排序快5倍，比插入排序大致快2倍。Shell排序比起QuickSort，MergeSort，</span></span><br><span class="line"><span class="comment">	 * HeapSort慢很多</span></span><br><span class="line"><span class="comment">	 * 。但是它相对比较简单，它适合于数据量在5000以下并且速度并不是特别重要的场合。它对于数据量较小的数列重复排序是非常好的。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = arr.length;</span><br><span class="line">		<span class="keyword">int</span> step = len/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> j;</span><br><span class="line">		<span class="keyword">while</span>(step&gt;<span class="number">0</span>)&#123;<span class="comment">//最后一个step必须要为1。</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = step;i&lt;len;i++)&#123;<span class="comment">//从第step的元素开始往前插入</span></span><br><span class="line">			<span class="keyword">int</span> temp = arr[i];<span class="comment">//第i个元素作为插入元素，之前i step间隔的元素默认有序，无序则进行交换。</span></span><br><span class="line">			<span class="keyword">for</span>(j = i-step;j&gt;=<span class="number">0</span>&amp;&amp;temp&lt;arr[j];j-=step)&#123;</span><br><span class="line">				arr[j+step] = arr[j];</span><br><span class="line">			&#125;</span><br><span class="line">			arr[j+step] = temp;</span><br><span class="line">			System.out.println(Arrays.toString(arr));</span><br><span class="line">		&#125;</span><br><span class="line">		step /= <span class="number">2</span>;<span class="comment">//缩小增量</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function"><span class="keyword">void</span> <span class="title">shellSort2</span><span class="params">(T[] a)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> j;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> gap = a.length / <span class="number">2</span>; gap &gt;= <span class="number">1</span>; gap /= <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; a.length; i++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (j = i; j - gap &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">					<span class="keyword">if</span> (a[j].compareTo(a[j - gap]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">						T temp = a[j];</span><br><span class="line">						a[j] = a[j - gap];</span><br><span class="line">						a[j - gap] = temp;</span><br><span class="line">					&#125; <span class="keyword">else</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序适合于<strong>数据量非常大的场合</strong>（百万数据）。</p>
<p>堆排序不需要大量的递归或者多维的暂存数组。这对于数据量非常巨大的序列是合适的。比如超过数百万条记录，因为快速排序，归并排序都使用递归来设计算法，在数据量非常大的时候，可能会发生堆栈溢出错误。</p>
<p>堆排序会将所有的数据建成一个堆，最大的数据在堆顶，然后将堆顶数据和序列的最后一个数据交换。接下来再次重建堆，交换数据，依次下去，就可以排序所有的数据。</p>
<h4 id="二叉堆复习"><a href="#二叉堆复习" class="headerlink" title="二叉堆复习"></a>二叉堆复习</h4><p>完全二叉堆这么有规律，所以它可以用一个数组表示而不需要使用链。对于数组中任何一个位置<strong>i</strong>，左儿子为<strong>2i</strong>。右儿子为<strong>2i+1</strong>，父节点在<strong>i/2</strong>的位置。</p>
<p>本例程只学习了小根堆，大根堆是类似的情况。</p>
<p>二叉堆是一个完全的二叉树，其没有儿子的节点只可能出现在末尾处。</p>
<h5 id="上滤"><a href="#上滤" class="headerlink" title="上滤"></a>上滤</h5><p>在insert操作时，采取的是hole上滤操作。上滤是指：<strong>将插入元素放置最后位置，此位置称为空穴，如果该元素能放置该位置而不破坏对的结构，则插入完成，否则，将空穴父节点的元素移入改空穴中，这样，空穴就朝着根的方向上移了一层。直至空穴元素能满足堆结构位置停止上滤</strong>值得注意的是：在父节点移入空穴的过程中，有两种方式，一种是直接和空穴元素交换，需要三步。另一种是直接赋值给空穴元素，空穴元素一直存储到temp中，此种做法只要一步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;<span class="comment">//上滤</span></span><br><span class="line">		<span class="keyword">int</span> hole = ++size;<span class="comment">//从1开始</span></span><br><span class="line">		<span class="keyword">for</span>(;hole&gt;=<span class="number">0</span>&amp;&amp;num&lt;arrays[hole/<span class="number">2</span>];hole /=<span class="number">2</span>)</span><br><span class="line">			arrays[hole] = arrays[hole/<span class="number">2</span>];</span><br><span class="line">		</span><br><span class="line">		arrays[hole] = num;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h5 id="下滤"><a href="#下滤" class="headerlink" title="下滤"></a>下滤</h5><p>deleteMin操作时，采取的是将末尾元素X放入arrays[1]的位置（二叉树的数组从1开始，即堆顶元素下标为1），然后从1位置开始下滤。<strong>下滤就是将空穴的两个儿子的较小者放到空穴，空穴下移一层，最终直至X能放到合适的位置。</strong>具体做法是：将X置入沿着从根开始包含最小儿子的一条路径上的一个正确的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">percDown</span><span class="params">(<span class="keyword">int</span> hole)</span></span>&#123;<span class="comment">//下滤</span></span><br><span class="line">		<span class="keyword">int</span> temp = arrays[hole];</span><br><span class="line">		<span class="keyword">int</span> child;</span><br><span class="line">		<span class="keyword">for</span>(;hole*<span class="number">2</span>&lt;=size;hole =child)&#123;</span><br><span class="line">			child = hole*<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(child!=size&amp;&amp;arrays[child+<span class="number">1</span>]&lt;arrays[child])&#123;<span class="comment">//child==size表示没有右儿子  小根堆 ，往较小的儿子下滤，较小的儿子上移</span></span><br><span class="line">				child++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(temp&gt;arrays[child])</span><br><span class="line">				arrays[hole] = arrays[child];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		arrays[hole] = temp; </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h5 id="buildHeap操作"><a href="#buildHeap操作" class="headerlink" title="buildHeap操作"></a>buildHeap操作</h5><p>初始集合如何获得堆结构？一次一次的percDown即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinaryHeap</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">		size = arr.length;</span><br><span class="line">		arrays = <span class="keyword">new</span> <span class="keyword">int</span>[size*<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">			arrays[i+<span class="number">1</span>] = arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">		buildHeap();</span><br><span class="line">		System.out.println(Arrays.toString(arrays));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = size/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">			percDown(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>注意：二叉堆只保证节点的元素比起后代更小（或更大），并没有保证同一级的节点的大小关系。<br>所以：利用小根堆找最大值是不可行的，因为最大值只能确定存在于叶子节点，但是叶子占了一半的位置。<br>堆排序的原理是先构建二叉堆，然后一次一次的剔除，重建，剔除，重建…将数组从后到前进行排序。若要对数组进行从小到大排序，需要构建<strong>大根堆</strong>！</p>
<h4 id="堆排序的实现"><a href="#堆排序的实现" class="headerlink" title="堆排序的实现"></a>堆排序的实现</h4><p>堆是一种特殊的树形数据结构，其每个节点都有一个值，通常提到的堆都是指一颗完全二叉树，根结点的值小于（或大于）两个子节点的值，同时，根节点的两个子树也分别是一个堆。<br><img src="http://oli0whb3w.bkt.clouddn.com/faffasfeweffffff" alt="enter image description here"><br>堆排序就是利用堆（假设利用大根堆）进行排序的方法。它的基本思想是，将待排序的序列构造成一个大根堆。此时，整个序列的最大值就是堆顶的根节点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的 n-1 个序列重新构造成一个堆，这样就会得到 n 个元素中次大的值。如此反复执行，便能得到一个有序序列了。<br>堆排序的实现需要解决的两个关键问题：<br>（1）<strong>将一个无序序列构成一个堆</strong>。<br>（2）<strong>输出堆顶元素后，调整剩余元素成为一个新堆</strong>。</p>
<ul>
<li>时间复杂度：O(n logn)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySort2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = arr.length;</span><br><span class="line">		<span class="comment">// 构建大根堆</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			percDown(arr, i, len - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">			arr[i] = arr[<span class="number">0</span>];</span><br><span class="line">			arr[<span class="number">0</span>] = temp;</span><br><span class="line">			percDown(arr, <span class="number">0</span>, i);</span><br><span class="line">			System.out.println(Arrays.toString(arr));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr 排序数组也是堆数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> i 从i元素开始下滤</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> n </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">percDown</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">// 下滤</span></span><br><span class="line">		<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">		<span class="keyword">int</span> child;</span><br><span class="line">		<span class="keyword">for</span> (child = leftChild(i); leftChild(i) &lt; n; i = child) &#123;<span class="comment">// i父，child子//此处和标准二叉堆不同，数组下标从0开始，因此是&lt;没有=</span></span><br><span class="line">			child = leftChild(i);</span><br><span class="line">			<span class="keyword">if</span> (child != n-<span class="number">1</span> &amp;&amp; arr[child] &lt; arr[child + <span class="number">1</span>]) &#123;<span class="comment">// 大根堆，往大儿子下滤</span></span><br><span class="line">				child++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp &lt; arr[child])</span><br><span class="line">				arr[i] = arr[child];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[i] = temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="comment">// 数组下标从0开始</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">21</span>, <span class="number">42</span>, <span class="number">32</span>, <span class="number">21</span>, <span class="number">12</span>, <span class="number">41</span>, <span class="number">10</span> &#125;;</span><br><span class="line">		heapSort(arr);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>合并排序比堆排序稍微快一点，但是需要比堆排序多一倍的内存空间，因为它需要一个额外的数组。归并排序是一种比较占内存，但却效率高且稳定的算法。</p>
<ul>
<li>时间复杂度：O(n logn)</li>
<li>空间复杂度：O(n+logn)</li>
<li>稳定性：稳定</li>
</ul>
<p>步骤：<br>（1）申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>（2）设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>（3）比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>（4）重复步骤3直到某一指针达到序列尾<br>（5）将另一序列剩下的所有元素直接复制到合并序列尾</p>
<p>关键操作是merge，即合并两个排好序的表啊表。<strong>合并的基本算法是输入两个数组A和B，一个输出数组C，以及3个计数器Acount,Bcount,Ccount。</strong>A[Acount]、B[Bcount]中的较小者被拷贝到C中的下一位置，相关的计数器向前推进一步。当两个输入表的一方用完，另一方拷贝剩余部分到C中。<strong>每一步merge操作的最后最后将tempArr中排好序的序列拷贝至对应的源数组中</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] tempArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">		</span><br><span class="line">		mergeSort(arr,tempArr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span>[] tempArr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">			<span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">			mergeSort(arr, tempArr, left, mid);</span><br><span class="line">			mergeSort(arr, tempArr, mid+<span class="number">1</span>, right);</span><br><span class="line">			merge(arr,tempArr,left,mid+<span class="number">1</span>,right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr 原数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> tempArr 临时数组，用于存储合并后的元素</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> leftPointer 左指针</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> rightPointer 右指针</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> rightEnd 右半部数组的结束点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span>[] tempArr,<span class="keyword">int</span> leftPointer,<span class="keyword">int</span> rightPointer,<span class="keyword">int</span> rightEnd)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> tempIndex = leftPointer;<span class="comment">//临时数组指针</span></span><br><span class="line">		<span class="keyword">int</span> leftEnd = rightPointer-<span class="number">1</span>;<span class="comment">//左数组结束点</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> mergeCount = rightEnd-leftPointer+<span class="number">1</span>;<span class="comment">//记录合并的数列的个数，用于最后的拷贝</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(leftPointer&lt;=leftEnd&amp;&amp;rightPointer&lt;=rightEnd)&#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[leftPointer]&lt;arr[rightPointer])</span><br><span class="line">				tempArr[tempIndex++] = arr[leftPointer++];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				tempArr[tempIndex++] = arr[rightPointer++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(leftPointer&gt;leftEnd)&#123;<span class="comment">//左为空</span></span><br><span class="line">			<span class="keyword">while</span>(rightPointer&lt;=rightEnd)</span><br><span class="line">				tempArr[tempIndex++] = arr[rightPointer++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(rightPointer&gt;rightEnd)&#123;</span><br><span class="line">			<span class="keyword">while</span>(leftPointer&lt;=leftEnd)</span><br><span class="line">				tempArr[tempIndex++] = arr[leftPointer++];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将排好序的队列拷贝到原数组中</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;mergeCount;i++)&#123;</span><br><span class="line">			arr[rightEnd] = tempArr[rightEnd];</span><br><span class="line">			rightEnd--;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">15</span>,<span class="number">14</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">		MergeSort ms = <span class="keyword">new</span> MergeSort();</span><br><span class="line">		ms.mergeSort(arr);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">	&#125;</span><br><span class="line">[<span class="number">14</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">14</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>平均运行时间是O(n logn)，该算法之所以快，是因为非常精炼和高度优化的内部循环。像归并排序一样，快速排序也是一种分治的递归算法。</p>
<ul>
<li>时间复杂度：O(n logn)</li>
<li>空间复杂度：O(logn)</li>
<li>稳定性：不稳定</li>
</ul>
<p><strong>“经典快速“</strong>排序的步骤：<br>（1） 如果不多于1个数据，直接返回。<br>（2） <strong>选取</strong>序列中的某一个元素作为支点数据（pivot，枢纽元）。<br>（3） 将序列<strong>分割</strong>2部分，一部分都大于支点数据，另外一部分都小于支点数据。<br>（4） 对两边利用递归排序数列。</p>
<h4 id="枢纽元的选取"><a href="#枢纽元的选取" class="headerlink" title="枢纽元的选取"></a>枢纽元的选取</h4><ul>
<li>错误做法一：选取第一个元素。预排序或倒序将会产生恶劣的分割。</li>
<li>错误做法二：随机选取，虽然安全，但是随机的开销太大。</li>
</ul>
<p><strong>三数中值分割法</strong>（Median-ofTree Partitioning）<br>选取序列中左中右的中值作为枢纽元。</p>
<h4 id="分割策略"><a href="#分割策略" class="headerlink" title="分割策略"></a>分割策略</h4><p>枢纽元与最后一个元素进行交换，<strong>i</strong>指向第一个元素，j指向枢纽元之前的元素。<strong>i</strong>和<strong>j</strong>指向的元素分别于枢纽元进行比较，当<strong>i</strong>指向的元素小于枢纽元时<strong>i++</strong>，否则不移动；同样当j指向的元素大于枢纽元时，<strong>j–</strong>，否则不移动。当<strong>i</strong>和<strong>j</strong>都停止不动时，交换<strong>i</strong>和<strong>j</strong>的值。比较停止的条件是<strong>i&gt;j</strong>。</p>
<h5 id="停还是不停？"><a href="#停还是不停？" class="headerlink" title="停还是不停？"></a>停还是不停？</h5><p>当i或j与枢纽元相等时，好一点的做法是指针停止，进行交换。</p>
<h4 id="小数组"><a href="#小数组" class="headerlink" title="小数组"></a>小数组</h4><p>对于小数组，快速排序不如插入排序，因此在数组数量小于一个值时，可以选择插入排序。由于快速排序是递归的，因此这种情况经常发生。一种好的截止范围是N=10；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUICK_SORT_LIMIT = <span class="number">10</span>;<span class="comment">//当排序元素小于改数用插入排序，提高约15%的效率</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">		quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> right left和right决定了排序的序列区间</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(left+QUICK_SORT_LIMIT&lt;=right)&#123;</span><br><span class="line">			<span class="keyword">int</span> pivot = median3(arr, left, right);<span class="comment">//用于比较的枢纽元</span></span><br><span class="line">			<span class="keyword">int</span> i = left;</span><br><span class="line">			<span class="keyword">int</span> j = right-<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">				<span class="keyword">while</span>(arr[++i]&lt;pivot)&#123;&#125;<span class="comment">//小移</span></span><br><span class="line">				<span class="keyword">while</span>(arr[--j]&gt;pivot)&#123;&#125;<span class="comment">//大移</span></span><br><span class="line">				<span class="keyword">if</span> (i &lt; j)<span class="comment">//i=j或i&gt;j不需交换</span></span><br><span class="line">					swapReference(arr, i, j);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">					</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * ij可能存在等于的情况，此时i=j=pivot，此时应该终止判断</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">			&#125;</span><br><span class="line">			swapReference(arr, i, right-<span class="number">1</span>);<span class="comment">//恢复枢纽元的位置</span></span><br><span class="line">			</span><br><span class="line">			quickSort(arr,left,i-<span class="number">1</span>);<span class="comment">//i此时为枢纽元，不需再进行排序了</span></span><br><span class="line">			quickSort(arr,i+<span class="number">1</span>,right);</span><br><span class="line">		</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			insertSort(arr,left,right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 简单插入排序</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> j;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> p = left+<span class="number">1</span>;p&lt;=right;p++)&#123;</span><br><span class="line">			<span class="keyword">int</span> temp = a[p];</span><br><span class="line">			<span class="keyword">for</span>(j = p;j&gt;left&amp;&amp;temp&lt;a[j-<span class="number">1</span>];j--)</span><br><span class="line">				a[j] = a[j-<span class="number">1</span>];</span><br><span class="line">			a[j] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 三数中值分割法</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 该方法将会对原数组中的左中右三个数进行提前排序，并将中值（即枢纽元）放置到倒数第二个位置。</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr 原数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> left 左</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> right 右</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回左中右中中位数的值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">median3</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(arr[left]&gt;arr[mid])</span><br><span class="line">			swapReference(arr, left, mid);</span><br><span class="line">		<span class="keyword">if</span>(arr[left]&gt;arr[right])</span><br><span class="line">			swapReference(arr, left, right);</span><br><span class="line">		<span class="keyword">if</span>(arr[mid]&gt;arr[right])</span><br><span class="line">			swapReference(arr, mid, right);</span><br><span class="line">		</span><br><span class="line">		swapReference(arr, mid, right-<span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> arr[right-<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 交换a，b下标的元素</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swapReference</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = arr[a];</span><br><span class="line">		arr[a] = arr[b];</span><br><span class="line">		arr[b] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		QuickSort qs = <span class="keyword">new</span> QuickSort();</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123; <span class="number">20</span>,<span class="number">19</span>,<span class="number">18</span>,<span class="number">17</span>,<span class="number">16</span>,<span class="number">15</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span> &#125;;</span><br><span class="line">		qs.quickSort(arr);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/排序算法/" rel="tag"># 排序算法</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/14/数据结构与算法分析 二叉树的遍历/" rel="next" title="数据结构与算法分析 二叉树的遍历">
                <i class="fa fa-chevron-left"></i> 数据结构与算法分析 二叉树的遍历
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/14/数据结构与算法分析（JAVA描述）（第二章 算法分析）/" rel="prev" title="数据结构与算法分析（JAVA描述）（第二章 算法分析）">
                数据结构与算法分析（JAVA描述）（第二章 算法分析） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Wch</p>
              <p class="site-description motion-element" itemprop="description">Java后端技术积累</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">68</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构与算法分析-排序算法总结"><span class="nav-number">1.</span> <span class="nav-text">数据结构与算法分析 排序算法总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#各排序算法复杂度比较"><span class="nav-number">1.0.1.</span> <span class="nav-text">各排序算法复杂度比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#冒泡排序"><span class="nav-number">1.0.2.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择排序"><span class="nav-number">1.0.3.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插入排序"><span class="nav-number">1.0.4.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#希尔排序"><span class="nav-number">1.0.5.</span> <span class="nav-text">希尔排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆排序"><span class="nav-number">1.0.6.</span> <span class="nav-text">堆排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉堆复习"><span class="nav-number">1.0.6.1.</span> <span class="nav-text">二叉堆复习</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#上滤"><span class="nav-number">1.0.6.1.1.</span> <span class="nav-text">上滤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#下滤"><span class="nav-number">1.0.6.1.2.</span> <span class="nav-text">下滤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#buildHeap操作"><span class="nav-number">1.0.6.1.3.</span> <span class="nav-text">buildHeap操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆排序的实现"><span class="nav-number">1.0.6.2.</span> <span class="nav-text">堆排序的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#归并排序"><span class="nav-number">1.0.7.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速排序"><span class="nav-number">1.0.8.</span> <span class="nav-text">快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#枢纽元的选取"><span class="nav-number">1.0.8.1.</span> <span class="nav-text">枢纽元的选取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分割策略"><span class="nav-number">1.0.8.2.</span> <span class="nav-text">分割策略</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#停还是不停？"><span class="nav-number">1.0.8.2.1.</span> <span class="nav-text">停还是不停？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小数组"><span class="nav-number">1.0.8.3.</span> <span class="nav-text">小数组</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

     <div id="music163player">
         <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=386829&auto=0&height=32"></iframe>
     </div>

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wch</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">170.2k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
